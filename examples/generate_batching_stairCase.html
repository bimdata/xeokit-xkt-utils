<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>buildBoxGeometry</title>
    <link href="css/styles.css" type="text/css" rel="stylesheet"/>

    <style>
        #myCanvas {
            width: 100%;
            height: 100%;
            background: lightBlue;
        }
    </style>

</head>

<body>
<canvas id="myCanvas"></canvas>
<div id="info">
    <h1>buildBoxGeometry, buildCylinderGeometry</h1><br>
    <p>Batched stair geometries</p><br>
    <div id="log">Loading JavaScript modules...</div>

</div>
</body>
<script type="module">

    import {
        DirLight,
        LightMap, ReflectionMap,
        Viewer,
        XKTLoaderPlugin
    } from "./build/xeokit-components.js";

    import {
        XKTModel,
        buildBoxGeometry,
        writeXKTModelToArrayBuffer,
        validateXKTArrayBuffer, buildCylinderGeometry
    } from "./../dist/xeokit-xkt-utils.es.js";
    import {math} from "../src/lib/math.js";

    const viewer = new Viewer({
        canvasId: "myCanvas",
        pbrEnabled: true,
        transparent: true
    });

    viewer.scene.camera.eye = [-78.72698072181812, 38.69546133152244, 16.954843608074185];
    viewer.scene.camera.look = [1.0769824143608275e-8, 19.999999999999897, -9.3081453655941e-10];
    viewer.scene.camera.up = [0.22106724402219707, 0.9740957853407151, -0.047609606193351674];

    viewer.cameraControl.navMode = "orbit";
    viewer.cameraControl.followPointer = true;

    //------------------------------------------------------------------------------------------------------------------
    // Configure lighting
    //------------------------------------------------------------------------------------------------------------------

    viewer.scene.gammaOutput = true;

    viewer.scene.clearLights();

    new DirLight(viewer.scene, {
        dir: [-50, -50, -50],
        color: [1.0, 1.0, 1.0],
        intensity: 1.0,
        space: "world"
    });

    new ReflectionMap(viewer.scene, {
        src: [
            "textures/reflect/desertRoad/px.png",
            "textures/reflect/desertRoad/nx.png",
            "textures/reflect/desertRoad/py.png",
            "textures/reflect/desertRoad/ny.png",
            "textures/reflect/desertRoad/pz.png",
            "textures/reflect/desertRoad/nz.png"
        ],
        encoding: "sRGB"
    });

    new LightMap(viewer.scene, {
        src: [
            "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PX.png",
            "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NX.png",
            "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PY.png",
            "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NY.png",
            "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PZ.png",
            "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NZ.png"
        ],
        encoding: "sRGB"
    });

    function log(msg) {
        document.getElementById("log").innerHTML += "<br>" + msg;
    }

    log("Generating XKTModel..");

    const xktModel = new XKTModel();

    const box = buildBoxGeometry({
        center: [0, 0, 0],
        xSize: 10,  // Half-size on each axis
        ySize: 0.5,
        zSize: 3
    });

    for (let i = 0; i < 360; i += 20) {

        const matrix = math.identityMat4();
        const translationMat = math.translationMat4v([-10, i / 8, 0]);
        const rotationMat = math.rotationMat4v(i * math.DEGTORAD, [0, 1, 0]);

        math.mulMat4(matrix, rotationMat, matrix);
        math.mulMat4(matrix, translationMat, matrix);

        xktModel.createGeometry({
            geometryId: "boxGeometry" + i,
            primitiveType: box.primitiveType, // Will be "triangles"
            positions: box.positions,
            normals: box.normals,
            indices: box.indices
        });

        xktModel.createMesh({
            meshId: "boxMesh" + i,
            geometryId: "boxGeometry" + i,
            matrix: matrix,
            color: [1, 1, 0],
            metallic: 1.0,
            roughness: 0.7,
            opacity: 1
        });

        xktModel.createEntity({
            entityId: "entity" + i,
            meshIds: ["boxMesh" + i]
        });
    }

    const cylinder = buildCylinderGeometry({
        center: [0, 0, 0],
        radiusTop: 2.0,
        radiusBottom: 2.0,
        height: 60.0,
        radialSegments: 16,
        heightSegments: 1,
        openEnded: false
    });

    xktModel.createGeometry({
        geometryId: "cylinderGeometry",
        primitiveType: cylinder.primitiveType, // Will be "triangles"
        positions: cylinder.positions,
        normals: cylinder.normals,
        indices: cylinder.indices
    });

    xktModel.createMesh({
        meshId: "cylinderMesh",
        geometryId: "cylinderGeometry",
        position: [0, 20, 0],
        scale: [1, 1, 1],
        rotation: [0, 0, 0],
        color: [1, 1, 1],
        metallic: 1.0,
        roughness: 0.5,
        opacity: 1
    });

    xktModel.createEntity({
        entityId: "staircase",
        meshIds: ["cylinderMesh"]
    });

    xktModel.finalize();

    log("Writing XKTModel to array buffer..");

    const xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel);

    log("Validating array buffer..");

    const xktArrayBufferValid = validateXKTArrayBuffer(xktArrayBuffer, xktModel);

    log(xktArrayBufferValid ? "VALID" : "ERRORS (see JS console for log)");

    log("Loading array buffer with XKTLoaderPlugin..");

    const xktLoader = new XKTLoaderPlugin(viewer);

    const model = xktLoader.load({
        id: "myModel",
        xkt: xktArrayBuffer,
        edges: false
    });

</script>
</html>