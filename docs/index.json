[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/XKTModel/KDNode.js",
    "content": "/**\n * A kd-Tree node, used internally by {@link XKTModel}.\n *\n * @private\n */\nclass KDNode {\n\n    /**\n     * Create a KDNode with an axis-aligned 3D World-space boundary.\n     */\n    constructor(aabb) {\n\n        /**\n         * The axis-aligned 3D World-space boundary of this KDNode.\n         *\n         * @type {Float32Array}\n         */\n        this.aabb = aabb;\n\n        /**\n         * The {@link XKTEntity}s within this KDNode.\n         */\n        this.entities = null;\n\n        /**\n         * The left child KDNode.\n         */\n        this.left = null;\n\n        /**\n         * The right child KDNode.\n         */\n        this.right = null;\n    }\n}\n\nexport {KDNode};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/XKTModel/KDNode.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "KDNode",
    "memberof": "src/XKTModel/KDNode.js",
    "static": true,
    "longname": "src/XKTModel/KDNode.js~KDNode",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/KDNode.js",
    "importStyle": "{KDNode}",
    "description": "A kd-Tree node, used internally by {@link XKTModel}.",
    "lineNumber": 6,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#constructor",
    "access": "public",
    "description": "Create a KDNode with an axis-aligned 3D World-space boundary.",
    "lineNumber": 11
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "aabb",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#aabb",
    "access": "public",
    "description": "The axis-aligned 3D World-space boundary of this KDNode.",
    "lineNumber": 18,
    "type": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "entities",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#entities",
    "access": "public",
    "description": "The {@link XKTEntity}s within this KDNode.",
    "lineNumber": 23,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "left",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#left",
    "access": "public",
    "description": "The left child KDNode.",
    "lineNumber": 28,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "right",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#right",
    "access": "public",
    "description": "The right child KDNode.",
    "lineNumber": 33,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "file",
    "name": "src/XKTModel/MockXKTModel.js",
    "content": "import {math} from \"../lib/math.js\";\nimport {geometryCompression} from \"./lib/geometryCompression.js\";\nimport {buildEdgeIndices} from \"./lib/buildEdgeIndices.js\";\n\nconst tempVec4a = math.vec4([0, 0, 0, 1]);\nconst tempVec4b = math.vec4([0, 0, 0, 1]);\nconst tempMat4 = math.mat4();\nconst tempMat4b = math.mat4();\n\n/**\n * A mock {@link XKTModel} that creates {@link Mesh}es and {@link Geometry}s to visualize the output of {@link parseGLTFIntoXKTModel}.\n *\n * @private\n */\nclass MockXKTModel {\n\n    /**\n     *\n     * @param cfg\n     */\n    constructor(cfg={}) {\n\n        if (!cfg.handlePrimitive) {\n            throw \"Expected config: handlePrimitive\";\n        }\n\n        if (!cfg.handleEntity) {\n            throw \"Expected config: handleEntity\";\n        }\n\n        this._handlePrimitive = cfg.handlePrimitive;\n        this._handleEntity = cfg.handleEntity;\n\n        this.geometries = {};\n    }\n\n    createGeometry(params) {\n\n        const geometryId = params.geometryId;\n        const primitiveType = params.primitiveType;\n        const reused = params.reused;\n        const primitiveModelingMatrix = params.primitiveModelingMatrix ? params.primitiveModelingMatrix.slice : math.identityMat4();\n        const color = params.color;\n        const opacity = params.opacity;\n        const positions = params.positions.slice();\n        const normals = params.normals.slice();\n        const indices = params.indices;\n\n        const positions2 = positions.slice();\n\n        const edgeIndices = buildEdgeIndices(positions, indices, null, 10);\n\n        if (!reused) {\n\n            // Bake single-use geometry's positions into World-space\n\n            for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                tempVec4a[0] = positions[i + 0];\n                tempVec4a[1] = positions[i + 1];\n                tempVec4a[2] = positions[i + 2];\n\n                math.transformPoint4(primitiveModelingMatrix, tempVec4a, tempVec4b);\n\n                positions2[i + 0] = tempVec4b[0];\n                positions2[i + 1] = tempVec4b[1];\n                positions2[i + 2] = tempVec4b[2];\n            }\n        }\n\n        const modelNormalMatrix = math.inverseMat4(math.transposeMat4(primitiveModelingMatrix, tempMat4b), tempMat4);\n        const normalsOctEncoded = new Int8Array(normals.length);\n\n        geometryCompression.transformAndOctEncodeNormals(modelNormalMatrix, normals, normals.length, normalsOctEncoded, 0);\n\n        const primitive = new VBOGeometry(this.scene, {\n            id: geometryId,\n            primitive: \"triangles\",\n            positions: positions2,\n            normals: normals,\n            indices: indices,\n            edgeIndices: edgeIndices\n        });\n\n        this.geometries[geometryId] = primitive;\n    }\n\n    createEntity(params) {\n\n        const entityId = params.entityId;\n        const entityModelingMatrix = params.entityModelingMatrix ? params.entityModelingMatrix.slice() : math.identityMat4();\n        const primitiveIds = params.primitiveIds;\n\n        for (let primitiveIdIdx = 0, primitiveIdLen = primitiveIds.length; primitiveIdIdx < primitiveIdLen; primitiveIdIdx++) {\n\n            const geometryId = primitiveIds[primitiveIdIdx];\n            const primitive = this.geometries[geometryId];\n\n            if (!primitive) {\n                console.error(\"primitive not found: \" + geometryId);\n                continue;\n            }\n\n            new Mesh(this.scene, {\n                id: entityId,\n                geometry: primitive,\n                matrix: entityModelingMatrix,\n                edges: true\n            });\n        }\n    }\n\n    finalize() {\n    }\n}\n\nexport {MockXKTModel};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/XKTModel/MockXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 56,
    "kind": "variable",
    "name": "tempVec4a",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~tempVec4a",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/MockXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 57,
    "kind": "variable",
    "name": "tempVec4b",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~tempVec4b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/MockXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 58,
    "kind": "variable",
    "name": "tempMat4",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~tempMat4",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/MockXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 59,
    "kind": "variable",
    "name": "tempMat4b",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~tempMat4b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/MockXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 60,
    "kind": "class",
    "name": "MockXKTModel",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/MockXKTModel.js",
    "importStyle": "{MockXKTModel}",
    "description": "A mock {@link XKTModel} that creates {@link Mesh}es and {@link Geometry}s to visualize the output of {@link parseGLTFIntoXKTModel}.",
    "lineNumber": 15,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 61,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "_handlePrimitive",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#_handlePrimitive",
    "access": "private",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "_handleEntity",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#_handleEntity",
    "access": "private",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "member",
    "name": "geometries",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#geometries",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "method",
    "name": "createGeometry",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#createGeometry",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "createEntity",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#createEntity",
    "access": "public",
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "finalize",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#finalize",
    "access": "public",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 68,
    "kind": "file",
    "name": "src/XKTModel/XKTEntity.js",
    "content": "import {math} from \"../lib/math.js\";\n\n/**\n * An object within an {@link XKTModel}.\n *\n * * Created by {@link XKTModel#createEntity}\n * * Stored in {@link XKTModel#entities} and {@link XKTModel#entitiesList}\n * * Has one or more {@link XKTMesh}s, each having an {@link XKTGeometry}\n *\n * @class XKTEntity\n */\nclass XKTEntity {\n\n    /**\n     * @private\n     * @param entityId\n     * @param meshes\n     */\n    constructor(entityId,  meshes) {\n\n        /**\n         * Unique ID of this ````XKTEntity```` in {@link XKTModel#entities}.\n         *\n         * For a BIM model, this will be an IFC product ID.\n         *\n         * @type {String}\n         */\n        this.entityId = entityId;\n\n        /**\n         * Index of this ````XKTEntity```` in {@link XKTModel#entitiesList}.\n         *\n         * Set by {@link XKTModel#finalize}.\n         *\n         * @type {Number}\n         */\n        this.entityIndex = 0;\n\n        /**\n         * A list of {@link XKTMesh}s that indicate which {@link XKTGeometry}s are used by this Entity.\n         *\n         * @type {XKTMesh[]}\n         */\n        this.meshes = meshes;\n\n        /**\n         * World-space axis-aligned bounding box (AABB) that encloses the {@link XKTGeometry#positions} of\n         * the {@link XKTGeometry}s that are used by this ````XKTEntity````.\n         *\n         * Set by {@link XKTModel#finalize}.\n         *\n         * @type {Float32Array}\n         */\n        this.aabb = math.AABB3();\n\n        /**\n         * Indicates if this ````XKTEntity```` shares {@link XKTGeometry}s with other {@link XKTEntity}'s.\n         *\n         * Set by {@link XKTModel#finalize}.\n         *\n         * Note that when an ````XKTEntity```` shares ````XKTGeometrys````, it shares **all** of its ````XKTGeometrys````. An ````XKTEntity````\n         * never shares only some of its ````XKTGeometrys```` - it always shares either the whole set or none at all.\n         *\n         * @type {Boolean}\n         */\n        this.hasReusedGeometries = false;\n    }\n}\n\nexport {XKTEntity};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/XKTModel/XKTEntity.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 69,
    "kind": "class",
    "name": "XKTEntity",
    "memberof": "src/XKTModel/XKTEntity.js",
    "static": true,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTEntity.js",
    "importStyle": "{XKTEntity}",
    "description": "An object within an {@link XKTModel}.\n\n* Created by {@link XKTModel#createEntity}\n* Stored in {@link XKTModel#entities} and {@link XKTModel#entitiesList}\n* Has one or more {@link XKTMesh}s, each having an {@link XKTGeometry}",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTEntity"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 70,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "entityId",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "meshes",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 71,
    "kind": "member",
    "name": "entityId",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#entityId",
    "access": "public",
    "description": "Unique ID of this ````XKTEntity```` in {@link XKTModel#entities}.\n\nFor a BIM model, this will be an IFC product ID.",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 72,
    "kind": "member",
    "name": "entityIndex",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#entityIndex",
    "access": "public",
    "description": "Index of this ````XKTEntity```` in {@link XKTModel#entitiesList}.\n\nSet by {@link XKTModel#finalize}.",
    "lineNumber": 37,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 73,
    "kind": "member",
    "name": "meshes",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#meshes",
    "access": "public",
    "description": "A list of {@link XKTMesh}s that indicate which {@link XKTGeometry}s are used by this Entity.",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "XKTMesh[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 74,
    "kind": "member",
    "name": "aabb",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#aabb",
    "access": "public",
    "description": "World-space axis-aligned bounding box (AABB) that encloses the {@link XKTGeometry#positions} of\nthe {@link XKTGeometry}s that are used by this ````XKTEntity````.\n\nSet by {@link XKTModel#finalize}.",
    "lineNumber": 54,
    "type": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 75,
    "kind": "member",
    "name": "hasReusedGeometries",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#hasReusedGeometries",
    "access": "public",
    "description": "Indicates if this ````XKTEntity```` shares {@link XKTGeometry}s with other {@link XKTEntity}'s.\n\nSet by {@link XKTModel#finalize}.\n\nNote that when an ````XKTEntity```` shares ````XKTGeometrys````, it shares **all** of its ````XKTGeometrys````. An ````XKTEntity````\nnever shares only some of its ````XKTGeometrys```` - it always shares either the whole set or none at all.",
    "lineNumber": 66,
    "type": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 76,
    "kind": "file",
    "name": "src/XKTModel/XKTGeometry.js",
    "content": "/**\n * An element of reusable geometry within an {@link XKTModel}.\n *\n * * Created by {@link XKTModel#createGeometry}\n * * Stored in {@link XKTModel#geometries} and {@link XKTModel#geometriesList}\n * * Referenced by {@link XKTMesh}s, which belong to {@link XKTEntity}s\n *\n * @class XKTGeometry\n */\nclass XKTGeometry {\n\n    /**\n     * @private\n     * @param {*} cfg Configuration for the XKTGeometry.\n     * @param {Number} cfg.geometryId Unique ID of the geometry in {@link XKTModel#geometries}.\n     * @param {String} cfg.primitiveType Type of this geometry - \"triangles\", \"points\" or \"lines\" so far.\n     * @param {Number} cfg.geometryIndex Index of this XKTGeometry in {@link XKTModel#geometriesList}.\n     * @param {Float64Array} cfg.positions Non-quantized 3D vertex positions.\n     * @param {Float32Array} cfg.normals Non-compressed vertex normals.\n     * @param {Uint8Array} cfg.colorsCompressed Integer RGB vertex colors.\n     * @param {Uint32Array} cfg.indices Indices to organize the vertex positions and normals into triangles.\n     * @param {Uint32Array} cfg.edgeIndices Indices to organize the vertex positions into edges.\n     */\n    constructor(cfg) {\n\n        /**\n         * Unique ID of this XKTGeometry in {@link XKTModel#geometries}.\n         *\n         * @type {Number}\n         */\n        this.geometryId = cfg.geometryId;\n\n        /**\n         * The type of primitive - \"triangles\" | \"points\" | \"lines\".\n         *\n         * @type {String}\n         */\n        this.primitiveType = cfg.primitiveType;\n\n        /**\n         * Index of this XKTGeometry in {@link XKTModel#geometriesList}.\n         *\n         * @type {Number}\n         */\n        this.geometryIndex = cfg.geometryIndex;\n\n        /**\n         * The number of {@link XKTMesh}s that reference this XKTGeometry.\n         *\n         * @type {Number}\n         */\n        this.numInstances = 0;\n\n        /**\n         * Non-quantized 3D vertex positions.\n         *\n         * Defined for all primitive types.\n         *\n         * @type {Float64Array}\n         */\n        this.positions = cfg.positions;\n\n        /**\n         * Quantized vertex positions.\n         *\n         * Defined for all primitive types.\n         *\n         * This array is later created from {@link XKTGeometry#positions} by {@link XKTModel#finalize}.\n         *\n         * @type {Uint16Array}\n         */\n        this.positionsQuantized = new Uint16Array(cfg.positions.length);\n\n        /**\n         * Non-compressed 3D vertex normals.\n         *\n         * Defined only for triangle primitives. Ignored for points and lines.\n         *\n         * @type {Float32Array}\n         */\n        this.normals = cfg.normals;\n\n        /**\n         * Compressed vertex normals.\n         *\n         * Defined only for triangle primitives. Ignored for points and lines.\n         *\n         * This array is later created from {@link XKTGeometry#normals} by {@link XKTModel#finalize}.\n         *\n         * @type {Int8Array}\n         */\n        this.normalsOctEncoded = null;\n\n        /**\n         * Compressed RGB vertex colors.\n         *\n         * Defined only for point primitives. Ignored for triangles and lines.\n         *\n         * @type {Float32Array}\n         */\n        this.colorsCompressed = cfg.colorsCompressed;\n\n        /**\n         * Indices that organize the vertex positions and normals as triangles.\n         *\n         * Defined only for triangle and lines primitives. Ignored for points.\n         *\n         * @type {Uint32Array}\n         */\n        this.indices = cfg.indices;\n\n        /**\n         * Indices that organize the vertex positions as edges.\n         *\n         * Defined only for triangle primitives. Ignored for points and lines.\n         *\n         * @type {Uint32Array}\n         */\n        this.edgeIndices = cfg.edgeIndices;\n\n        /**\n         * When {@link XKTGeometry#primitiveType} is \"triangles\", this is ````true```` when this geometry is a watertight mesh.\n         *\n         * Defined only for triangle primitives. Ignored for points and lines.\n         *\n         * Set by {@link XKTModel#finalize}.\n         *\n         * @type {boolean}\n         */\n        this.solid = false;\n    }\n\n    /**\n     * Convenience property that is ````true```` when {@link XKTGeometry#numInstances} is greater that one.\n     * @returns {boolean}\n     */\n    get reused() {\n        return (this.numInstances > 1);\n    }\n}\n\nexport {XKTGeometry};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/XKTModel/XKTGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 77,
    "kind": "class",
    "name": "XKTGeometry",
    "memberof": "src/XKTModel/XKTGeometry.js",
    "static": true,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTGeometry.js",
    "importStyle": "{XKTGeometry}",
    "description": "An element of reusable geometry within an {@link XKTModel}.\n\n* Created by {@link XKTModel#createGeometry}\n* Stored in {@link XKTModel#geometries} and {@link XKTModel#geometriesList}\n* Referenced by {@link XKTMesh}s, which belong to {@link XKTEntity}s",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTGeometry"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 78,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 24,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg",
        "description": "Configuration for the XKTGeometry."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.geometryId",
        "description": "Unique ID of the geometry in {@link XKTModel#geometries}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.primitiveType",
        "description": "Type of this geometry - \"triangles\", \"points\" or \"lines\" so far."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.geometryIndex",
        "description": "Index of this XKTGeometry in {@link XKTModel#geometriesList}."
      },
      {
        "nullable": null,
        "types": [
          "Float64Array"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.positions",
        "description": "Non-quantized 3D vertex positions."
      },
      {
        "nullable": null,
        "types": [
          "Float32Array"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.normals",
        "description": "Non-compressed vertex normals."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.colorsCompressed",
        "description": "Integer RGB vertex colors."
      },
      {
        "nullable": null,
        "types": [
          "Uint32Array"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.indices",
        "description": "Indices to organize the vertex positions and normals into triangles."
      },
      {
        "nullable": null,
        "types": [
          "Uint32Array"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.edgeIndices",
        "description": "Indices to organize the vertex positions into edges."
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 79,
    "kind": "member",
    "name": "geometryId",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#geometryId",
    "access": "public",
    "description": "Unique ID of this XKTGeometry in {@link XKTModel#geometries}.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 80,
    "kind": "member",
    "name": "primitiveType",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#primitiveType",
    "access": "public",
    "description": "The type of primitive - \"triangles\" | \"points\" | \"lines\".",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 81,
    "kind": "member",
    "name": "geometryIndex",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#geometryIndex",
    "access": "public",
    "description": "Index of this XKTGeometry in {@link XKTModel#geometriesList}.",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 82,
    "kind": "member",
    "name": "numInstances",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#numInstances",
    "access": "public",
    "description": "The number of {@link XKTMesh}s that reference this XKTGeometry.",
    "lineNumber": 52,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 83,
    "kind": "member",
    "name": "positions",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#positions",
    "access": "public",
    "description": "Non-quantized 3D vertex positions.\n\nDefined for all primitive types.",
    "lineNumber": 61,
    "type": {
      "nullable": null,
      "types": [
        "Float64Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 84,
    "kind": "member",
    "name": "positionsQuantized",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#positionsQuantized",
    "access": "public",
    "description": "Quantized vertex positions.\n\nDefined for all primitive types.\n\nThis array is later created from {@link XKTGeometry#positions} by {@link XKTModel#finalize}.",
    "lineNumber": 72,
    "type": {
      "nullable": null,
      "types": [
        "Uint16Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 85,
    "kind": "member",
    "name": "normals",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#normals",
    "access": "public",
    "description": "Non-compressed 3D vertex normals.\n\nDefined only for triangle primitives. Ignored for points and lines.",
    "lineNumber": 81,
    "type": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 86,
    "kind": "member",
    "name": "normalsOctEncoded",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#normalsOctEncoded",
    "access": "public",
    "description": "Compressed vertex normals.\n\nDefined only for triangle primitives. Ignored for points and lines.\n\nThis array is later created from {@link XKTGeometry#normals} by {@link XKTModel#finalize}.",
    "lineNumber": 92,
    "type": {
      "nullable": null,
      "types": [
        "Int8Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 87,
    "kind": "member",
    "name": "colorsCompressed",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#colorsCompressed",
    "access": "public",
    "description": "Compressed RGB vertex colors.\n\nDefined only for point primitives. Ignored for triangles and lines.",
    "lineNumber": 101,
    "type": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 88,
    "kind": "member",
    "name": "indices",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#indices",
    "access": "public",
    "description": "Indices that organize the vertex positions and normals as triangles.\n\nDefined only for triangle and lines primitives. Ignored for points.",
    "lineNumber": 110,
    "type": {
      "nullable": null,
      "types": [
        "Uint32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 89,
    "kind": "member",
    "name": "edgeIndices",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#edgeIndices",
    "access": "public",
    "description": "Indices that organize the vertex positions as edges.\n\nDefined only for triangle primitives. Ignored for points and lines.",
    "lineNumber": 119,
    "type": {
      "nullable": null,
      "types": [
        "Uint32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 90,
    "kind": "member",
    "name": "solid",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#solid",
    "access": "public",
    "description": "When {@link XKTGeometry#primitiveType} is \"triangles\", this is ````true```` when this geometry is a watertight mesh.\n\nDefined only for triangle primitives. Ignored for points and lines.\n\nSet by {@link XKTModel#finalize}.",
    "lineNumber": 130,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 91,
    "kind": "get",
    "name": "reused",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#reused",
    "access": "public",
    "description": "Convenience property that is ````true```` when {@link XKTGeometry#numInstances} is greater that one.",
    "lineNumber": 137,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "file",
    "name": "src/XKTModel/XKTMesh.js",
    "content": "/**\n * Represents the usage of a {@link XKTGeometry} by an {@link XKTEntity}.\n *\n * * Created by {@link XKTModel#createEntity}\n * * Stored in {@link XKTEntity#meshes} and {@link XKTModel#meshesList}\n * * Specifies color and opacity\n *\n * @class XKTMesh\n */\nclass XKTMesh {\n\n    /**\n     * @private\n     */\n    constructor(cfg) {\n\n        /**\n         * Unique ID of this XKTMesh in {@link XKTModel#meshes}.\n         *\n         * @type {Number}\n         */\n        this.meshId = cfg.meshId;\n\n        /**\n         * Index of this XKTMesh in {@link XKTModel#meshesList};\n         *\n         * @type {Number}\n         */\n        this.meshIndex = cfg.meshIndex;\n\n        /**\n         * The 4x4 modeling transform matrix.\n         *\n         * Transform is relative to the center of the {@link XKTTile} that contains this XKTMesh's {@link XKTEntity},\n         * which is given in {@link XKTMesh#entity}.\n         *\n         * When the ````XKTEntity```` shares its {@link XKTGeometry}s with other ````XKTEntity````s, this matrix is used\n         * to transform this XKTMesh's XKTGeometry into World-space. When this XKTMesh does not share its ````XKTGeometry````,\n         * then this matrix is ignored.\n         *\n         * @type {Number[]}\n         */\n        this.matrix = cfg.matrix;\n\n        /**\n         * The instanced {@link XKTGeometry}.\n         *\n         * @type {XKTGeometry}\n         */\n        this.geometry = cfg.geometry;\n\n        /**\n         * RGB color of this XKTMesh.\n         *\n         * @type {Uint8Array}\n         */\n        this.color = cfg.color || new Uint8Array(3);\n\n        /**\n         * PBR metallness of this XKTMesh.\n         *\n         * @type {Number}\n         */\n        this.metallic = (cfg.metallic !== null && cfg.metallic !== undefined) ? cfg.metallic : 0;\n\n        /**\n         * PBR roughness of this XKTMesh.\n         *\n         * @type {Number}\n         */\n        this.roughness = (cfg.roughness !== null && cfg.roughness !== undefined) ? cfg.roughness : 1;\n\n        /**\n         * Opacity of this XKTMesh.\n         *\n         * @type {Number}\n         */\n        this.opacity = (cfg.opacity !== undefined && cfg.opacity !== null) ? cfg.opacity : 1.0;\n\n        /**\n         * The owner {@link XKTEntity}.\n         *\n         * Set by {@link XKTModel#createEntity}.\n         *\n         * @type {XKTEntity}\n         */\n        this.entity = null; // Set after instantiation, when the Entity is known\n    }\n}\n\nexport {XKTMesh};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/XKTModel/XKTMesh.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 93,
    "kind": "class",
    "name": "XKTMesh",
    "memberof": "src/XKTModel/XKTMesh.js",
    "static": true,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTMesh.js",
    "importStyle": "{XKTMesh}",
    "description": "Represents the usage of a {@link XKTGeometry} by an {@link XKTEntity}.\n\n* Created by {@link XKTModel#createEntity}\n* Stored in {@link XKTEntity#meshes} and {@link XKTModel#meshesList}\n* Specifies color and opacity",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTMesh"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 94,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 15,
    "ignore": true
  },
  {
    "__docId__": 95,
    "kind": "member",
    "name": "meshId",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#meshId",
    "access": "public",
    "description": "Unique ID of this XKTMesh in {@link XKTModel#meshes}.",
    "lineNumber": 22,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 96,
    "kind": "member",
    "name": "meshIndex",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#meshIndex",
    "access": "public",
    "description": "Index of this XKTMesh in {@link XKTModel#meshesList};",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 97,
    "kind": "member",
    "name": "matrix",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#matrix",
    "access": "public",
    "description": "The 4x4 modeling transform matrix.\n\nTransform is relative to the center of the {@link XKTTile} that contains this XKTMesh's {@link XKTEntity},\nwhich is given in {@link XKTMesh#entity}.\n\nWhen the ````XKTEntity```` shares its {@link XKTGeometry}s with other ````XKTEntity````s, this matrix is used\nto transform this XKTMesh's XKTGeometry into World-space. When this XKTMesh does not share its ````XKTGeometry````,\nthen this matrix is ignored.",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "Number[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 98,
    "kind": "member",
    "name": "geometry",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#geometry",
    "access": "public",
    "description": "The instanced {@link XKTGeometry}.",
    "lineNumber": 50,
    "type": {
      "nullable": null,
      "types": [
        "XKTGeometry"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 99,
    "kind": "member",
    "name": "color",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#color",
    "access": "public",
    "description": "RGB color of this XKTMesh.",
    "lineNumber": 57,
    "type": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 100,
    "kind": "member",
    "name": "metallic",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#metallic",
    "access": "public",
    "description": "PBR metallness of this XKTMesh.",
    "lineNumber": 64,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 101,
    "kind": "member",
    "name": "roughness",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#roughness",
    "access": "public",
    "description": "PBR roughness of this XKTMesh.",
    "lineNumber": 71,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 102,
    "kind": "member",
    "name": "opacity",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#opacity",
    "access": "public",
    "description": "Opacity of this XKTMesh.",
    "lineNumber": 78,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 103,
    "kind": "member",
    "name": "entity",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#entity",
    "access": "public",
    "description": "The owner {@link XKTEntity}.\n\nSet by {@link XKTModel#createEntity}.",
    "lineNumber": 87,
    "type": {
      "nullable": null,
      "types": [
        "XKTEntity"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 104,
    "kind": "file",
    "name": "src/XKTModel/XKTModel.js",
    "content": "import {math} from \"../lib/math.js\";\nimport {geometryCompression} from \"./lib/geometryCompression.js\";\nimport {buildEdgeIndices} from \"./lib/buildEdgeIndices.js\";\nimport {isTriangleMeshSolid} from \"./lib/isTriangleMeshSolid.js\";\n\nimport {XKTMesh} from './XKTMesh.js';\nimport {XKTGeometry} from './XKTGeometry.js';\nimport {XKTEntity} from './XKTEntity.js';\nimport {XKTTile} from './XKTTile.js';\nimport {KDNode} from \"./KDNode.js\";\n\nconst tempVec4a = math.vec4([0, 0, 0, 1]);\nconst tempVec4b = math.vec4([0, 0, 0, 1]);\n\nconst tempMat4 = math.mat4();\nconst tempMat4b = math.mat4();\n\nconst MIN_TILE_DIAG = 10000;\n\nconst kdTreeDimLength = new Float64Array(3);\n\n/**\n * A document model that represents the contents of an .XKT file.\n *\n * * An XKTModel contains {@link XKTTile}s, which spatially subdivide the model into regions.\n * * Each {@link XKTTile} contains {@link XKTEntity}s, which represent the objects within its region.\n * * Each {@link XKTEntity} has {@link XKTMesh}s, which each have a {@link XKTGeometry}. Each {@link XKTGeometry} can be shared by multiple {@link XKTMesh}s.\n * * Import glTF into an XKTModel using {@link parseGLTFIntoXKTModel}.\n * * Build an XKTModel programmatically using {@link XKTModel#createGeometry}, {@link XKTModel#createMesh} and {@link XKTModel#createEntity}.\n * * Serialize an XKTModel to an ArrayBuffer using {@link writeXKTModelToArrayBuffer}.\n * * Validate an ArrayBuffer against an XKTModel using {@link validateXKTArrayBuffer}.\n *\n * ## Usage\n *\n * See [main docs page](/docs/#javascript-api) for usage examples.\n *\n * @class XKTModel\n */\nclass XKTModel {\n\n    /**\n     * Constructs a new XKTModel.\n     *\n     * @param {*} [cfg] Configuration\n     * @param {Number} [cfg.edgeThreshold=10]\n     */\n    constructor(cfg = {}) {\n\n        /**\n         *\n         * @type {Number|number}\n         */\n        this.edgeThreshold = cfg.edgeThreshold || 10;\n\n        /**\n         * The positions of all shared {@link XKTGeometry}s are de-quantized using this singular\n         * de-quantization matrix.\n         *\n         * This de-quantization matrix is generated from the collective Local-space boundary of the\n         * positions of all shared {@link XKTGeometry}s.\n         *\n         * @type {Float32Array}\n         */\n        this.reusedGeometriesDecodeMatrix = new Float32Array(16);\n\n        /**\n         * Map of {@link XKTGeometry}s within this XKTModel, each mapped to {@link XKTGeometry#geometryId}.\n         *\n         * Created by {@link XKTModel#createGeometry}.\n         *\n         * @type {{Number:XKTGeometry}}\n         */\n        this.geometries = {};\n\n        /**\n         * List of {@link XKTGeometry}s within this XKTModel, in the order they were created.\n         *\n         * Each XKTGeometry holds its position in this list in {@link XKTGeometry#geometryIndex}.\n         *\n         * Created by {@link XKTModel#createGeometry}.\n         *\n         * @type {XKTGeometry[]}\n         */\n        this.geometriesList = [];\n\n        /**\n         * Map of {@link XKTMesh}s within this XKTModel, each mapped to {@link XKTMesh#meshId}.\n         *\n         * Created by {@link XKTModel#createMesh}.\n         *\n         * @type {{Number:XKTMesh}}\n         */\n        this.meshes = {};\n\n        /**\n         * List of {@link XKTMesh}s within this XKTModel, in the order they were created.\n         *\n         * Each XKTMesh holds its position in this list in {@link XKTMesh#meshIndex}.\n         *\n         * Created by {@link XKTModel#createMesh}.\n         *\n         * @type {XKTMesh[]}\n         */\n        this.meshesList = [];\n\n        /**\n         * Map of {@link XKTEntity}s within this XKTModel, each mapped to {@link XKTEntity#entityId}.\n         *\n         * Created by {@link XKTModel#createEntity}.\n         *\n         * @type {{String:XKTEntity}}\n         */\n        this.entities = {};\n\n        /**\n         * {@link XKTEntity}s within this XKTModel.\n         *\n         * Each XKTEntity holds its position in this list in {@link XKTMesh#entityIndex}.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTEntity[]}\n         */\n        this.entitiesList = [];\n\n        /**\n         * {@link XKTTile}s within this Model.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTTile[]}\n         */\n        this.tilesList = [];\n\n        /**\n         * Indicates if this XKTModel has been finalized.\n         *\n         * Set ````true```` by {@link XKTModel#finalize}.\n         *\n         * @type {boolean}\n         */\n        this.finalized = false;\n    }\n\n    /**\n     * Creates an {@link XKTGeometry} within this XKTModel.\n     *\n     * Logs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).\n     *\n     * @param {*} params Method parameters.\n     * @param {Number} params.geometryId Unique ID for the {@link XKTGeometry}.\n     * @param {String} params.primitiveType The type of {@link XKTGeometry}: \"triangles\", \"lines\" or \"points\".\n     * @param {Float64Array} params.positions Floating-point Local-space vertex positions for the {@link XKTGeometry}. Required for all primitive types.\n     * @param {Number[]} [params.normals] Floating-point vertex normals for the {@link XKTGeometry}. Required for triangles primitives. Ignored for points and lines.\n     * @param {Number[]} [params.colors] Floating-point RGBA vertex colors for the {@link XKTGeometry}. Required for points primitives. Ignored for lines and triangles.\n     * @param {Number[]} [params.colorsCompressed] Integer RGBA vertex colors for the {@link XKTGeometry}. Required for points primitives. Ignored for lines and triangles.\n     * @param {Uint32Array} [params.indices] Indices for the {@link XKTGeometry}. Required for triangles and lines primitives. Ignored for points.\n     * @param {Number} [params.edgeThreshold=10]\n     * @returns {XKTGeometry} The new {@link XKTGeometry}.\n     */\n    createGeometry(params) {\n\n        if (!params) {\n            throw \"Parameters expected: params\";\n        }\n\n        if (params.geometryId === null || params.geometryId === undefined) {\n            throw \"Parameter expected: params.geometryId\";\n        }\n\n        if (!params.primitiveType) {\n            throw \"Parameter expected: params.primitiveType\";\n        }\n\n        if (!params.positions) {\n            throw \"Parameter expected: params.positions\";\n        }\n\n        const triangles = params.primitiveType === \"triangles\";\n        const points = params.primitiveType === \"points\";\n        const lines = params.primitiveType === \"lines\";\n\n        if (!triangles && !points && !lines) {\n            throw \"Unsupported value for params.primitiveType: \" + params.primitiveType + \"' - supported values are 'triangles', 'points' and 'lines'\";\n        }\n\n        if (triangles) {\n            if (!params.normals) {\n                throw \"Parameter expected for 'triangles' primitive: params.normals\";\n            }\n            if (!params.indices) {\n                throw \"Parameter expected for 'triangles' primitive: params.indices\";\n            }\n        }\n\n        if (points) {\n            if (!params.colors && !params.colorsCompressed) {\n                throw \"Parameter expected for 'points' primitive: params.colors or params.colorsCompressed\";\n            }\n        }\n\n        if (lines) {\n            if (!params.indices) {\n                throw \"Parameter expected for 'lines' primitive: params.indices\";\n            }\n        }\n\n        if (this.finalized) {\n            console.error(\"XKTModel has been finalized, can't add more geometries\");\n            return;\n        }\n\n        if (this.geometries[params.geometryId]) {\n            console.error(\"XKTGeometry already exists with this ID: \" + params.geometryId);\n            return;\n        }\n\n        const geometryId = params.geometryId;\n        const primitiveType = params.primitiveType;\n        const positions = new Float64Array(params.positions); // May modify in #finalize\n\n        const xktGeometryCfg = {\n            geometryId: geometryId,\n            geometryIndex: this.geometriesList.length,\n            primitiveType: primitiveType,\n            positions: positions\n        }\n\n        if (triangles) {\n            xktGeometryCfg.normals = new Float64Array(params.normals); // May modify in #finalize\n            xktGeometryCfg.indices = params.indices;\n            xktGeometryCfg.edgeIndices = buildEdgeIndices(positions, params.indices, null, params.edgeThreshold || this.edgeThreshold || 10);\n        }\n\n        if (points) {\n            if (params.colorsCompressed) {\n                xktGeometryCfg.colorsCompressed = new Uint8Array(params.colorsCompressed);\n            } else {\n                const colors = params.colors;\n                const colorsCompressed = new Uint8Array(colors.length);\n                for (let i = 0, len = colors.length; i < len; i++) {\n                    colorsCompressed[i] = Math.floor(colors[i] * 255);\n                }\n                xktGeometryCfg.colorsCompressed = colorsCompressed;\n            }\n        }\n\n        if (lines) {\n            xktGeometryCfg.indices = params.indices;\n        }\n\n        const geometry = new XKTGeometry(xktGeometryCfg);\n\n        this.geometries[geometryId] = geometry;\n        this.geometriesList.push(geometry);\n\n        return geometry;\n    }\n\n    /**\n     * Creates an {@link XKTMesh} within this XKTModel.\n     *\n     * An {@link XKTMesh} can be owned by one {@link XKTEntity}, which can own multiple {@link XKTMesh}es.\n     *\n     * @param {*} params Method parameters.\n     * @param {Number} params.meshId Unique ID for the {@link XKTMesh}.\n     * @param {Number} params.geometryId ID of an existing {@link XKTGeometry} in {@link XKTModel#geometries}.\n     * @param {Uint8Array} params.color RGB color for the {@link XKTMesh}, with each color component in range [0..1].\n     * @param {Number} [params.metallic=0] How metallic the {@link XKTMesh} is, in range [0..1]. A value of ````0```` indicates fully dielectric material, while ````1```` indicates fully metallic.\n     * @param {Number} [params.roughness=1] How rough the {@link XKTMesh} is, in range [0..1]. A value of ````0```` indicates fully smooth, while ````1```` indicates fully rough.\n     * @param {Number} params.opacity Opacity factor for the {@link XKTMesh}, in range [0..1].\n     * @param {Float64Array} [params.matrix] Modeling matrix for the {@link XKTMesh}. Overrides ````position````, ````scale```` and ````rotation```` parameters.\n     * @param {Number[]} [params.position=[0,0,0]] Position of the {@link XKTMesh}. Overridden by the ````matrix```` parameter.\n     * @param {Number[]} [params.scale=[1,1,1]] Scale of the {@link XKTMesh}. Overridden by the ````matrix```` parameter.\n     * @param {Number[]} [params.rotation=[0,0,0]] Rotation of the {@link XKTMesh} as Euler angles given in degrees, for each of the X, Y and Z axis. Overridden by the ````matrix```` parameter.\n     * @returns {XKTMesh} The new {@link XKTMesh}.\n     */\n    createMesh(params) {\n\n        if (params.meshId === null || params.meshId === undefined) {\n            throw \"Parameter expected: params.meshId\";\n        }\n\n        if (params.geometryId === null || params.geometryId === undefined) {\n            throw \"Parameter expected: params.geometryId\";\n        }\n\n        // if (!params.color) {\n        //     throw \"Parameter expected: params.color\";\n        // }\n        //\n        // if (params.opacity === null || params.opacity === undefined) {\n        //     throw \"Parameter expected: params.opacity\";\n        // }\n\n        if (this.finalized) {\n            throw \"XKTModel has been finalized, can't add more meshes\";\n        }\n\n        if (this.meshes[params.meshId]) {\n            console.error(\"XKTMesh already exists with this ID: \" + params.meshId);\n            return;\n        }\n\n        const geometry = this.geometries[params.geometryId];\n\n        if (!geometry) {\n            console.error(\"XKTGeometry not found: \" + params.geometryId);\n            return;\n        }\n\n        geometry.numInstances++;\n\n        let matrix = params.matrix;\n\n        if (!matrix) {\n\n            const position = params.position;\n            const scale = params.scale;\n            const rotation = params.rotation;\n\n            if (position || scale || rotation) {\n                matrix = math.identityMat4();\n                const quaternion = math.eulerToQuaternion(rotation || [0, 0, 0], \"XYZ\", math.identityQuaternion());\n                math.composeMat4(position || [0, 0, 0], quaternion, scale || [1, 1, 1], matrix)\n\n            } else {\n                matrix = math.identityMat4();\n            }\n        }\n\n        const meshIndex = this.meshesList.length;\n\n        const mesh = new XKTMesh({\n            meshId: params.meshId,\n            meshIndex: meshIndex,\n            matrix: matrix,\n            geometry: geometry,\n            color: params.color,\n            metallic: params.metallic,\n            roughness: params.roughness,\n            opacity: params.opacity\n        });\n\n        this.meshes[mesh.meshId] = mesh;\n        this.meshesList.push(mesh);\n\n        return mesh;\n    }\n\n    /**\n     * Creates an {@link XKTEntity} within this XKTModel.\n     *\n     * Logs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).\n     *\n     * @param {*} params Method parameters.\n     * @param {String} params.entityId Unique ID for the {@link XKTEntity}.\n     * @param {String[]} params.meshIds IDs of {@link XKTMesh}es used by the {@link XKTEntity}. Note that each {@link XKTMesh} can only be used by one {@link XKTEntity}.\n     * @returns {XKTEntity} The new {@link XKTEntity}.\n     */\n    createEntity(params) {\n\n        if (!params) {\n            throw \"Parameters expected: params\";\n        }\n\n        if (params.entityId === null || params.entityId === undefined) {\n            throw \"Parameter expected: params.entityId\";\n        }\n\n        if (!params.meshIds) {\n            throw \"Parameter expected: params.meshIds\";\n        }\n\n        if (this.finalized) {\n            console.error(\"XKTModel has been finalized, can't add more entities\");\n            return;\n        }\n\n        if (this.entities[params.entityId]) {\n            console.error(\"XKTEntity already exists with this ID: \" + params.entityId);\n            return;\n        }\n\n        const entityId = params.entityId;\n        const meshIds = params.meshIds;\n        const meshes = [];\n\n        for (let meshIdIdx = 0, meshIdLen = meshIds.length; meshIdIdx < meshIdLen; meshIdIdx++) {\n\n            const meshId = meshIds[meshIdIdx];\n            const mesh = this.meshes[meshId];\n\n            if (!mesh) {\n                console.error(\"XKTMesh found: \" + meshId);\n                continue;\n            }\n\n            if (mesh.entity) {\n                console.error(\"XKTMesh \" + meshId + \" already used by XKTEntity \" + mesh.entity.entityId);\n                continue;\n            }\n\n            meshes.push(mesh);\n        }\n\n        const entity = new XKTEntity(entityId, meshes);\n\n        for (let i = 0, len = meshes.length; i < len; i++) {\n            const mesh = meshes[i];\n            mesh.entity = entity;\n        }\n\n        this.entities[entityId] = entity;\n        this.entitiesList.push(entity);\n\n        return entity;\n    }\n\n    /**\n     * Finalizes this XKTModel.\n     *\n     * After finalizing, we may then serialize the model to an array buffer using {@link writeXKTModelToArrayBuffer}.\n     *\n     * Logs error and does nothing if this XKTModel has already been finalized.\n     *\n     * Internally, this method:\n     *\n     * * sets each {@link XKTEntity}'s {@link XKTEntity#hasReusedGeometries} true if it shares its {@link XKTGeometry}s with other {@link XKTEntity}s,\n     * * creates each {@link XKTEntity}'s {@link XKTEntity#aabb},\n     * * creates {@link XKTTile}s in {@link XKTModel#tilesList}, and\n     * * sets {@link XKTModel#finalized} ````true````.\n     */\n    finalize() {\n\n        if (this.finalized) {\n            console.log(\"XKTModel already finalized\");\n            return;\n        }\n\n        this._bakeSingleUseGeometryPositions();\n\n        this._bakeAndOctEncodeNormals();\n\n        this._createEntityAABBs();\n\n        const rootKDNode = this._createKDTree();\n\n        this._createTilesFromKDTree(rootKDNode);\n\n        this._createReusedGeometriesDecodeMatrix();\n\n        this._flagSolidGeometries();\n\n        this.finalized = true;\n    }\n\n    _bakeSingleUseGeometryPositions() {\n\n        for (let j = 0, lenj = this.meshesList.length; j < lenj; j++) {\n\n            const mesh = this.meshesList[j];\n\n            const geometry = mesh.geometry;\n\n            if (geometry.numInstances === 1) {\n\n                const matrix = mesh.matrix;\n\n                if (matrix && (!math.isIdentityMat4(matrix))) {\n\n                    const positions = geometry.positions;\n\n                    for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                        tempVec4a[0] = positions[i + 0];\n                        tempVec4a[1] = positions[i + 1];\n                        tempVec4a[2] = positions[i + 2];\n                        tempVec4a[3] = 1;\n\n                        math.transformPoint4(matrix, tempVec4a, tempVec4b);\n\n                        positions[i + 0] = tempVec4b[0];\n                        positions[i + 1] = tempVec4b[1];\n                        positions[i + 2] = tempVec4b[2];\n                    }\n                }\n            }\n        }\n    }\n\n    _bakeAndOctEncodeNormals() {\n\n        for (let i = 0, len = this.meshesList.length; i < len; i++) {\n\n            const mesh = this.meshesList[i];\n            const geometry = mesh.geometry;\n\n            if (geometry.normals && !geometry.normalsOctEncoded) {\n\n                geometry.normalsOctEncoded = new Int8Array(geometry.normals.length);\n\n                if (geometry.numInstances > 1) {\n                    geometryCompression.octEncodeNormals(geometry.normals, geometry.normals.length, geometry.normalsOctEncoded, 0);\n\n                } else {\n                    const modelNormalMatrix =  math.inverseMat4(math.transposeMat4(mesh.matrix, tempMat4), tempMat4b);\n                    geometryCompression.transformAndOctEncodeNormals(modelNormalMatrix, geometry.normals, geometry.normals.length, geometry.normalsOctEncoded, 0);\n                }\n            }\n        }\n    }\n\n    _createEntityAABBs() {\n\n        for (let i = 0, len = this.entitiesList.length; i < len; i++) {\n\n            const entity = this.entitiesList[i];\n            const entityAABB = entity.aabb;\n            const meshes = entity.meshes;\n\n            math.collapseAABB3(entityAABB);\n\n            for (let j = 0, lenj = meshes.length; j < lenj; j++) {\n\n                const mesh = meshes[j];\n                const geometry = mesh.geometry;\n                const matrix = mesh.matrix;\n\n                if (geometry.numInstances > 1) {\n\n                    const positions = geometry.positions;\n                    for (let i = 0, len = positions.length; i < len; i += 3) {\n                        tempVec4a[0] = positions[i + 0];\n                        tempVec4a[1] = positions[i + 1];\n                        tempVec4a[2] = positions[i + 2];\n                        tempVec4a[3] = 1;\n                        math.transformPoint4(matrix, tempVec4a, tempVec4b);\n                        math.expandAABB3Point3(entityAABB, tempVec4b);\n                    }\n\n                } else {\n\n                    const positions = geometry.positions;\n                    for (let i = 0, len = positions.length; i < len; i += 3) {\n                        tempVec4a[0] = positions[i + 0];\n                        tempVec4a[1] = positions[i + 1];\n                        tempVec4a[2] = positions[i + 2];\n                        math.expandAABB3Point3(entityAABB, tempVec4a);\n                    }\n                }\n            }\n        }\n    }\n\n    _createKDTree() {\n\n        const aabb = math.collapseAABB3();\n\n        for (let i = 0, len = this.entitiesList.length; i < len; i++) {\n            const entity = this.entitiesList[i];\n            math.expandAABB3(aabb, entity.aabb);\n        }\n\n        const rootKDNode = new KDNode(aabb);\n\n        for (let i = 0, len = this.entitiesList.length; i < len; i++) {\n            const entity = this.entitiesList[i];\n            this._insertEntityIntoKDTree(rootKDNode, entity);\n        }\n\n        return rootKDNode;\n    }\n\n    _insertEntityIntoKDTree(kdNode, entity) {\n\n        const nodeAABB = kdNode.aabb;\n        const entityAABB = entity.aabb;\n\n        const nodeAABBDiag = math.getAABB3Diag(nodeAABB);\n\n        if (nodeAABBDiag < MIN_TILE_DIAG) {\n            kdNode.entities = kdNode.entities || [];\n            kdNode.entities.push(entity);\n            math.expandAABB3(nodeAABB, entityAABB);\n            return;\n        }\n\n        if (kdNode.left) {\n            if (math.containsAABB3(kdNode.left.aabb, entityAABB)) {\n                this._insertEntityIntoKDTree(kdNode.left, entity);\n                return;\n            }\n        }\n\n        if (kdNode.right) {\n            if (math.containsAABB3(kdNode.right.aabb, entityAABB)) {\n                this._insertEntityIntoKDTree(kdNode.right, entity);\n                return;\n            }\n        }\n\n        kdTreeDimLength[0] = nodeAABB[3] - nodeAABB[0];\n        kdTreeDimLength[1] = nodeAABB[4] - nodeAABB[1];\n        kdTreeDimLength[2] = nodeAABB[5] - nodeAABB[2];\n\n        let dim = 0;\n\n        if (kdTreeDimLength[1] > kdTreeDimLength[dim]) {\n            dim = 1;\n        }\n\n        if (kdTreeDimLength[2] > kdTreeDimLength[dim]) {\n            dim = 2;\n        }\n\n        if (!kdNode.left) {\n            const aabbLeft = nodeAABB.slice();\n            aabbLeft[dim + 3] = ((nodeAABB[dim] + nodeAABB[dim + 3]) / 2.0);\n            kdNode.left = new KDNode(aabbLeft);\n            if (math.containsAABB3(aabbLeft, entityAABB)) {\n                this._insertEntityIntoKDTree(kdNode.left, entity);\n                return;\n            }\n        }\n\n        if (!kdNode.right) {\n            const aabbRight = nodeAABB.slice();\n            aabbRight[dim] = ((nodeAABB[dim] + nodeAABB[dim + 3]) / 2.0);\n            kdNode.right = new KDNode(aabbRight);\n            if (math.containsAABB3(aabbRight, entityAABB)) {\n                this._insertEntityIntoKDTree(kdNode.right, entity);\n                return;\n            }\n        }\n\n        kdNode.entities = kdNode.entities || [];\n        kdNode.entities.push(entity);\n\n        math.expandAABB3(nodeAABB, entityAABB);\n    }\n\n    _createTilesFromKDTree(rootKDNode) {\n        this._createTilesFromKDNode(rootKDNode);\n    }\n\n    _createTilesFromKDNode(kdNode) {\n        if (kdNode.entities && kdNode.entities.length > 0) {\n            this._createTileFromEntities(kdNode.entities);\n        }\n        if (kdNode.left) {\n            this._createTilesFromKDNode(kdNode.left);\n        }\n        if (kdNode.right) {\n            this._createTilesFromKDNode(kdNode.right);\n        }\n    }\n\n    /**\n     * Creates a tile from the given entities.\n     *\n     * For each single-use {@link XKTGeometry}, this method centers {@link XKTGeometry#positions} to make them relative to the\n     * tile's center, then quantizes the positions to unsigned 16-bit integers, relative to the tile's boundary.\n     *\n     * @param entities\n     */\n    _createTileFromEntities(entities) {\n\n        const tileAABB = math.AABB3(); // A tighter World-space AABB around the entities\n        math.collapseAABB3(tileAABB);\n\n        for (let i = 0; i < entities.length; i++) {\n            const entity = entities [i];\n            math.expandAABB3(tileAABB, entity.aabb);\n        }\n\n        const tileCenter = math.getAABB3Center(tileAABB);\n        const tileCenterNeg = math.mulVec3Scalar(tileCenter, -1, math.vec3());\n\n        const rtcAABB = math.AABB3(); // AABB centered at the RTC origin\n\n        rtcAABB[0] = tileAABB[0] - tileCenter[0];\n        rtcAABB[1] = tileAABB[1] - tileCenter[1];\n        rtcAABB[2] = tileAABB[2] - tileCenter[2];\n        rtcAABB[3] = tileAABB[3] - tileCenter[0];\n        rtcAABB[4] = tileAABB[4] - tileCenter[1];\n        rtcAABB[5] = tileAABB[5] - tileCenter[2];\n\n        for (let i = 0; i < entities.length; i++) {\n\n            const entity = entities [i];\n\n            const meshes = entity.meshes;\n\n            for (let j = 0, lenj = meshes.length; j < lenj; j++) {\n\n                const mesh = meshes[j];\n                const geometry = mesh.geometry;\n\n                if (!geometry.reused) {\n\n                    const positions = geometry.positions;\n\n                    // Center positions relative to their tile's World-space center\n\n                    for (let k = 0, lenk = positions.length; k < lenk; k += 3) {\n\n                        positions[k + 0] -= tileCenter[0];\n                        positions[k + 1] -= tileCenter[1];\n                        positions[k + 2] -= tileCenter[2];\n                    }\n\n                    // Quantize positions relative to tile's RTC-space boundary\n\n                    geometryCompression.quantizePositions(positions, positions.length, rtcAABB, geometry.positionsQuantized);\n\n                } else {\n\n                    // Post-multiply a translation to the mesh's modeling matrix\n                    // to center the entity's geometry instances to the tile RTC center\n\n                    math.translateMat4v(tileCenterNeg, mesh.matrix);\n                }\n            }\n\n            entity.entityIndex = this.entitiesList.length;\n\n            this.entitiesList.push(entity);\n        }\n\n        const tile = new XKTTile(tileAABB, entities);\n\n        this.tilesList.push(tile);\n    }\n\n    _createReusedGeometriesDecodeMatrix() {\n\n        const tempVec3a = math.vec3();\n        const reusedGeometriesAABB = math.collapseAABB3(math.AABB3());\n        let countReusedGeometries = 0;\n\n        for (let geometryIndex = 0, numGeometries = this.geometriesList.length; geometryIndex < numGeometries; geometryIndex++) {\n\n            const geometry = this.geometriesList [geometryIndex];\n\n            if (geometry.reused) {\n\n                const positions = geometry.positions;\n\n                for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                    tempVec3a[0] = positions[i];\n                    tempVec3a[1] = positions[i + 1];\n                    tempVec3a[2] = positions[i + 2];\n\n                    math.expandAABB3Point3(reusedGeometriesAABB, tempVec3a);\n                }\n\n                countReusedGeometries++;\n            }\n        }\n\n        if (countReusedGeometries > 0) {\n\n            geometryCompression.createPositionsDecodeMatrix(reusedGeometriesAABB, this.reusedGeometriesDecodeMatrix);\n\n            for (let geometryIndex = 0, numGeometries = this.geometriesList.length; geometryIndex < numGeometries; geometryIndex++) {\n\n                const geometry = this.geometriesList [geometryIndex];\n\n                if (geometry.reused) {\n                    geometryCompression.quantizePositions(geometry.positions, geometry.positions.length, reusedGeometriesAABB, geometry.positionsQuantized);\n                }\n            }\n\n        } else {\n            math.identityMat4(this.reusedGeometriesDecodeMatrix); // No need for this matrix, but we'll be tidy and set it to identity\n        }\n    }\n\n    _flagSolidGeometries() {\n        for (let i = 0, len = this.geometriesList.length; i < len; i++) {\n            const geometry = this.geometriesList[i];\n            if (geometry.primitiveType === \"triangles\") {\n                geometry.solid = isTriangleMeshSolid(geometry.indices, geometry.positionsQuantized); // Better memory/cpu performance with quantized values\n            }\n        }\n    }\n}\n\nexport {XKTModel};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/XKTModel/XKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 105,
    "kind": "variable",
    "name": "tempVec4a",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~tempVec4a",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 106,
    "kind": "variable",
    "name": "tempVec4b",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~tempVec4b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 107,
    "kind": "variable",
    "name": "tempMat4",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~tempMat4",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 108,
    "kind": "variable",
    "name": "tempMat4b",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~tempMat4b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 109,
    "kind": "variable",
    "name": "MIN_TILE_DIAG",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~MIN_TILE_DIAG",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 110,
    "kind": "variable",
    "name": "kdTreeDimLength",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~kdTreeDimLength",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 111,
    "kind": "class",
    "name": "XKTModel",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~XKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTModel.js",
    "importStyle": "{XKTModel}",
    "description": "A document model that represents the contents of an .XKT file.\n\n* An XKTModel contains {@link XKTTile}s, which spatially subdivide the model into regions.\n* Each {@link XKTTile} contains {@link XKTEntity}s, which represent the objects within its region.\n* Each {@link XKTEntity} has {@link XKTMesh}s, which each have a {@link XKTGeometry}. Each {@link XKTGeometry} can be shared by multiple {@link XKTMesh}s.\n* Import glTF into an XKTModel using {@link parseGLTFIntoXKTModel}.\n* Build an XKTModel programmatically using {@link XKTModel#createGeometry}, {@link XKTModel#createMesh} and {@link XKTModel#createEntity}.\n* Serialize an XKTModel to an ArrayBuffer using {@link writeXKTModelToArrayBuffer}.\n* Validate an ArrayBuffer against an XKTModel using {@link validateXKTArrayBuffer}.\n\n## Usage\n\nSee [main docs page](/docs/#javascript-api) for usage examples.",
    "lineNumber": 39,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTModel"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 112,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#constructor",
    "access": "public",
    "description": "Constructs a new XKTModel.",
    "lineNumber": 47,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configuration"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "10",
        "defaultRaw": 10,
        "name": "cfg.edgeThreshold",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 113,
    "kind": "member",
    "name": "edgeThreshold",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#edgeThreshold",
    "access": "public",
    "description": "",
    "lineNumber": 53,
    "type": {
      "nullable": null,
      "types": [
        "Number",
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 114,
    "kind": "member",
    "name": "reusedGeometriesDecodeMatrix",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#reusedGeometriesDecodeMatrix",
    "access": "public",
    "description": "The positions of all shared {@link XKTGeometry}s are de-quantized using this singular\nde-quantization matrix.\n\nThis de-quantization matrix is generated from the collective Local-space boundary of the\npositions of all shared {@link XKTGeometry}s.",
    "lineNumber": 64,
    "type": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 115,
    "kind": "member",
    "name": "geometries",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#geometries",
    "access": "public",
    "description": "Map of {@link XKTGeometry}s within this XKTModel, each mapped to {@link XKTGeometry#geometryId}.\n\nCreated by {@link XKTModel#createGeometry}.",
    "lineNumber": 73,
    "type": {
      "nullable": null,
      "types": [
        "{Number:XKTGeometry}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 116,
    "kind": "member",
    "name": "geometriesList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#geometriesList",
    "access": "public",
    "description": "List of {@link XKTGeometry}s within this XKTModel, in the order they were created.\n\nEach XKTGeometry holds its position in this list in {@link XKTGeometry#geometryIndex}.\n\nCreated by {@link XKTModel#createGeometry}.",
    "lineNumber": 84,
    "type": {
      "nullable": null,
      "types": [
        "XKTGeometry[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 117,
    "kind": "member",
    "name": "meshes",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#meshes",
    "access": "public",
    "description": "Map of {@link XKTMesh}s within this XKTModel, each mapped to {@link XKTMesh#meshId}.\n\nCreated by {@link XKTModel#createMesh}.",
    "lineNumber": 93,
    "type": {
      "nullable": null,
      "types": [
        "{Number:XKTMesh}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 118,
    "kind": "member",
    "name": "meshesList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#meshesList",
    "access": "public",
    "description": "List of {@link XKTMesh}s within this XKTModel, in the order they were created.\n\nEach XKTMesh holds its position in this list in {@link XKTMesh#meshIndex}.\n\nCreated by {@link XKTModel#createMesh}.",
    "lineNumber": 104,
    "type": {
      "nullable": null,
      "types": [
        "XKTMesh[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 119,
    "kind": "member",
    "name": "entities",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#entities",
    "access": "public",
    "description": "Map of {@link XKTEntity}s within this XKTModel, each mapped to {@link XKTEntity#entityId}.\n\nCreated by {@link XKTModel#createEntity}.",
    "lineNumber": 113,
    "type": {
      "nullable": null,
      "types": [
        "{String:XKTEntity}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 120,
    "kind": "member",
    "name": "entitiesList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#entitiesList",
    "access": "public",
    "description": "{@link XKTEntity}s within this XKTModel.\n\nEach XKTEntity holds its position in this list in {@link XKTMesh#entityIndex}.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 124,
    "type": {
      "nullable": null,
      "types": [
        "XKTEntity[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 121,
    "kind": "member",
    "name": "tilesList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#tilesList",
    "access": "public",
    "description": "{@link XKTTile}s within this Model.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 133,
    "type": {
      "nullable": null,
      "types": [
        "XKTTile[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 122,
    "kind": "member",
    "name": "finalized",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#finalized",
    "access": "public",
    "description": "Indicates if this XKTModel has been finalized.\n\nSet ````true```` by {@link XKTModel#finalize}.",
    "lineNumber": 142,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "createGeometry",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createGeometry",
    "access": "public",
    "description": "Creates an {@link XKTGeometry} within this XKTModel.\n\nLogs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).",
    "lineNumber": 161,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{XKTGeometry} The new {@link XKTGeometry}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Method parameters."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "params.geometryId",
        "description": "Unique ID for the {@link XKTGeometry}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "params.primitiveType",
        "description": "The type of {@link XKTGeometry}: \"triangles\", \"lines\" or \"points\"."
      },
      {
        "nullable": null,
        "types": [
          "Float64Array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.positions",
        "description": "Floating-point Local-space vertex positions for the {@link XKTGeometry}. Required for all primitive types."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.normals",
        "description": "Floating-point vertex normals for the {@link XKTGeometry}. Required for triangles primitives. Ignored for points and lines."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.colors",
        "description": "Floating-point RGBA vertex colors for the {@link XKTGeometry}. Required for points primitives. Ignored for lines and triangles."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.colorsCompressed",
        "description": "Integer RGBA vertex colors for the {@link XKTGeometry}. Required for points primitives. Ignored for lines and triangles."
      },
      {
        "nullable": null,
        "types": [
          "Uint32Array"
        ],
        "spread": false,
        "optional": true,
        "name": "params.indices",
        "description": "Indices for the {@link XKTGeometry}. Required for triangles and lines primitives. Ignored for points."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "10",
        "defaultRaw": 10,
        "name": "params.edgeThreshold",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "XKTGeometry"
      ],
      "spread": false,
      "description": "The new {@link XKTGeometry}."
    }
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "createMesh",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createMesh",
    "access": "public",
    "description": "Creates an {@link XKTMesh} within this XKTModel.\n\nAn {@link XKTMesh} can be owned by one {@link XKTEntity}, which can own multiple {@link XKTMesh}es.",
    "lineNumber": 278,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{XKTMesh} The new {@link XKTMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Method parameters."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "params.meshId",
        "description": "Unique ID for the {@link XKTMesh}."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "params.geometryId",
        "description": "ID of an existing {@link XKTGeometry} in {@link XKTModel#geometries}."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.color",
        "description": "RGB color for the {@link XKTMesh}, with each color component in range [0..1]."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "params.metallic",
        "description": "How metallic the {@link XKTMesh} is, in range [0..1]. A value of ````0```` indicates fully dielectric material, while ````1```` indicates fully metallic."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "params.roughness",
        "description": "How rough the {@link XKTMesh} is, in range [0..1]. A value of ````0```` indicates fully smooth, while ````1```` indicates fully rough."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "params.opacity",
        "description": "Opacity factor for the {@link XKTMesh}, in range [0..1]."
      },
      {
        "nullable": null,
        "types": [
          "Float64Array"
        ],
        "spread": false,
        "optional": true,
        "name": "params.matrix",
        "description": "Modeling matrix for the {@link XKTMesh}. Overrides ````position````, ````scale```` and ````rotation```` parameters."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[0,0,0]",
        "defaultRaw": [
          0,
          0,
          0
        ],
        "name": "params.position",
        "description": "Position of the {@link XKTMesh}. Overridden by the ````matrix```` parameter."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[1,1,1]",
        "defaultRaw": [
          1,
          1,
          1
        ],
        "name": "params.scale",
        "description": "Scale of the {@link XKTMesh}. Overridden by the ````matrix```` parameter."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[0,0,0]",
        "defaultRaw": [
          0,
          0,
          0
        ],
        "name": "params.rotation",
        "description": "Rotation of the {@link XKTMesh} as Euler angles given in degrees, for each of the X, Y and Z axis. Overridden by the ````matrix```` parameter."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "XKTMesh"
      ],
      "spread": false,
      "description": "The new {@link XKTMesh}."
    }
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "createEntity",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createEntity",
    "access": "public",
    "description": "Creates an {@link XKTEntity} within this XKTModel.\n\nLogs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).",
    "lineNumber": 361,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{XKTEntity} The new {@link XKTEntity}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Method parameters."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "params.entityId",
        "description": "Unique ID for the {@link XKTEntity}."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": false,
        "name": "params.meshIds",
        "description": "IDs of {@link XKTMesh}es used by the {@link XKTEntity}. Note that each {@link XKTMesh} can only be used by one {@link XKTEntity}."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "XKTEntity"
      ],
      "spread": false,
      "description": "The new {@link XKTEntity}."
    }
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "finalize",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#finalize",
    "access": "public",
    "description": "Finalizes this XKTModel.\n\nAfter finalizing, we may then serialize the model to an array buffer using {@link writeXKTModelToArrayBuffer}.\n\nLogs error and does nothing if this XKTModel has already been finalized.\n\nInternally, this method:\n\n* sets each {@link XKTEntity}'s {@link XKTEntity#hasReusedGeometries} true if it shares its {@link XKTGeometry}s with other {@link XKTEntity}s,\n* creates each {@link XKTEntity}'s {@link XKTEntity#aabb},\n* creates {@link XKTTile}s in {@link XKTModel#tilesList}, and\n* sets {@link XKTModel#finalized} ````true````.",
    "lineNumber": 434,
    "params": [],
    "return": null
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "_bakeSingleUseGeometryPositions",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_bakeSingleUseGeometryPositions",
    "access": "private",
    "description": null,
    "lineNumber": 458,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "_bakeAndOctEncodeNormals",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_bakeAndOctEncodeNormals",
    "access": "private",
    "description": null,
    "lineNumber": 492,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "_createEntityAABBs",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createEntityAABBs",
    "access": "private",
    "description": null,
    "lineNumber": 514,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "_createKDTree",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createKDTree",
    "access": "private",
    "description": null,
    "lineNumber": 556,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "_insertEntityIntoKDTree",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_insertEntityIntoKDTree",
    "access": "private",
    "description": null,
    "lineNumber": 575,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "kdNode",
        "types": [
          "*"
        ]
      },
      {
        "name": "entity",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "_createTilesFromKDTree",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createTilesFromKDTree",
    "access": "private",
    "description": null,
    "lineNumber": 643,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "rootKDNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "_createTilesFromKDNode",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createTilesFromKDNode",
    "access": "private",
    "description": null,
    "lineNumber": 647,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "kdNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 135,
    "kind": "method",
    "name": "_createTileFromEntities",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createTileFromEntities",
    "access": "private",
    "description": "Creates a tile from the given entities.\n\nFor each single-use {@link XKTGeometry}, this method centers {@link XKTGeometry#positions} to make them relative to the\ntile's center, then quantizes the positions to unsigned 16-bit integers, relative to the tile's boundary.",
    "lineNumber": 667,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "entities",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 136,
    "kind": "method",
    "name": "_createReusedGeometriesDecodeMatrix",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createReusedGeometriesDecodeMatrix",
    "access": "private",
    "description": null,
    "lineNumber": 736,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 137,
    "kind": "method",
    "name": "_flagSolidGeometries",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_flagSolidGeometries",
    "access": "private",
    "description": null,
    "lineNumber": 781,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 138,
    "kind": "file",
    "name": "src/XKTModel/XKTTile.js",
    "content": "/**\n * @desc A box-shaped 3D region within an {@link XKTModel} that contains {@link XKTEntity}s.\n *\n * * Created by {@link XKTModel#finalize}\n * * Stored in {@link XKTModel#tilesList}\n *\n * @class XKTTile\n */\nclass XKTTile {\n\n    /**\n     * Creates a new XKTTile.\n     *\n     * @private\n     * @param aabb\n     * @param entities\n     */\n    constructor(aabb, entities) {\n\n        /**\n         * Axis-aligned World-space bounding box that encloses the {@link XKTEntity}'s within this Tile.\n         *\n         * @type {Float64Array}\n         */\n        this.aabb = aabb;\n\n        /**\n         * The {@link XKTEntity}'s within this XKTTile.\n         *\n         * @type {XKTEntity[]}\n         */\n        this.entities = entities;\n    }\n}\n\nexport {XKTTile};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/XKTModel/XKTTile.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 139,
    "kind": "class",
    "name": "XKTTile",
    "memberof": "src/XKTModel/XKTTile.js",
    "static": true,
    "longname": "src/XKTModel/XKTTile.js~XKTTile",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTTile.js",
    "importStyle": "{XKTTile}",
    "description": "A box-shaped 3D region within an {@link XKTModel} that contains {@link XKTEntity}s.\n\n* Created by {@link XKTModel#finalize}\n* Stored in {@link XKTModel#tilesList}",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTTile"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 140,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTTile.js~XKTTile",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTTile.js~XKTTile#constructor",
    "access": "private",
    "description": "Creates a new XKTTile.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "aabb",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "entities",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 141,
    "kind": "member",
    "name": "aabb",
    "memberof": "src/XKTModel/XKTTile.js~XKTTile",
    "static": false,
    "longname": "src/XKTModel/XKTTile.js~XKTTile#aabb",
    "access": "public",
    "description": "Axis-aligned World-space bounding box that encloses the {@link XKTEntity}'s within this Tile.",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "Float64Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 142,
    "kind": "member",
    "name": "entities",
    "memberof": "src/XKTModel/XKTTile.js~XKTTile",
    "static": false,
    "longname": "src/XKTModel/XKTTile.js~XKTTile#entities",
    "access": "public",
    "description": "The {@link XKTEntity}'s within this XKTTile.",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "XKTEntity[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 143,
    "kind": "file",
    "name": "src/XKTModel/lib/buildEdgeIndices.js",
    "content": "//const math = require('./math');\n\nimport {math} from \"../../lib/math.js\";\n\n/**\n * @private\n */\nconst buildEdgeIndices = (function () {\n\n    const uniquePositions = [];\n    const indicesLookup = [];\n    const indicesReverseLookup = [];\n    const weldedIndices = [];\n\n// TODO: Optimize with caching, but need to cater to both compressed and uncompressed positions\n\n    const faces = [];\n    let numFaces = 0;\n    const compa = new Uint16Array(3);\n    const compb = new Uint16Array(3);\n    const compc = new Uint16Array(3);\n    const a = math.vec3();\n    const b = math.vec3();\n    const c = math.vec3();\n    const cb = math.vec3();\n    const ab = math.vec3();\n    const cross = math.vec3();\n    const normal = math.vec3();\n\n    function weldVertices(positions, indices) {\n        const positionsMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n        let vx;\n        let vy;\n        let vz;\n        let key;\n        const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n        const precision = Math.pow(10, precisionPoints);\n        let i;\n        let len;\n        let lenUniquePositions = 0;\n        for (i = 0, len = positions.length; i < len; i += 3) {\n            vx = positions[i];\n            vy = positions[i + 1];\n            vz = positions[i + 2];\n            key = Math.round(vx * precision) + '_' + Math.round(vy * precision) + '_' + Math.round(vz * precision);\n            if (positionsMap[key] === undefined) {\n                positionsMap[key] = lenUniquePositions / 3;\n                uniquePositions[lenUniquePositions++] = vx;\n                uniquePositions[lenUniquePositions++] = vy;\n                uniquePositions[lenUniquePositions++] = vz;\n            }\n            indicesLookup[i / 3] = positionsMap[key];\n        }\n        for (i = 0, len = indices.length; i < len; i++) {\n            weldedIndices[i] = indicesLookup[indices[i]];\n            indicesReverseLookup[weldedIndices[i]] = indices[i];\n        }\n    }\n\n    function buildFaces(numIndices, positionsDecodeMatrix) {\n        numFaces = 0;\n        for (let i = 0, len = numIndices; i < len; i += 3) {\n            const ia = ((weldedIndices[i]) * 3);\n            const ib = ((weldedIndices[i + 1]) * 3);\n            const ic = ((weldedIndices[i + 2]) * 3);\n            if (positionsDecodeMatrix) {\n                compa[0] = uniquePositions[ia];\n                compa[1] = uniquePositions[ia + 1];\n                compa[2] = uniquePositions[ia + 2];\n                compb[0] = uniquePositions[ib];\n                compb[1] = uniquePositions[ib + 1];\n                compb[2] = uniquePositions[ib + 2];\n                compc[0] = uniquePositions[ic];\n                compc[1] = uniquePositions[ic + 1];\n                compc[2] = uniquePositions[ic + 2];\n                // Decode\n                math.decompressPosition(compa, positionsDecodeMatrix, a);\n                math.decompressPosition(compb, positionsDecodeMatrix, b);\n                math.decompressPosition(compc, positionsDecodeMatrix, c);\n            } else {\n                a[0] = uniquePositions[ia];\n                a[1] = uniquePositions[ia + 1];\n                a[2] = uniquePositions[ia + 2];\n                b[0] = uniquePositions[ib];\n                b[1] = uniquePositions[ib + 1];\n                b[2] = uniquePositions[ib + 2];\n                c[0] = uniquePositions[ic];\n                c[1] = uniquePositions[ic + 1];\n                c[2] = uniquePositions[ic + 2];\n            }\n            math.subVec3(c, b, cb);\n            math.subVec3(a, b, ab);\n            math.cross3Vec3(cb, ab, cross);\n            math.normalizeVec3(cross, normal);\n            const face = faces[numFaces] || (faces[numFaces] = {normal: math.vec3()});\n            face.normal[0] = normal[0];\n            face.normal[1] = normal[1];\n            face.normal[2] = normal[2];\n            numFaces++;\n        }\n    }\n\n    return function (positions, indices, positionsDecodeMatrix, edgeThreshold) {\n        weldVertices(positions, indices);\n        buildFaces(indices.length, positionsDecodeMatrix);\n        const edgeIndices = [];\n        const thresholdDot = Math.cos(math.DEGTORAD * edgeThreshold);\n        const edges = {};\n        let edge1;\n        let edge2;\n        let index1;\n        let index2;\n        let key;\n        let largeIndex = false;\n        let edge;\n        let normal1;\n        let normal2;\n        let dot;\n        let ia;\n        let ib;\n        for (let i = 0, len = indices.length; i < len; i += 3) {\n            const faceIndex = i / 3;\n            for (let j = 0; j < 3; j++) {\n                edge1 = weldedIndices[i + j];\n                edge2 = weldedIndices[i + ((j + 1) % 3)];\n                index1 = Math.min(edge1, edge2);\n                index2 = Math.max(edge1, edge2);\n                key = index1 + ',' + index2;\n                if (edges[key] === undefined) {\n                    edges[key] = {\n                        index1: index1,\n                        index2: index2,\n                        face1: faceIndex,\n                        face2: undefined,\n                    };\n                } else {\n                    edges[key].face2 = faceIndex;\n                }\n            }\n        }\n        for (key in edges) {\n            edge = edges[key];\n            // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\n            if (edge.face2 !== undefined) {\n                normal1 = faces[edge.face1].normal;\n                normal2 = faces[edge.face2].normal;\n                dot = math.dotVec3(normal1, normal2);\n                if (dot > thresholdDot) {\n                    continue;\n                }\n            }\n            ia = indicesReverseLookup[edge.index1];\n            ib = indicesReverseLookup[edge.index2];\n            if (!largeIndex && ia > 65535 || ib > 65535) {\n                largeIndex = true;\n            }\n            edgeIndices.push(ia);\n            edgeIndices.push(ib);\n        }\n        return (largeIndex) ? new Uint32Array(edgeIndices) : new Uint16Array(edgeIndices);\n    };\n})();\n\n\nexport {buildEdgeIndices};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/XKTModel/lib/buildEdgeIndices.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 144,
    "kind": "variable",
    "name": "buildEdgeIndices",
    "memberof": "src/XKTModel/lib/buildEdgeIndices.js",
    "static": true,
    "longname": "src/XKTModel/lib/buildEdgeIndices.js~buildEdgeIndices",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/buildEdgeIndices.js",
    "importStyle": "{buildEdgeIndices}",
    "description": "",
    "lineNumber": 8,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "file",
    "name": "src/XKTModel/lib/geometryCompression.js",
    "content": "import {math} from \"../../lib/math.js\";\n\nvar quantizePositions = function (positions, lenPositions, aabb, quantizedPositions) {\n    const xmin = aabb[0];\n    const ymin = aabb[1];\n    const zmin = aabb[2];\n    const xwid = aabb[3] - xmin;\n    const ywid = aabb[4] - ymin;\n    const zwid = aabb[5] - zmin;\n    const maxInt = 65535;\n    const xMultiplier = maxInt / xwid;\n    const yMultiplier = maxInt / ywid;\n    const zMultiplier = maxInt / zwid;\n    let i;\n    for (i = 0; i < lenPositions; i += 3) {\n        quantizedPositions[i + 0] = Math.floor((positions[i + 0] - xmin) * xMultiplier);\n        quantizedPositions[i + 1] = Math.floor((positions[i + 1] - ymin) * yMultiplier);\n        quantizedPositions[i + 2] = Math.floor((positions[i + 2] - zmin) * zMultiplier);\n    }\n};\n\nvar createPositionsDecodeMatrix = (function () {\n    const translate = math.mat4();\n    const scale = math.mat4();\n    return function (aabb, positionsDecodeMatrix) {\n        positionsDecodeMatrix = positionsDecodeMatrix || math.mat4();\n        const xmin = aabb[0];\n        const ymin = aabb[1];\n        const zmin = aabb[2];\n        const xwid = aabb[3] - xmin;\n        const ywid = aabb[4] - ymin;\n        const zwid = aabb[5] - zmin;\n        const maxInt = 65535;\n        math.identityMat4(translate);\n        math.translationMat4v(aabb, translate);\n        math.identityMat4(scale);\n        math.scalingMat4v([xwid / maxInt, ywid / maxInt, zwid / maxInt], scale);\n        math.mulMat4(translate, scale, positionsDecodeMatrix);\n        return positionsDecodeMatrix;\n    };\n})();\n\nfunction transformAndOctEncodeNormals(modelNormalMatrix, normals, lenNormals, compressedNormals, lenCompressedNormals) {\n    // http://jcgt.org/published/0003/02/01/\n    let oct, dec, best, currentCos, bestCos;\n    let i, ei;\n    let localNormal = math.vec3();\n    let worldNormal =  math.vec3();\n    for (i = 0; i < lenNormals; i += 3) {\n        localNormal[0] = normals[i];\n        localNormal[1] = normals[i + 1];\n        localNormal[2] = normals[i + 2];\n\n        math.transformVec3(modelNormalMatrix, localNormal, worldNormal);\n        math.normalizeVec3(worldNormal, worldNormal);\n\n        // Test various combinations of ceil and floor to minimize rounding errors\n        best = oct = octEncodeVec3(worldNormal, 0, \"floor\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = bestCos = dot(worldNormal, 0, dec);\n        oct = octEncodeVec3(worldNormal, 0, \"ceil\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, 0, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(worldNormal, 0, \"floor\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, 0, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(worldNormal, 0, \"ceil\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, 0, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        compressedNormals[lenCompressedNormals + i + 0] = best[0];\n        compressedNormals[lenCompressedNormals + i + 1] = best[1];\n        compressedNormals[lenCompressedNormals + i + 2] = 0.0; // Unused\n    }\n    lenCompressedNormals += lenNormals;\n    return lenCompressedNormals;\n}\n\nfunction octEncodeNormals(normals, lenNormals, compressedNormals, lenCompressedNormals) { // http://jcgt.org/published/0003/02/01/\n    let oct, dec, best, currentCos, bestCos;\n    for (let i = 0; i < lenNormals; i += 3) {\n        // Test various combinations of ceil and floor to minimize rounding errors\n        best = oct = octEncodeVec3(normals, i, \"floor\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = bestCos = dot(normals, i, dec);\n        oct = octEncodeVec3(normals, i, \"ceil\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(normals, i, \"floor\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(normals, i, \"ceil\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        compressedNormals[lenCompressedNormals + i + 0] = best[0];\n        compressedNormals[lenCompressedNormals + i + 1] = best[1];\n        compressedNormals[lenCompressedNormals + i + 2] = 0.0; // Unused\n    }\n    lenCompressedNormals += lenNormals;\n    return lenCompressedNormals;\n}\n\n/**\n * @private\n */\nfunction octEncodeVec3(array, i, xfunc, yfunc) { // Oct-encode single normal vector in 2 bytes\n    let x = array[i] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    let y = array[i + 1] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    if (array[i + 2] < 0) {\n        let tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        let tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        x = tempx;\n        y = tempy;\n    }\n    return new Int8Array([\n        Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)),\n        Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))\n    ]);\n}\n\n/**\n * Decode an oct-encoded normal\n */\nfunction octDecodeVec2(oct) {\n    let x = oct[0];\n    let y = oct[1];\n    x /= x < 0 ? 127 : 128;\n    y /= y < 0 ? 127 : 128;\n    const z = 1 - Math.abs(x) - Math.abs(y);\n    if (z < 0) {\n        x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n    }\n    const length = Math.sqrt(x * x + y * y + z * z);\n    return [\n        x / length,\n        y / length,\n        z / length\n    ];\n}\n\n/**\n * Dot product of a normal in an array against a candidate decoding\n * @private\n */\nfunction dot(array, i, vec3) {\n    return array[i] * vec3[0] + array[i + 1] * vec3[1] + array[i + 2] * vec3[2];\n}\n\n/**\n * @private\n */\nconst geometryCompression = {\n    quantizePositions,\n    createPositionsDecodeMatrix,\n    transformAndOctEncodeNormals,\n    octEncodeNormals,\n};\n\nexport {geometryCompression}",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/XKTModel/lib/geometryCompression.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 146,
    "kind": "function",
    "name": "quantizePositions",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~quantizePositions",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenPositions",
        "types": [
          "*"
        ]
      },
      {
        "name": "aabb",
        "types": [
          "*"
        ]
      },
      {
        "name": "quantizedPositions",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 147,
    "kind": "variable",
    "name": "createPositionsDecodeMatrix",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~createPositionsDecodeMatrix",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 148,
    "kind": "function",
    "name": "transformAndOctEncodeNormals",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~transformAndOctEncodeNormals",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "params": [
      {
        "name": "modelNormalMatrix",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenNormals",
        "types": [
          "*"
        ]
      },
      {
        "name": "compressedNormals",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenCompressedNormals",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 149,
    "kind": "function",
    "name": "octEncodeNormals",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~octEncodeNormals",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "params": [
      {
        "name": "normals",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenNormals",
        "types": [
          "*"
        ]
      },
      {
        "name": "compressedNormals",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenCompressedNormals",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 150,
    "kind": "function",
    "name": "octEncodeVec3",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~octEncodeVec3",
    "access": "private",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 129,
    "ignore": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      },
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "xfunc",
        "types": [
          "*"
        ]
      },
      {
        "name": "yfunc",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 151,
    "kind": "function",
    "name": "octDecodeVec2",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~octDecodeVec2",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": "Decode an oct-encoded normal",
    "lineNumber": 147,
    "params": [
      {
        "name": "oct",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 152,
    "kind": "function",
    "name": "dot",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~dot",
    "access": "private",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": "Dot product of a normal in an array against a candidate decoding",
    "lineNumber": 169,
    "ignore": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      },
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "vec3",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 153,
    "kind": "variable",
    "name": "geometryCompression",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~geometryCompression",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/geometryCompression.js",
    "importStyle": "{geometryCompression}",
    "description": "",
    "lineNumber": 176,
    "ignore": true,
    "type": {
      "types": [
        "{\"quantizePositions\": *, \"createPositionsDecodeMatrix\": *, \"transformAndOctEncodeNormals\": *, \"octEncodeNormals\": *}"
      ]
    }
  },
  {
    "__docId__": 154,
    "kind": "file",
    "name": "src/XKTModel/lib/isTriangleMeshSolid.js",
    "content": "/**\n * Uses edge adjacency counts to identify if the given triangle mesh can be rendered with backface culling enabled.\n *\n * If all edges are connected to exactly two triangles, then the mesh will likely be a closed solid, and we can safely\n * render it with backface culling enabled.\n *\n * Otherwise, the mesh is a surface, and we must render it with backface culling disabled.\n *\n * @private\n */\nconst isTriangleMeshSolid = (indices, positions) => {\n\n    let numPositions = 0;\n    const positionToAdjustedIndex = {};\n    const adjustedIndices = [];\n    const edgeAdjCounts = {};\n\n    for (let i = 0, len = indices.length; i < len; i++) {\n\n        const index = indices[i];\n        const x = positions[index * 3];\n        const y = positions[index * 3 + 1];\n        const z = positions[index * 3 + 2];\n        const positionHash = (\"\" + x + \",\" + y + \",\" + z);\n\n        let adjustedIndex = positionToAdjustedIndex[positionHash];\n\n        if (adjustedIndex === undefined) {\n            adjustedIndex = numPositions++;\n        }\n\n        adjustedIndices[i] = adjustedIndex;\n\n        positionToAdjustedIndex[positionHash] = adjustedIndex;\n    }\n\n    for (let i = 0, len = adjustedIndices.length; i < len; i += 3) {\n\n        const a = adjustedIndices[i];\n        const b = adjustedIndices[i + 1];\n        const c = adjustedIndices[i + 2];\n\n        let a2 = a;\n        let b2 = b;\n        let c2 = c;\n\n        if (a > b && a > c) {\n            if (b > c) {\n                a2 = a;\n                b2 = b;\n                c2 = c;\n            } else {\n                a2 = a;\n                b2 = c;\n                c2 = b;\n            }\n        } else if (b > a && b > c) {\n            if (a > c) {\n                a2 = b;\n                b2 = a;\n                c2 = c;\n            } else {\n                a2 = b;\n                b2 = c;\n                c2 = a;\n            }\n        } else if (c > a && c > b) {\n            if (a > b) {\n                a2 = c;\n                b2 = a;\n                c2 = b;\n            } else {\n                a2 = c;\n                b2 = b;\n                c2 = a;\n            }\n        }\n\n        let edgeHash = \"\" + a2 + \"-\" + b2;\n        let edgeAdjCount = edgeAdjCounts[edgeHash];\n        edgeAdjCounts[edgeHash] = (edgeAdjCount === undefined) ? 1 : edgeAdjCount + 1;\n\n        edgeHash = \"\" + b2 + \"-\" + c2;\n        edgeAdjCount = edgeAdjCounts[edgeHash];\n        edgeAdjCounts[edgeHash] = (edgeAdjCount === undefined) ? 1 : edgeAdjCount + 1;\n\n        if (a2 > c2) {\n            const temp = c2;\n            c2 = a2;\n            a2 = temp;\n        }\n        edgeHash = \"\" + c2 + \"-\" + a2;\n        edgeAdjCount = edgeAdjCounts[edgeHash];\n        edgeAdjCounts[edgeHash] = (edgeAdjCount === undefined) ? 1 : edgeAdjCount + 1;\n    }\n\n    for (let edgeHash in edgeAdjCounts) {\n        if (edgeAdjCounts[edgeHash] !== 2) { // Surface\n            return false;\n        }\n    }\n\n    return true; // Watertight\n};\n\nexport {isTriangleMeshSolid};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/XKTModel/lib/isTriangleMeshSolid.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 155,
    "kind": "function",
    "name": "isTriangleMeshSolid",
    "memberof": "src/XKTModel/lib/isTriangleMeshSolid.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/isTriangleMeshSolid.js~isTriangleMeshSolid",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/isTriangleMeshSolid.js",
    "importStyle": "{isTriangleMeshSolid}",
    "description": "Uses edge adjacency counts to identify if the given triangle mesh can be rendered with backface culling enabled.\n\nIf all edges are connected to exactly two triangles, then the mesh will likely be a closed solid, and we can safely\nrender it with backface culling enabled.\n\nOtherwise, the mesh is a surface, and we must render it with backface culling disabled.",
    "lineNumber": 11,
    "ignore": true,
    "params": [
      {
        "name": "indices",
        "types": [
          "*"
        ]
      },
      {
        "name": "positions",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 156,
    "kind": "file",
    "name": "src/XKTModel/lib/utils.js",
    "content": "function isString(value) {\n    return (typeof value === 'string' || value instanceof String);\n}\n\n/**\n * @private\n */\nconst utils = {\n    isString: isString,\n};\n\nexport {utils};\n",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/XKTModel/lib/utils.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 157,
    "kind": "function",
    "name": "isString",
    "memberof": "src/XKTModel/lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/utils.js~isString",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 158,
    "kind": "variable",
    "name": "utils",
    "memberof": "src/XKTModel/lib/utils.js",
    "static": true,
    "longname": "src/XKTModel/lib/utils.js~utils",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/utils.js",
    "importStyle": "{utils}",
    "description": "",
    "lineNumber": 8,
    "ignore": true,
    "type": {
      "types": [
        "{\"isString\": *}"
      ]
    }
  },
  {
    "__docId__": 159,
    "kind": "file",
    "name": "src/XKTModel/validateXKTArrayBuffer.js",
    "content": "/**\n * @desc Validates an {@link ArrayBuffer} against the {@link XKTModel} it was written from.\n *\n * @param {ArrayBuffer} arrayBuffer The {@link ArrayBuffer}.\n * @param {XKTModel} xktModel The {@link XKTModel} that the {@link ArrayBuffer} was written from.\n * @returns {Boolean} True if valid, else false. Logs validity failures to the JS console.\n */\nfunction validateXKTArrayBuffer(arrayBuffer, xktModel) {\n\n    const dataView = new DataView(arrayBuffer);\n    const dataArray = new Uint8Array(arrayBuffer);\n    const xktVersion = dataView.getUint32(0, true);\n    const numElements = dataView.getUint32(4, true);\n\n    const elements = [];\n\n    let byteOffset = (numElements + 2) * 4;\n\n    for (let i = 0; i < numElements; i++) {\n        const elementSize = dataView.getUint32((i + 2) * 4, true);\n        elements.push(dataArray.subarray(byteOffset, byteOffset + elementSize));\n        byteOffset += elementSize;\n    }\n\n    const deflatedData = extract(elements);\n    const inflatedData = inflate(deflatedData);\n\n    return validateData(inflatedData, xktModel);\n}\n\nfunction extract(elements) {\n\n    return {\n\n        // vertex attributes\n\n        positions: elements[0],\n        normals: elements[1],\n        colors: elements[2],\n\n        // Indices\n\n        indices: elements[3],\n        edgeIndices: elements[4],\n\n        // Transform matrices\n\n        matrices: elements[5],\n\n        reusedGeometriesDecodeMatrix: elements[6],\n\n        // Geometries\n\n        eachGeometryPrimitiveType: elements[7],\n        eachGeometryPositionsPortion: elements[8],\n        eachGeometryNormalsPortion: elements[9],\n        eachGeometryColorsPortion: elements[10],\n\n        eachGeometryIndicesPortion: elements[11],\n        eachGeometryEdgeIndicesPortion: elements[12],\n\n        // Meshes are grouped in runs that are shared by the same entities\n\n        eachMeshGeometriesPortion: elements[13],\n        eachMeshMatricesPortion: elements[14],\n        eachMeshColorAndOpacity: elements[15],\n\n        // Entity elements in the following arrays are grouped in runs that are shared by the same tiles\n\n        eachEntityId: elements[16],\n        eachEntityMeshesPortion: elements[17],\n\n        eachTileAABB: elements[18],\n        eachTileEntitiesPortion: elements[19]\n    };\n}\n\nfunction inflate(deflatedData) {\n\n    return {\n\n        positions: new Uint16Array(pako.inflate(deflatedData.positions).buffer),\n        normals: new Int8Array(pako.inflate(deflatedData.normals).buffer),\n        colors: new Uint8Array(pako.inflate(deflatedData.colors).buffer),\n\n        indices: new Uint32Array(pako.inflate(deflatedData.indices).buffer),\n        edgeIndices: new Uint32Array(pako.inflate(deflatedData.edgeIndices).buffer),\n\n        matrices: new Float32Array(pako.inflate(deflatedData.matrices).buffer),\n        reusedGeometriesDecodeMatrix: new Float32Array(pako.inflate(deflatedData.reusedGeometriesDecodeMatrix).buffer),\n\n        eachGeometryPrimitiveType: new Uint8Array(pako.inflate(deflatedData.eachGeometryPrimitiveType).buffer),\n        eachGeometryPositionsPortion: new Uint32Array(pako.inflate(deflatedData.eachGeometryPositionsPortion).buffer),\n        eachGeometryNormalsPortion: new Uint32Array(pako.inflate(deflatedData.eachGeometryNormalsPortion).buffer),\n        eachGeometryColorsPortion: new Uint32Array(pako.inflate(deflatedData.eachGeometryColorsPortion).buffer),\n        eachGeometryIndicesPortion: new Uint32Array(pako.inflate(deflatedData.eachGeometryIndicesPortion).buffer),\n        eachGeometryEdgeIndicesPortion: new Uint32Array(pako.inflate(deflatedData.eachGeometryEdgeIndicesPortion).buffer),\n\n        eachMeshGeometriesPortion: new Uint32Array(pako.inflate(deflatedData.eachMeshGeometriesPortion).buffer),\n        eachMeshMatricesPortion: new Uint32Array(pako.inflate(deflatedData.eachMeshMatricesPortion).buffer),\n        eachMeshColorAndOpacity: new Uint8Array(pako.inflate(deflatedData.eachMeshColorAndOpacity).buffer),\n\n        eachEntityId: pako.inflate(deflatedData.eachEntityId, {to: 'string'}),\n        eachEntityMeshesPortion: new Uint32Array(pako.inflate(deflatedData.eachEntityMeshesPortion).buffer),\n\n        eachTileAABB: new Float64Array(pako.inflate(deflatedData.eachTileAABB).buffer),\n        eachTileEntitiesPortion: new Uint32Array(pako.inflate(deflatedData.eachTileEntitiesPortion).buffer),\n    };\n}\n\nconst decompressColor = (function () {\n    const floatColor = new Float32Array(3);\n    return function (intColor) {\n        floatColor[0] = intColor[0] / 255.0;\n        floatColor[1] = intColor[1] / 255.0;\n        floatColor[2] = intColor[2] / 255.0;\n        return floatColor;\n    };\n})();\n\nfunction validateData(inflatedData, xktModel) {\n\n    const positions = inflatedData.positions;\n    const normals = inflatedData.normals;\n    const colors = inflatedData.colors;\n\n    const indices = inflatedData.indices;\n    const edgeIndices = inflatedData.edgeIndices;\n\n    const matrices = inflatedData.matrices;\n    const reusedGeometriesDecodeMatrix = inflatedData.reusedGeometriesDecodeMatrix;\n\n    const eachGeometryPrimitiveType = inflatedData.eachGeometryPrimitiveType;\n    const eachGeometryPositionsPortion = inflatedData.eachGeometryPositionsPortion;\n    const eachGeometryNormalsPortion = inflatedData.eachGeometryNormalsPortion;\n    const eachGeometryColorsPortion = inflatedData.eachGeometryColorsPortion;\n    const eachGeometryIndicesPortion = inflatedData.eachGeometryIndicesPortion;\n    const eachGeometryEdgeIndicesPortion = inflatedData.eachGeometryEdgeIndicesPortion;\n\n    const eachMeshGeometriesPortion = inflatedData.eachMeshGeometriesPortion;\n    const eachMeshColorAndOpacity = inflatedData.eachMeshColorAndOpacity;\n    const eachMeshMatricesPortion = inflatedData.eachMeshMatricesPortion;\n\n    const eachEntityId = JSON.parse(inflatedData.eachEntityId);\n    const eachEntityMeshesPortion = inflatedData.eachEntityMeshesPortion;\n\n    const eachTileAABB = inflatedData.eachTileAABB;\n    const eachTileEntitiesPortion = inflatedData.eachTileEntitiesPortion;\n\n    const numGeometries = eachGeometryPositionsPortion.length;\n    const numMeshes = eachMeshGeometriesPortion.length;\n    const numEntities = eachEntityId.length;\n    const numTiles = eachTileEntitiesPortion.length;\n\n    // ASSERTIONS\n\n    if (numTiles !== xktModel.tilesList.length) {\n        console.error(\"Unexpected number of tiles; found \" + numTiles + \", but expected \" + xktModel.tilesList.length);\n        return false;\n    }\n\n    // Count instances of each geometry\n\n    const geometryReuseCounts = new Uint32Array(numGeometries);\n\n    for (let meshIndex = 0; meshIndex < numMeshes; meshIndex++) {\n        const geometryIndex = eachMeshGeometriesPortion[meshIndex];\n        if (geometryReuseCounts[geometryIndex] !== undefined) {\n            geometryReuseCounts[geometryIndex]++;\n        } else {\n            geometryReuseCounts[geometryIndex] = 1;\n        }\n    }\n\n    // ASSERTIONS\n    // Check mesh --> geometry reuse counts\n\n    for (let meshIndex = 0; meshIndex < numMeshes; meshIndex++) {\n        const geometryIndex = eachMeshGeometriesPortion[meshIndex];\n        const xktGeometry = xktModel.geometriesList[geometryIndex];\n        if (!xktGeometry) {\n            console.error(\"xktModel.geometriesList[geometryIndex] not found\");\n            return false;\n        }\n        if (xktGeometry.numInstances !== geometryReuseCounts[geometryIndex]) {\n            console.error(\"xktGeometry.numInstances !== geometryReuseCounts[geometryIndex]\");\n            return false;\n        }\n    }\n\n    // ASSERTIONS\n    // Check geometry primitive types\n\n    for (let geometryIndex = 0; geometryIndex < numGeometries; geometryIndex++) {\n        const xktGeometry = xktModel.geometriesList[geometryIndex];\n        if (!xktGeometry) {\n            console.error(\"xktModel.geometriesList[geometryIndex] not found\");\n            return false;\n        }\n        const geometryPrimitiveType = eachGeometryPrimitiveType[geometryIndex];\n        switch (geometryPrimitiveType) {\n            case 0:\n                if (xktGeometry.primitiveType !== \"triangles\") {\n                    console.error(\"eachGeometryPrimitiveType[geometryIndex] unexpected value\");\n                    return false;\n                }\n                break;\n            case 1:\n                if (xktGeometry.primitiveType !== \"triangles\") {\n                    console.error(\"eachGeometryPrimitiveType[geometryIndex] unexpected value\");\n                    return false;\n                }\n                break;\n            case 2:\n                if (xktGeometry.primitiveType !== \"points\") {\n                    console.error(\"eachGeometryPrimitiveType[geometryIndex] unexpected value\");\n                    return false;\n                }\n                break;\n            case 3:\n                if (xktGeometry.primitiveType !== \"lines\") {\n                    console.error(\"eachGeometryPrimitiveType[geometryIndex] unexpected value\");\n                    return false;\n                }\n                break;\n            default:\n                console.error(\"eachGeometryPrimitiveType[geometryIndex] unexpected value\");\n                return false;\n        }\n    }\n\n    // Iterate over tiles\n\n    for (let tileIndex = 0; tileIndex < numTiles; tileIndex++) {\n\n        const lastTileIndex = (numTiles - 1);\n        const atLastTile = (tileIndex === lastTileIndex);\n\n        const firstTileEntityIndex = eachTileEntitiesPortion [tileIndex];\n        const lastTileEntityIndex = atLastTile ? numEntities : eachTileEntitiesPortion[tileIndex + 1];\n\n        const tileAABBIndex = tileIndex * 6;\n\n        const tileAABB = eachTileAABB.subarray(tileAABBIndex, tileAABBIndex + 6);\n\n        // ASSERTIONS\n\n        const xktTile = xktModel.tilesList[tileIndex];\n\n        if (!xktTile) {\n            console.error(\"xktModel.tilesList[tileIndex] not found\");\n            return false;\n        }\n\n        if (!compareArrays(tileAABB, xktTile.aabb)) {\n            console.error(\"compareArrays(tileAABB, xktTile.aabb) === false\");\n            return false;\n        }\n\n        const numTileEntities = (lastTileEntityIndex - firstTileEntityIndex);\n        if (numTileEntities !== xktTile.entities.length) {\n            console.error(\"Unexpected number of entities in tile\");\n            return false;\n        }\n\n        // Iterate over each tile's entities\n\n        for (let tileEntityIndex = firstTileEntityIndex; tileEntityIndex < lastTileEntityIndex; tileEntityIndex++) {\n\n            const entityId = eachEntityId[tileEntityIndex];\n            const lastTileEntityIndex = (numEntities - 1);\n            const atLastTileEntity = (tileEntityIndex === lastTileEntityIndex);\n            const firstMeshIndex = eachEntityMeshesPortion [tileEntityIndex];\n            const lastMeshIndex = atLastTileEntity ? eachMeshGeometriesPortion.length : eachEntityMeshesPortion[tileEntityIndex + 1];\n\n            // ASSERTIONS\n\n            const xktEntity = xktModel.entitiesList[tileEntityIndex];\n\n            if (!xktEntity) {\n                console.error(\"xktModel.entitiesList[tileEntityIndex] not found\");\n                return false;\n            }\n\n            if (entityId !== xktEntity.entityId) {\n                console.error(\"entityId !== xktEntity.entityId\");\n                return false;\n            }\n\n            // Iterate each entity's meshes\n\n            for (let meshIndex = firstMeshIndex; meshIndex < lastMeshIndex; meshIndex++) {\n\n                const meshMatrixIndex = eachMeshMatricesPortion[meshIndex];\n                const meshMatrix = matrices.slice(meshMatrixIndex, meshMatrixIndex + 16);\n\n                const color = decompressColor(eachMeshColorAndOpacity.subarray((meshIndex * 4), (meshIndex * 4) + 3));\n                const opacity = eachMeshColorAndOpacity[(meshIndex * 4) + 3] / 255.0;\n\n                const geometryIndex = eachMeshGeometriesPortion[meshIndex];\n                const geometryReuseCount = geometryReuseCounts[geometryIndex];\n                const isReusedGeometry = (geometryReuseCount > 1);\n\n                const atLastGeometry = (geometryIndex === (numGeometries - 1));\n\n                const primitiveType = eachGeometryPrimitiveType[geometryIndex];\n\n                // ASSERTIONS\n\n                const xktMesh = xktModel.meshesList[meshIndex];\n                const xktGeometry = xktModel.geometriesList[geometryIndex];\n\n                if (!xktMesh) {\n                    console.error(\"xktModel.meshesList[meshIndex] not found\");\n                    return false;\n                }\n\n                if (!xktGeometry) {\n                    console.error(\"xktModel.geometriesList[geometryIndex] not found\");\n                    return false;\n                }\n\n                if (isReusedGeometry && !compareArrays(meshMatrix, xktMesh.matrix)) {\n                    console.error(\"compareArrays(meshMatrix, xktMesh.matrix) === false\");\n                    return false;\n                }\n\n                if (xktMesh.color && !compareArrays(color, xktMesh.color)) {\n                    console.error(\"compareArrays(color, xktMesh.color) === false\");\n                    return false;\n                }\n\n                if (opacity !== xktMesh.opacity) {\n                    console.error(\"opacity !== xktMesh.opacity\");\n                    return false;\n                }\n\n                if (xktMesh.geometry !== xktGeometry) {\n                    console.error(\"xktMesh.geometry !== xktGeometry\");\n                    return false;\n                }\n\n                let primitiveName;\n                let geometryPositions;\n                let geometryNormals;\n                let geometryColors;\n                let geometryIndices;\n                let geometryEdgeIndices;\n\n                switch (primitiveType) {\n                    case 0: // Solid\n                        primitiveName = \"triangles\";\n                        geometryPositions = positions.subarray(eachGeometryPositionsPortion [geometryIndex], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex + 1]);\n                        geometryNormals = normals.subarray(eachGeometryNormalsPortion [geometryIndex], atLastGeometry ? normals.length : eachGeometryNormalsPortion [geometryIndex + 1]);\n                        geometryIndices = indices.subarray(eachGeometryIndicesPortion [geometryIndex], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex + 1]);\n                        geometryEdgeIndices = edgeIndices.subarray(eachGeometryEdgeIndicesPortion [geometryIndex], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion [geometryIndex + 1]);\n                        break;\n                    case 1: // Surface\n                        primitiveName = \"triangles\";\n                        geometryPositions = positions.subarray(eachGeometryPositionsPortion [geometryIndex], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex + 1]);\n                        geometryNormals = normals.subarray(eachGeometryNormalsPortion [geometryIndex], atLastGeometry ? normals.length : eachGeometryNormalsPortion [geometryIndex + 1]);\n                        geometryIndices = indices.subarray(eachGeometryIndicesPortion [geometryIndex], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex + 1]);\n                        geometryEdgeIndices = edgeIndices.subarray(eachGeometryEdgeIndicesPortion [geometryIndex], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion [geometryIndex + 1]);\n                        break;\n                    case 2:\n                        primitiveName = \"points\";\n                        geometryPositions = positions.subarray(eachGeometryPositionsPortion [geometryIndex], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex + 1]);\n                        geometryColors = colors.subarray(eachGeometryColorsPortion [geometryIndex], atLastGeometry ? colors.length : eachGeometryColorsPortion [geometryIndex + 1]);\n                        break;\n                    case 3:\n                        primitiveName = \"lines\";\n                        geometryPositions = positions.subarray(eachGeometryPositionsPortion [geometryIndex], atLastGeometry ? positions.length : eachGeometryPositionsPortion [geometryIndex + 1]);\n                        geometryIndices = indices.subarray(eachGeometryIndicesPortion [geometryIndex], atLastGeometry ? indices.length : eachGeometryIndicesPortion [geometryIndex + 1]);\n                        break;\n                    default:\n                        continue;\n                }\n\n                if (geometryPositions && !compareArrays(geometryPositions, xktGeometry.positionsQuantized)) {\n                    console.error(\"compareArrays(geometryPositions, xktGeometry.positionsQuantized) === false\");\n                    return false;\n                }\n\n                if (geometryNormals && !compareArrays(geometryNormals, xktGeometry.normalsOctEncoded)) {\n                    console.error(\"compareArrays(geometryNormals, xktGeometry.normalsOctEncoded) === false\");\n                    return false;\n                }\n\n                if (geometryColors && !compareArrays(geometryColors, xktGeometry.colorsCompressed)) {\n                    console.error(\"compareArrays(geometryColors, xktGeometry.colorsCompressed) === false\");\n                    return false;\n                }\n\n                if (geometryIndices && !compareArrays(geometryIndices, xktGeometry.indices)) {\n                    console.error(\"compareArrays(geometryIndices, xktGeometry.indices) === false\");\n                    return false;\n                }\n\n                if (geometryEdgeIndices && !compareArrays(geometryEdgeIndices, xktGeometry.edgeIndices)) {\n                    console.error(\"compareArrays(geometryEdgeIndices, xktGeometry.edgeIndices) === false\");\n                    return false;\n                }\n\n                if (geometryReuseCount !== xktGeometry.numInstances) {\n                    console.error(\"geometryReuseCount !== xktGeometry.numInstances\");\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nfunction compareArrays(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0, len = a.length; i < len; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport {validateXKTArrayBuffer};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/XKTModel/validateXKTArrayBuffer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 160,
    "kind": "function",
    "name": "extract",
    "memberof": "src/XKTModel/validateXKTArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/validateXKTArrayBuffer.js~extract",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/validateXKTArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "params": [
      {
        "name": "elements",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"positions\": *, \"normals\": *, \"colors\": *, \"indices\": *, \"edgeIndices\": *, \"matrices\": *, \"reusedGeometriesDecodeMatrix\": *, \"eachGeometryPrimitiveType\": *, \"eachGeometryPositionsPortion\": *, \"eachGeometryNormalsPortion\": *, \"eachGeometryColorsPortion\": *, \"eachGeometryIndicesPortion\": *, \"eachGeometryEdgeIndicesPortion\": *, \"eachMeshGeometriesPortion\": *, \"eachMeshMatricesPortion\": *, \"eachMeshColorAndOpacity\": *, \"eachEntityId\": *, \"eachEntityMeshesPortion\": *, \"eachTileAABB\": *, \"eachTileEntitiesPortion\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 161,
    "kind": "function",
    "name": "inflate",
    "memberof": "src/XKTModel/validateXKTArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/validateXKTArrayBuffer.js~inflate",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/validateXKTArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "params": [
      {
        "name": "deflatedData",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"positions\": *, \"normals\": *, \"colors\": *, \"indices\": *, \"edgeIndices\": *, \"matrices\": *, \"reusedGeometriesDecodeMatrix\": *, \"eachGeometryPrimitiveType\": *, \"eachGeometryPositionsPortion\": *, \"eachGeometryNormalsPortion\": *, \"eachGeometryColorsPortion\": *, \"eachGeometryIndicesPortion\": *, \"eachGeometryEdgeIndicesPortion\": *, \"eachMeshGeometriesPortion\": *, \"eachMeshMatricesPortion\": *, \"eachMeshColorAndOpacity\": *, \"eachEntityId\": *, \"eachEntityMeshesPortion\": *, \"eachTileAABB\": *, \"eachTileEntitiesPortion\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 162,
    "kind": "variable",
    "name": "decompressColor",
    "memberof": "src/XKTModel/validateXKTArrayBuffer.js",
    "static": true,
    "longname": "src/XKTModel/validateXKTArrayBuffer.js~decompressColor",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/validateXKTArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 111,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 163,
    "kind": "function",
    "name": "validateData",
    "memberof": "src/XKTModel/validateXKTArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/validateXKTArrayBuffer.js~validateData",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/validateXKTArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "params": [
      {
        "name": "inflatedData",
        "types": [
          "*"
        ]
      },
      {
        "name": "xktModel",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 164,
    "kind": "function",
    "name": "compareArrays",
    "memberof": "src/XKTModel/validateXKTArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/validateXKTArrayBuffer.js~compareArrays",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/validateXKTArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 415,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 165,
    "kind": "function",
    "name": "validateXKTArrayBuffer",
    "memberof": "src/XKTModel/validateXKTArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/validateXKTArrayBuffer.js~validateXKTArrayBuffer",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/validateXKTArrayBuffer.js",
    "importStyle": "{validateXKTArrayBuffer}",
    "description": "Validates an {@link ArrayBuffer} against the {@link XKTModel} it was written from.",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Boolean} True if valid, else false. Logs validity failures to the JS console."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": false,
        "name": "arrayBuffer",
        "description": "The {@link ArrayBuffer}."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "xktModel",
        "description": "The {@link XKTModel} that the {@link ArrayBuffer} was written from."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": "True if valid, else false. Logs validity failures to the JS console."
    }
  },
  {
    "__docId__": 166,
    "kind": "file",
    "name": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "content": "import * as p from \"./lib/pako.es.js\";\n\nlet pako = p;\nif (!pako.inflate) {  // See https://github.com/nodeca/pako/issues/97\n    pako = pako.default;\n}\n\nconst XKT_VERSION = 7; // XKT format version\n\n/**\n * Writes an {@link XKTModel} to an {@link ArrayBuffer}.\n *\n * @param {XKTModel} xktModel The {@link XKTModel}.\n * @returns {ArrayBuffer} The {@link ArrayBuffer}.\n */\nfunction writeXKTModelToArrayBuffer(xktModel) {\n\n    const data = getModelData(xktModel);\n\n    const deflatedData = deflateData(data);\n\n    const arrayBuffer = createArrayBuffer(deflatedData);\n\n    return arrayBuffer;\n}\n\nfunction getModelData(xktModel) {\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Allocate data\n    //------------------------------------------------------------------------------------------------------------------\n\n    const geometriesList = xktModel.geometriesList;\n    const meshesList = xktModel.meshesList;\n    const entitiesList = xktModel.entitiesList;\n    const tilesList = xktModel.tilesList;\n\n    const numGeometries = geometriesList.length;\n    const numMeshes = meshesList.length;\n    const numEntities = entitiesList.length;\n    const numTiles = tilesList.length;\n\n    let lenPositions = 0;\n    let lenNormals = 0;\n    let lenColors = 0;\n    let lenIndices = 0;\n    let lenEdgeIndices = 0;\n    let lenMatrices = 0;\n\n    for (let geometryIndex = 0; geometryIndex < numGeometries; geometryIndex++) {\n        const geometry = geometriesList [geometryIndex];\n        if (geometry.positionsQuantized) {\n            lenPositions += geometry.positionsQuantized.length;\n        }\n        if (geometry.normalsOctEncoded) {\n            lenNormals += geometry.normalsOctEncoded.length;\n        }\n        if (geometry.colorsCompressed) {\n            lenColors += geometry.colorsCompressed.length;\n        }\n        if (geometry.indices) {\n            lenIndices += geometry.indices.length;\n        }\n        if (geometry.edgeIndices) {\n            lenEdgeIndices += geometry.edgeIndices.length;\n        }\n    }\n\n    for (let meshIndex = 0; meshIndex < numMeshes; meshIndex++) {\n        const mesh = meshesList[meshIndex];\n        if (mesh.geometry.numInstances > 1) {\n            lenMatrices += 16;\n        }\n    }\n\n    const data = {\n\n        // Vertex attributes\n\n        positions: new Uint16Array(lenPositions), // All geometry arrays\n        normals: new Int8Array(lenNormals),\n        colors: new Uint8Array(lenColors),\n\n        // Indices\n\n        indices: new Uint32Array(lenIndices),\n        edgeIndices: new Uint32Array(lenEdgeIndices),\n\n        // Transform matrices\n\n        matrices: new Float32Array(lenMatrices), // Modeling matrices for entities that share geometries. Each entity either shares all it's geometries, or owns all its geometries exclusively. Exclusively-owned geometries are pre-transformed into World-space, and so their entities don't have modeling matrices in this array.\n\n        reusedGeometriesDecodeMatrix: new Float32Array(xktModel.reusedGeometriesDecodeMatrix), // A single, global vertex position de-quantization matrix for all reused geometries. Reused geometries are quantized to their collective Local-space AABB, and this matrix is derived from that AABB.\n\n        // Geometries\n\n        eachGeometryPrimitiveType: new Uint8Array(numGeometries), // Primitive type for each geometry (0=solid triangles, 1=surface triangles, 2=lines, 3=points)\n        eachGeometryPositionsPortion: new Uint32Array(numGeometries), // For each geometry, an index to its first element in data.positions. Every primitive type has positions.\n        eachGeometryNormalsPortion: new Uint32Array(numGeometries), // For each geometry, an index to its first element in data.normals. If the next geometry has the same index, then this geometry has no normals.\n        eachGeometryColorsPortion: new Uint32Array(numGeometries), // For each geometry, an index to its first element in data.colors. If the next geometry has the same index, then this geometry has no colors.\n        eachGeometryIndicesPortion: new Uint32Array(numGeometries), // For each geometry, an index to its first element in data.indices. If the next geometry has the same index, then this geometry has no indices.\n        eachGeometryEdgeIndicesPortion: new Uint32Array(numGeometries), // For each geometry, an index to its first element in data.edgeIndices. If the next geometry has the same index, then this geometry has no edge indices.\n\n        // Meshes are grouped in runs that are shared by the same entities.\n\n        // We duplicate materials for meshes, rather than reusing them, because each material is only 6 bytes and an index\n        // into a common materials array would be 4 bytes, so it's hardly worth reusing materials, as long as they are that compact.\n\n        eachMeshGeometriesPortion: new Uint32Array(numMeshes), // For each mesh, an index into the eachGeometry* arrays\n        eachMeshMatricesPortion: new Uint32Array(numMeshes), // For each mesh that shares its geometry, an index to its first element in data.matrices, to indicate the modeling matrix that transforms the shared geometry Local-space vertex positions. This is ignored for meshes that don't share geometries, because the vertex positions of non-shared geometries are pre-transformed into World-space.\n        eachMeshMaterial: new Uint8Array(numMeshes * 6), // For each mesh, an RGBA integer color of format [0..255, 0..255, 0..255, 0..255], and PBR metallic and roughness factors, of format [0..255, 0..255]\n\n        // Entity elements in the following arrays are grouped in runs that are shared by the same tiles\n\n        eachEntityId: [], // For each entity, an ID string\n        eachEntityMeshesPortion: new Uint32Array(numEntities), // For each entity, the index of the the first element of meshes used by the entity\n\n        eachTileAABB: new Float64Array(numTiles * 6), // For each tile, an axis-aligned bounding box\n        eachTileEntitiesPortion: new Uint32Array(numTiles) // For each tile, the index of the the first element of eachEntityId, eachEntityMeshesPortion and eachEntityMatricesPortion used by the tile\n    };\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Populate the data\n    //------------------------------------------------------------------------------------------------------------------\n\n    let countPositions = 0;\n    let countNormals = 0;\n    let countColors = 0;\n    let countIndices = 0;\n    let countEdgeIndices = 0;\n    let countMeshColors = 0;\n\n    // Geometries\n\n    let matricesIndex = 0;\n\n    for (let geometryIndex = 0; geometryIndex < numGeometries; geometryIndex++) {\n\n        const geometry = geometriesList [geometryIndex];\n\n        const primitiveType\n            = (geometry.primitiveType === \"triangles\")\n            ? (geometry.solid ? 0 : 1)\n            : (geometry.primitiveType === \"points\" ? 2 : 3)\n\n        data.eachGeometryPrimitiveType [geometryIndex] = primitiveType;\n        data.eachGeometryPositionsPortion [geometryIndex] = countPositions;\n        data.eachGeometryNormalsPortion [geometryIndex] = countNormals;\n        data.eachGeometryColorsPortion [geometryIndex] = countColors;\n        data.eachGeometryIndicesPortion [geometryIndex] = countIndices;\n        data.eachGeometryEdgeIndicesPortion [geometryIndex] = countEdgeIndices;\n\n        if (geometry.positionsQuantized) {\n            data.positions.set(geometry.positionsQuantized, countPositions);\n            countPositions += geometry.positionsQuantized.length;\n        }\n        if (geometry.normalsOctEncoded) {\n            data.normals.set(geometry.normalsOctEncoded, countNormals);\n            countNormals += geometry.normalsOctEncoded.length;\n        }\n        if (geometry.colorsCompressed) {\n            data.colors.set(geometry.colorsCompressed, countColors);\n            countColors += geometry.colorsCompressed.length;\n        }\n        if (geometry.indices) {\n            data.indices.set(geometry.indices, countIndices);\n            countIndices += geometry.indices.length;\n        }\n        if (geometry.edgeIndices) {\n            data.edgeIndices.set(geometry.edgeIndices, countEdgeIndices);\n            countEdgeIndices += geometry.edgeIndices.length;\n        }\n    }\n\n    // Meshes\n\n    for (let meshIndex = 0; meshIndex < numMeshes; meshIndex++) {\n\n        const mesh = meshesList [meshIndex];\n\n        if (mesh.geometry.numInstances > 1) {\n\n            data.matrices.set(mesh.matrix, matricesIndex);\n            data.eachMeshMatricesPortion [meshIndex] = matricesIndex;\n\n            matricesIndex += 16;\n        }\n\n        data.eachMeshMaterial[countMeshColors + 0] = Math.floor(mesh.color[0] * 255);\n        data.eachMeshMaterial[countMeshColors + 1] = Math.floor(mesh.color[1] * 255);\n        data.eachMeshMaterial[countMeshColors + 2] = Math.floor(mesh.color[2] * 255);\n        data.eachMeshMaterial[countMeshColors + 3] = Math.floor(mesh.opacity * 255);\n        data.eachMeshMaterial[countMeshColors + 4] = Math.floor(mesh.metallic * 255);\n        data.eachMeshMaterial[countMeshColors + 5] = Math.floor(mesh.roughness * 255);\n\n        countMeshColors += 6;\n    }\n\n    // Entities, geometry instances, and tiles\n\n    let entityIndex = 0;\n    let countEntityGeometryInstancesPortion = 0;\n\n    for (let tileIndex = 0; tileIndex < numTiles; tileIndex++) {\n\n        const tile = tilesList [tileIndex];\n        const tileEntities = tile.entities;\n        const numTileEntities = tileEntities.length;\n\n        if (numTileEntities === 0) {\n            continue;\n        }\n\n        data.eachTileEntitiesPortion[tileIndex] = entityIndex;\n\n        const tileAABB = tile.aabb;\n\n        for (let j = 0; j < numTileEntities; j++) {\n\n            const entity = tileEntities[j];\n            const entityGeometryInstances = entity.meshes;\n            const numEntityGeometryInstances = entityGeometryInstances.length;\n\n            if (numEntityGeometryInstances === 0) {\n                continue;\n            }\n\n            for (let k = 0; k < numEntityGeometryInstances; k++) {\n\n                const geometryInstance = entityGeometryInstances[k];\n                const geometry = geometryInstance.geometry;\n                const geometryIndex = geometry.geometryIndex;\n\n                data.eachMeshGeometriesPortion [countEntityGeometryInstancesPortion + k] = geometryIndex;\n            }\n\n            data.eachEntityId [entityIndex] = entity.entityId;\n            data.eachEntityMeshesPortion[entityIndex] = countEntityGeometryInstancesPortion; // <<<<<<<<<<<<<<<<<<<< Error here? Order/value of countEntityGeometryInstancesPortion correct?\n\n            entityIndex++;\n            countEntityGeometryInstancesPortion += numEntityGeometryInstances;\n        }\n\n        const tileAABBIndex = tileIndex * 6;\n\n        data.eachTileAABB.set(tileAABB, tileAABBIndex);\n    }\n\n    return data;\n}\n\nfunction deflateData(data) {\n\n    return {\n\n        positions: pako.deflate(data.positions.buffer),\n        normals: pako.deflate(data.normals.buffer),\n        colors: pako.deflate(data.colors.buffer),\n        indices: pako.deflate(data.indices.buffer),\n        edgeIndices: pako.deflate(data.edgeIndices.buffer),\n\n        matrices: pako.deflate(data.matrices.buffer),\n        reusedGeometriesDecodeMatrix: pako.deflate(data.reusedGeometriesDecodeMatrix.buffer),\n\n        eachGeometryPrimitiveType: pako.deflate(data.eachGeometryPrimitiveType.buffer),\n        eachGeometryPositionsPortion: pako.deflate(data.eachGeometryPositionsPortion.buffer),\n        eachGeometryNormalsPortion: pako.deflate(data.eachGeometryNormalsPortion.buffer),\n        eachGeometryColorsPortion: pako.deflate(data.eachGeometryColorsPortion.buffer),\n        eachGeometryIndicesPortion: pako.deflate(data.eachGeometryIndicesPortion.buffer),\n        eachGeometryEdgeIndicesPortion: pako.deflate(data.eachGeometryEdgeIndicesPortion.buffer),\n\n        eachMeshGeometriesPortion: pako.deflate(data.eachMeshGeometriesPortion.buffer),\n        eachMeshMatricesPortion: pako.deflate(data.eachMeshMatricesPortion.buffer),\n        eachMeshMaterial: pako.deflate(data.eachMeshMaterial.buffer),\n\n        eachEntityId: pako.deflate(JSON.stringify(data.eachEntityId)\n            .replace(/[\\u007F-\\uFFFF]/g, function (chr) { // Produce only ASCII-chars, so that the data can be inflated later\n                return \"\\\\u\" + (\"0000\" + chr.charCodeAt(0).toString(16)).substr(-4)\n            })),\n        eachEntityMeshesPortion: pako.deflate(data.eachEntityMeshesPortion.buffer),\n\n        eachTileAABB: pako.deflate(data.eachTileAABB.buffer),\n        eachTileEntitiesPortion: pako.deflate(data.eachTileEntitiesPortion.buffer)\n    };\n}\n\nfunction createArrayBuffer(deflatedData) {\n\n    return toArrayBuffer([\n\n        deflatedData.positions,\n        deflatedData.normals,\n        deflatedData.colors,\n\n        deflatedData.indices,\n        deflatedData.edgeIndices,\n\n        deflatedData.matrices,\n        deflatedData.reusedGeometriesDecodeMatrix,\n\n        deflatedData.eachGeometryPrimitiveType,\n        deflatedData.eachGeometryPositionsPortion,\n        deflatedData.eachGeometryNormalsPortion,\n        deflatedData.eachGeometryColorsPortion,\n        deflatedData.eachGeometryIndicesPortion,\n        deflatedData.eachGeometryEdgeIndicesPortion,\n\n        deflatedData.eachMeshGeometriesPortion,\n        deflatedData.eachMeshMatricesPortion,\n        deflatedData.eachMeshMaterial,\n\n        deflatedData.eachEntityId,\n        deflatedData.eachEntityMeshesPortion,\n\n        deflatedData.eachTileAABB,\n        deflatedData.eachTileEntitiesPortion\n    ]);\n}\n\nfunction toArrayBuffer(elements) {\n    const indexData = new Uint32Array(elements.length + 2);\n    indexData[0] = XKT_VERSION;\n    indexData [1] = elements.length;  // Stored Data 1.1: number of stored elements\n    let dataLen = 0;    // Stored Data 1.2: length of stored elements\n    for (let i = 0, len = elements.length; i < len; i++) {\n        const element = elements[i];\n        const elementsize = element.length;\n        indexData[i + 2] = elementsize;\n        dataLen += elementsize;\n    }\n    const indexBuf = new Uint8Array(indexData.buffer);\n    const dataArray = new Uint8Array(indexBuf.length + dataLen);\n    dataArray.set(indexBuf);\n    let offset = indexBuf.length;\n    for (let i = 0, len = elements.length; i < len; i++) {     // Stored Data 2: the elements themselves\n        const element = elements[i];\n        dataArray.set(element, offset);\n        offset += element.length;\n    }\n    console.log(\"Array buffer size: \" + (dataArray.length / 1024).toFixed(3) + \" kB\");\n    return dataArray.buffer;\n}\n\nexport {writeXKTModelToArrayBuffer};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 167,
    "kind": "variable",
    "name": "pako",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~pako",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 168,
    "kind": "variable",
    "name": "XKT_VERSION",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~XKT_VERSION",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 169,
    "kind": "function",
    "name": "getModelData",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~getModelData",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "xktModel",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 170,
    "kind": "function",
    "name": "deflateData",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~deflateData",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 252,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"positions\": *, \"normals\": *, \"colors\": *, \"indices\": *, \"edgeIndices\": *, \"matrices\": *, \"reusedGeometriesDecodeMatrix\": *, \"eachGeometryPrimitiveType\": *, \"eachGeometryPositionsPortion\": *, \"eachGeometryNormalsPortion\": *, \"eachGeometryColorsPortion\": *, \"eachGeometryIndicesPortion\": *, \"eachGeometryEdgeIndicesPortion\": *, \"eachMeshGeometriesPortion\": *, \"eachMeshMatricesPortion\": *, \"eachMeshMaterial\": *, \"eachEntityId\": *, \"eachEntityMeshesPortion\": *, \"eachTileAABB\": *, \"eachTileEntitiesPortion\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 171,
    "kind": "function",
    "name": "createArrayBuffer",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~createArrayBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 287,
    "undocument": true,
    "params": [
      {
        "name": "deflatedData",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 172,
    "kind": "function",
    "name": "toArrayBuffer",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~toArrayBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 320,
    "undocument": true,
    "params": [
      {
        "name": "elements",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 173,
    "kind": "function",
    "name": "writeXKTModelToArrayBuffer",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~writeXKTModelToArrayBuffer",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": "{writeXKTModelToArrayBuffer}",
    "description": "Writes an {@link XKTModel} to an {@link ArrayBuffer}.",
    "lineNumber": 16,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ArrayBuffer} The {@link ArrayBuffer}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "xktModel",
        "description": "The {@link XKTModel}."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayBuffer"
      ],
      "spread": false,
      "description": "The {@link ArrayBuffer}."
    }
  },
  {
    "__docId__": 174,
    "kind": "file",
    "name": "src/geometryBuilders/buildBoxGeometry.js",
    "content": "/**\n * @desc Creates box-shaped triangle mesh geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a box-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildBoxGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const box = buildBoxGeometry({\n *     primitiveType: \"triangles\" // or \"lines\"\n *     center: [0,0,0],\n *     xSize: 1,  // Half-size on each axis\n *     ySize: 1,\n *     zSize: 1\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"boxGeometry\",\n *      primitiveType: box.primitiveType,\n *      positions: box.positions,\n *      normals: box.normals,\n *      indices: box.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redBoxMesh\",\n *      geometryId: \"boxGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redBox\",\n *      meshIds: [\"redBoxMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildBoxGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center]  3D point indicating the center position.\n * @param {Number} [cfg.xSize=1.0]  Half-size on the X-axis.\n * @param {Number} [cfg.ySize=1.0]  Half-size on the Y-axis.\n * @param {Number} [cfg.zSize=1.0]  Half-size on the Z-axis.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildBoxGeometry(cfg = {}) {\n\n    let xSize = cfg.xSize || 1;\n    if (xSize < 0) {\n        console.error(\"negative xSize not allowed - will invert\");\n        xSize *= -1;\n    }\n\n    let ySize = cfg.ySize || 1;\n    if (ySize < 0) {\n        console.error(\"negative ySize not allowed - will invert\");\n        ySize *= -1;\n    }\n\n    let zSize = cfg.zSize || 1;\n    if (zSize < 0) {\n        console.error(\"negative zSize not allowed - will invert\");\n        zSize *= -1;\n    }\n\n    const center = cfg.center;\n    const centerX = center ? center[0] : 0;\n    const centerY = center ? center[1] : 0;\n    const centerZ = center ? center[2] : 0;\n\n    const xmin = -xSize + centerX;\n    const ymin = -ySize + centerY;\n    const zmin = -zSize + centerZ;\n    const xmax = xSize + centerX;\n    const ymax = ySize + centerY;\n    const zmax = zSize + centerZ;\n\n    return {\n\n        primitiveType: \"triangles\",\n\n        // The vertices - eight for our cube, each\n        // one spanning three array elements for X,Y and Z\n\n        positions: [\n\n            // v0-v1-v2-v3 front\n            xmax, ymax, zmax,\n            xmin, ymax, zmax,\n            xmin, ymin, zmax,\n            xmax, ymin, zmax,\n\n            // v0-v3-v4-v1 right\n            xmax, ymax, zmax,\n            xmax, ymin, zmax,\n            xmax, ymin, zmin,\n            xmax, ymax, zmin,\n\n            // v0-v1-v6-v1 top\n            xmax, ymax, zmax,\n            xmax, ymax, zmin,\n            xmin, ymax, zmin,\n            xmin, ymax, zmax,\n\n            // v1-v6-v7-v2 left\n            xmin, ymax, zmax,\n            xmin, ymax, zmin,\n            xmin, ymin, zmin,\n            xmin, ymin, zmax,\n\n            // v7-v4-v3-v2 bottom\n            xmin, ymin, zmin,\n            xmax, ymin, zmin,\n            xmax, ymin, zmax,\n            xmin, ymin, zmax,\n\n            // v4-v7-v6-v1 back\n            xmax, ymin, zmin,\n            xmin, ymin, zmin,\n            xmin, ymax, zmin,\n            xmax, ymax, zmin\n        ],\n\n        // Normal vectors, one for each vertex\n        normals: [\n\n            // v0-v1-v2-v3 front\n            0, 0, 1,\n            0, 0, 1,\n            0, 0, 1,\n            0, 0, 1,\n\n            // v0-v3-v4-v5 right\n            1, 0, 0,\n            1, 0, 0,\n            1, 0, 0,\n            1, 0, 0,\n\n            // v0-v5-v6-v1 top\n            0, 1, 0,\n            0, 1, 0,\n            0, 1, 0,\n            0, 1, 0,\n\n            // v1-v6-v7-v2 left\n            -1, 0, 0,\n            -1, 0, 0,\n            -1, 0, 0,\n            -1, 0, 0,\n\n            // v7-v4-v3-v2 bottom\n            0, -1, 0,\n            0, -1, 0,\n            0, -1, 0,\n            0, -1, 0,\n\n            // v4-v7-v6-v5 back\n            0, 0, -1,\n            0, 0, -1,\n            0, 0, -1,\n            0, 0, -1\n        ],\n\n        // UV coords\n        uv: [\n\n            // v0-v1-v2-v3 front\n            1, 0,\n            0, 0,\n            0, 1,\n            1, 1,\n\n            // v0-v3-v4-v1 right\n            0, 0,\n            0, 1,\n            1, 1,\n            1, 0,\n\n            // v0-v1-v6-v1 top\n            1, 1,\n            1, 0,\n            0, 0,\n            0, 1,\n\n            // v1-v6-v7-v2 left\n            1, 0,\n            0, 0,\n            0, 1,\n            1, 1,\n\n            // v7-v4-v3-v2 bottom\n            0, 1,\n            1, 1,\n            1, 0,\n            0, 0,\n\n            // v4-v7-v6-v1 back\n            0, 1,\n            1, 1,\n            1, 0,\n            0, 0\n        ],\n\n        // Indices - these organise the\n        // positions and uv texture coordinates\n        // into geometric primitives in accordance\n        // with the \"primitive\" parameter,\n        // in this case a set of three indices\n        // for each triangle.\n        //\n        // Note that each triangle is specified\n        // in counter-clockwise winding order.\n        //\n        // You can specify them in clockwise\n        // order if you configure the Modes\n        // node's frontFace flag as \"cw\", instead of\n        // the default \"ccw\".\n        indices: [\n            0, 1, 2,\n            0, 2, 3,\n            // front\n            4, 5, 6,\n            4, 6, 7,\n            // right\n            8, 9, 10,\n            8, 10, 11,\n            // top\n            12, 13, 14,\n            12, 14, 15,\n            // left\n            16, 17, 18,\n            16, 18, 19,\n            // bottom\n            20, 21, 22,\n            20, 22, 23\n        ]\n    };\n}\n\nexport {buildBoxGeometry};\n",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/geometryBuilders/buildBoxGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 175,
    "kind": "function",
    "name": "buildBoxGeometry",
    "memberof": "src/geometryBuilders/buildBoxGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildBoxGeometry.js~buildBoxGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/geometryBuilders/buildBoxGeometry.js",
    "importStyle": "{buildBoxGeometry}",
    "description": "Creates box-shaped triangle mesh geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a box-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildBoxGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst box = buildBoxGeometry({\n    primitiveType: \"triangles\" // or \"lines\"\n    center: [0,0,0],\n    xSize: 1,  // Half-size on each axis\n    ySize: 1,\n    zSize: 1\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"boxGeometry\",\n     primitiveType: box.primitiveType,\n     positions: box.positions,\n     normals: box.normals,\n     indices: box.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redBoxMesh\",\n     geometryId: \"boxGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redBox\",\n     meshIds: [\"redBoxMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 55,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildBoxGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.xSize",
        "description": "Half-size on the X-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.ySize",
        "description": "Half-size on the Y-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.zSize",
        "description": "Half-size on the Z-axis."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 176,
    "kind": "file",
    "name": "src/geometryBuilders/buildBoxLinesGeometry.js",
    "content": "/**\n * @desc Creates box-shaped line segment geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a box-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildBoxLinesGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const box = buildBoxLinesGeometry({\n *     center: [0,0,0],\n *     xSize: 1,  // Half-size on each axis\n *     ySize: 1,\n *     zSize: 1\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"boxGeometry\",\n *      primitiveType: box.primitiveType, // \"lines\"\n *      positions: box.positions,\n *      normals: box.normals,\n *      indices: box.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redBoxMesh\",\n *      geometryId: \"boxGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redBox\",\n *      meshIds: [\"redBoxMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildBoxLinesGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center]  3D point indicating the center position.\n * @param {Number} [cfg.xSize=1.0]  Half-size on the X-axis.\n * @param {Number} [cfg.ySize=1.0]  Half-size on the Y-axis.\n * @param {Number} [cfg.zSize=1.0]  Half-size on the Z-axis.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildBoxLinesGeometry(cfg = {}) {\n\n    let xSize = cfg.xSize || 1;\n    if (xSize < 0) {\n        console.error(\"negative xSize not allowed - will invert\");\n        xSize *= -1;\n    }\n\n    let ySize = cfg.ySize || 1;\n    if (ySize < 0) {\n        console.error(\"negative ySize not allowed - will invert\");\n        ySize *= -1;\n    }\n\n    let zSize = cfg.zSize || 1;\n    if (zSize < 0) {\n        console.error(\"negative zSize not allowed - will invert\");\n        zSize *= -1;\n    }\n\n    const center = cfg.center;\n    const centerX = center ? center[0] : 0;\n    const centerY = center ? center[1] : 0;\n    const centerZ = center ? center[2] : 0;\n\n    const xmin = -xSize + centerX;\n    const ymin = -ySize + centerY;\n    const zmin = -zSize + centerZ;\n    const xmax = xSize + centerX;\n    const ymax = ySize + centerY;\n    const zmax = zSize + centerZ;\n\n    return {\n        primitiveType: \"lines\",\n        positions: [\n            xmin, ymin, zmin,\n            xmin, ymin, zmax,\n            xmin, ymax, zmin,\n            xmin, ymax, zmax,\n            xmax, ymin, zmin,\n            xmax, ymin, zmax,\n            xmax, ymax, zmin,\n            xmax, ymax, zmax\n        ],\n        indices: [\n            0, 1,\n            1, 3,\n            3, 2,\n            2, 0,\n            4, 5,\n            5, 7,\n            7, 6,\n            6, 4,\n            0, 4,\n            1, 5,\n            2, 6,\n            3, 7\n        ]\n    }\n}\n\nexport {buildBoxLinesGeometry};\n",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/geometryBuilders/buildBoxLinesGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 177,
    "kind": "function",
    "name": "buildBoxLinesGeometry",
    "memberof": "src/geometryBuilders/buildBoxLinesGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildBoxLinesGeometry.js~buildBoxLinesGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/geometryBuilders/buildBoxLinesGeometry.js",
    "importStyle": "{buildBoxLinesGeometry}",
    "description": "Creates box-shaped line segment geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a box-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildBoxLinesGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst box = buildBoxLinesGeometry({\n    center: [0,0,0],\n    xSize: 1,  // Half-size on each axis\n    ySize: 1,\n    zSize: 1\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"boxGeometry\",\n     primitiveType: box.primitiveType, // \"lines\"\n     positions: box.positions,\n     normals: box.normals,\n     indices: box.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redBoxMesh\",\n     geometryId: \"boxGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redBox\",\n     meshIds: [\"redBoxMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildBoxLinesGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.xSize",
        "description": "Half-size on the X-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.ySize",
        "description": "Half-size on the Y-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.zSize",
        "description": "Half-size on the Z-axis."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 178,
    "kind": "file",
    "name": "src/geometryBuilders/buildCylinderGeometry.js",
    "content": "/**\n * @desc Creates cylinder-shaped geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a cylinder-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildCylinderGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const cylinder = buildCylinderGeometry({\n *      center: [0,0,0],\n *      radiusTop: 2.0,\n *      radiusBottom: 2.0,\n *      height: 5.0,\n *      radialSegments: 20,\n *      heightSegments: 1,\n *      openEnded: false\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"cylinderGeometry\",\n *      primitiveType: cylinder.primitiveType,\n *      positions: cylinder.positions,\n *      normals: cylinder.normals,\n *      indices: cylinder.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redCylinderMesh\",\n *      geometryId: \"cylinderGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redCylinder\",\n *      meshIds: [\"redCylinderMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildCylinderGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center] 3D point indicating the center position.\n * @param {Number} [cfg.radiusTop=1]  Radius of top.\n * @param {Number} [cfg.radiusBottom=1]  Radius of bottom.\n * @param {Number} [cfg.height=1] Height.\n * @param {Number} [cfg.radialSegments=60]  Number of horizontal segments.\n * @param {Number} [cfg.heightSegments=1]  Number of vertical segments.\n * @param {Boolean} [cfg.openEnded=false]  Whether or not the cylinder has solid caps on the ends.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildCylinderGeometry(cfg = {}) {\n\n    let radiusTop = cfg.radiusTop || 1;\n    if (radiusTop < 0) {\n        console.error(\"negative radiusTop not allowed - will invert\");\n        radiusTop *= -1;\n    }\n\n    let radiusBottom = cfg.radiusBottom || 1;\n    if (radiusBottom < 0) {\n        console.error(\"negative radiusBottom not allowed - will invert\");\n        radiusBottom *= -1;\n    }\n\n    let height = cfg.height || 1;\n    if (height < 0) {\n        console.error(\"negative height not allowed - will invert\");\n        height *= -1;\n    }\n\n    let radialSegments = cfg.radialSegments || 32;\n    if (radialSegments < 0) {\n        console.error(\"negative radialSegments not allowed - will invert\");\n        radialSegments *= -1;\n    }\n    if (radialSegments < 3) {\n        radialSegments = 3;\n    }\n\n    let heightSegments = cfg.heightSegments || 1;\n    if (heightSegments < 0) {\n        console.error(\"negative heightSegments not allowed - will invert\");\n        heightSegments *= -1;\n    }\n    if (heightSegments < 1) {\n        heightSegments = 1;\n    }\n\n    const openEnded = !!cfg.openEnded;\n\n    let center = cfg.center;\n    const centerX = center ? center[0] : 0;\n    const centerY = center ? center[1] : 0;\n    const centerZ = center ? center[2] : 0;\n\n    const heightHalf = height / 2;\n    const heightLength = height / heightSegments;\n    const radialAngle = (2.0 * Math.PI / radialSegments);\n    const radialLength = 1.0 / radialSegments;\n    //var nextRadius = this._radiusBottom;\n    const radiusChange = (radiusTop - radiusBottom) / heightSegments;\n\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n\n    let h;\n    let i;\n\n    let x;\n    let z;\n\n    let currentRadius;\n    let currentHeight;\n\n    let first;\n    let second;\n\n    let startIndex;\n    let tu;\n    let tv;\n\n    // create vertices\n    const normalY = (90.0 - (Math.atan(height / (radiusBottom - radiusTop))) * 180 / Math.PI) / 90.0;\n\n    for (h = 0; h <= heightSegments; h++) {\n        currentRadius = radiusTop - h * radiusChange;\n        currentHeight = heightHalf - h * heightLength;\n\n        for (i = 0; i <= radialSegments; i++) {\n            x = Math.sin(i * radialAngle);\n            z = Math.cos(i * radialAngle);\n\n            normals.push(currentRadius * x);\n            normals.push(normalY); //todo\n            normals.push(currentRadius * z);\n\n            uvs.push((i * radialLength));\n            uvs.push(h * 1 / heightSegments);\n\n            positions.push((currentRadius * x) + centerX);\n            positions.push((currentHeight) + centerY);\n            positions.push((currentRadius * z) + centerZ);\n        }\n    }\n\n    // create faces\n    for (h = 0; h < heightSegments; h++) {\n        for (i = 0; i <= radialSegments; i++) {\n\n            first = h * (radialSegments + 1) + i;\n            second = first + radialSegments;\n\n            indices.push(first);\n            indices.push(second);\n            indices.push(second + 1);\n\n            indices.push(first);\n            indices.push(second + 1);\n            indices.push(first + 1);\n        }\n    }\n\n    // create top cap\n    if (!openEnded && radiusTop > 0) {\n        startIndex = (positions.length / 3);\n\n        // top center\n        normals.push(0.0);\n        normals.push(1.0);\n        normals.push(0.0);\n\n        uvs.push(0.5);\n        uvs.push(0.5);\n\n        positions.push(0 + centerX);\n        positions.push(heightHalf + centerY);\n        positions.push(0 + centerZ);\n\n        // top triangle fan\n        for (i = 0; i <= radialSegments; i++) {\n            x = Math.sin(i * radialAngle);\n            z = Math.cos(i * radialAngle);\n            tu = (0.5 * Math.sin(i * radialAngle)) + 0.5;\n            tv = (0.5 * Math.cos(i * radialAngle)) + 0.5;\n\n            normals.push(radiusTop * x);\n            normals.push(1.0);\n            normals.push(radiusTop * z);\n\n            uvs.push(tu);\n            uvs.push(tv);\n\n            positions.push((radiusTop * x) + centerX);\n            positions.push((heightHalf) + centerY);\n            positions.push((radiusTop * z) + centerZ);\n        }\n\n        for (i = 0; i < radialSegments; i++) {\n            center = startIndex;\n            first = startIndex + 1 + i;\n\n            indices.push(first);\n            indices.push(first + 1);\n            indices.push(center);\n        }\n    }\n\n    // create bottom cap\n    if (!openEnded && radiusBottom > 0) {\n\n        startIndex = (positions.length / 3);\n\n        // top center\n        normals.push(0.0);\n        normals.push(-1.0);\n        normals.push(0.0);\n\n        uvs.push(0.5);\n        uvs.push(0.5);\n\n        positions.push(0 + centerX);\n        positions.push(0 - heightHalf + centerY);\n        positions.push(0 + centerZ);\n\n        // top triangle fan\n        for (i = 0; i <= radialSegments; i++) {\n\n            x = Math.sin(i * radialAngle);\n            z = Math.cos(i * radialAngle);\n\n            tu = (0.5 * Math.sin(i * radialAngle)) + 0.5;\n            tv = (0.5 * Math.cos(i * radialAngle)) + 0.5;\n\n            normals.push(radiusBottom * x);\n            normals.push(-1.0);\n            normals.push(radiusBottom * z);\n\n            uvs.push(tu);\n            uvs.push(tv);\n\n            positions.push((radiusBottom * x) + centerX);\n            positions.push((0 - heightHalf) + centerY);\n            positions.push((radiusBottom * z) + centerZ);\n        }\n\n        for (i = 0; i < radialSegments; i++) {\n\n            center = startIndex;\n            first = startIndex + 1 + i;\n\n            indices.push(center);\n            indices.push(first + 1);\n            indices.push(first);\n        }\n    }\n\n    return  {\n        primitiveType: \"triangles\",\n        positions: positions,\n        normals: normals,\n        uv: uvs,\n        indices: indices\n    };\n}\n\n\nexport {buildCylinderGeometry};\n",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/geometryBuilders/buildCylinderGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 179,
    "kind": "function",
    "name": "buildCylinderGeometry",
    "memberof": "src/geometryBuilders/buildCylinderGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildCylinderGeometry.js~buildCylinderGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/geometryBuilders/buildCylinderGeometry.js",
    "importStyle": "{buildCylinderGeometry}",
    "description": "Creates cylinder-shaped geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a cylinder-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildCylinderGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst cylinder = buildCylinderGeometry({\n     center: [0,0,0],\n     radiusTop: 2.0,\n     radiusBottom: 2.0,\n     height: 5.0,\n     radialSegments: 20,\n     heightSegments: 1,\n     openEnded: false\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"cylinderGeometry\",\n     primitiveType: cylinder.primitiveType,\n     positions: cylinder.positions,\n     normals: cylinder.normals,\n     indices: cylinder.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redCylinderMesh\",\n     geometryId: \"cylinderGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redCylinder\",\n     meshIds: [\"redCylinderMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 60,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildCylinderGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.radiusTop",
        "description": "Radius of top."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.radiusBottom",
        "description": "Radius of bottom."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.height",
        "description": "Height."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "60",
        "defaultRaw": 60,
        "name": "cfg.radialSegments",
        "description": "Number of horizontal segments."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.heightSegments",
        "description": "Number of vertical segments."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "cfg.openEnded",
        "description": "Whether or not the cylinder has solid caps on the ends."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 180,
    "kind": "file",
    "name": "src/geometryBuilders/buildGridGeometry.js",
    "content": "/**\n * @desc Creates grid-shaped geometry arrays..\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a grid-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildGridGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const grid = buildGridGeometry({\n *      size: 1000,\n *      divisions: 500\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"gridGeometry\",\n *      primitiveType: grid.primitiveType, // Will be \"lines\"\n *      positions: grid.positions,\n *      indices: grid.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redGridMesh\",\n *      geometryId: \"gridGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redGrid\",\n *      meshIds: [\"redGridMesh\"]\n * });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildGridGeometry\n * @param {*} [cfg] Configs\n * @param {Number} [cfg.size=1] Dimension on the X and Z-axis.\n * @param {Number} [cfg.divisions=1] Number of divisions on X and Z axis..\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildGridGeometry(cfg = {}) {\n\n    let size = cfg.size || 1;\n    if (size < 0) {\n        console.error(\"negative size not allowed - will invert\");\n        size *= -1;\n    }\n\n    let divisions = cfg.divisions || 1;\n    if (divisions < 0) {\n        console.error(\"negative divisions not allowed - will invert\");\n        divisions *= -1;\n    }\n    if (divisions < 1) {\n        divisions = 1;\n    }\n\n    size = size || 10;\n    divisions = divisions || 10;\n\n    const step = size / divisions;\n    const halfSize = size / 2;\n\n    const positions = [];\n    const indices = [];\n    let l = 0;\n\n    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {\n\n        positions.push(-halfSize);\n        positions.push(0);\n        positions.push(k);\n\n        positions.push(halfSize);\n        positions.push(0);\n        positions.push(k);\n\n        positions.push(k);\n        positions.push(0);\n        positions.push(-halfSize);\n\n        positions.push(k);\n        positions.push(0);\n        positions.push(halfSize);\n\n        indices.push(l++);\n        indices.push(l++);\n        indices.push(l++);\n        indices.push(l++);\n    }\n\n    return {\n        primitiveType: \"lines\",\n        positions: positions,\n        indices: indices\n    };\n}\n\n\nexport {buildGridGeometry};\n",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/geometryBuilders/buildGridGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 181,
    "kind": "function",
    "name": "buildGridGeometry",
    "memberof": "src/geometryBuilders/buildGridGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildGridGeometry.js~buildGridGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/geometryBuilders/buildGridGeometry.js",
    "importStyle": "{buildGridGeometry}",
    "description": "Creates grid-shaped geometry arrays..\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a grid-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildGridGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst grid = buildGridGeometry({\n     size: 1000,\n     divisions: 500\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"gridGeometry\",\n     primitiveType: grid.primitiveType, // Will be \"lines\"\n     positions: grid.positions,\n     indices: grid.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redGridMesh\",\n     geometryId: \"gridGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redGrid\",\n     meshIds: [\"redGridMesh\"]\n});\n\nxktModel.finalize();\n````",
    "lineNumber": 49,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildGridGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.size",
        "description": "Dimension on the X and Z-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.divisions",
        "description": "Number of divisions on X and Z axis.."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 182,
    "kind": "file",
    "name": "src/geometryBuilders/buildPlaneGeometry.js",
    "content": "/**\n * @desc Creates plane-shaped geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a plane-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildPlaneGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const plane = buildPlaneGeometry({\n *      center: [0,0,0],\n *      xSize: 2,\n *      zSize: 2,\n *      xSegments: 10,\n *      zSegments: 10\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"planeGeometry\",\n *      primitiveType: plane.primitiveType, // Will be \"triangles\"\n *      positions: plane.positions,\n *      normals: plane.normals,\n *      indices: plane.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redPlaneMesh\",\n *      geometryId: \"planeGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redPlane\",\n *      meshIds: [\"redPlaneMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildPlaneGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center]  3D point indicating the center position.\n * @param {Number} [cfg.xSize=1] Dimension on the X-axis.\n * @param {Number} [cfg.zSize=1] Dimension on the Z-axis.\n * @param {Number} [cfg.xSegments=1] Number of segments on the X-axis.\n * @param {Number} [cfg.zSegments=1] Number of segments on the Z-axis.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildPlaneGeometry(cfg = {}) {\n\n    let xSize = cfg.xSize || 1;\n    if (xSize < 0) {\n        console.error(\"negative xSize not allowed - will invert\");\n        xSize *= -1;\n    }\n\n    let zSize = cfg.zSize || 1;\n    if (zSize < 0) {\n        console.error(\"negative zSize not allowed - will invert\");\n        zSize *= -1;\n    }\n\n    let xSegments = cfg.xSegments || 1;\n    if (xSegments < 0) {\n        console.error(\"negative xSegments not allowed - will invert\");\n        xSegments *= -1;\n    }\n    if (xSegments < 1) {\n        xSegments = 1;\n    }\n\n    let zSegments = cfg.xSegments || 1;\n    if (zSegments < 0) {\n        console.error(\"negative zSegments not allowed - will invert\");\n        zSegments *= -1;\n    }\n    if (zSegments < 1) {\n        zSegments = 1;\n    }\n\n    const center = cfg.center;\n    const centerX = center ? center[0] : 0;\n    const centerY = center ? center[1] : 0;\n    const centerZ = center ? center[2] : 0;\n\n    const halfWidth = xSize / 2;\n    const halfHeight = zSize / 2;\n\n    const planeX = Math.floor(xSegments) || 1;\n    const planeZ = Math.floor(zSegments) || 1;\n\n    const planeX1 = planeX + 1;\n    const planeZ1 = planeZ + 1;\n\n    const segmentWidth = xSize / planeX;\n    const segmentHeight = zSize / planeZ;\n\n    const positions = new Float32Array(planeX1 * planeZ1 * 3);\n    const normals = new Float32Array(planeX1 * planeZ1 * 3);\n    const uvs = new Float32Array(planeX1 * planeZ1 * 2);\n\n    let offset = 0;\n    let offset2 = 0;\n\n    let iz;\n    let ix;\n    let x;\n    let a;\n    let b;\n    let c;\n    let d;\n\n    for (iz = 0; iz < planeZ1; iz++) {\n\n        const z = iz * segmentHeight - halfHeight;\n\n        for (ix = 0; ix < planeX1; ix++) {\n\n            x = ix * segmentWidth - halfWidth;\n\n            positions[offset] = x + centerX;\n            positions[offset + 1] = centerY;\n            positions[offset + 2] = -z + centerZ;\n\n            normals[offset + 2] = -1;\n\n            uvs[offset2] = (ix) / planeX;\n            uvs[offset2 + 1] = ((planeZ - iz) / planeZ);\n\n            offset += 3;\n            offset2 += 2;\n        }\n    }\n\n    offset = 0;\n\n    const indices = new ((positions.length / 3) > 65535 ? Uint32Array : Uint16Array)(planeX * planeZ * 6);\n\n    for (iz = 0; iz < planeZ; iz++) {\n\n        for (ix = 0; ix < planeX; ix++) {\n\n            a = ix + planeX1 * iz;\n            b = ix + planeX1 * (iz + 1);\n            c = (ix + 1) + planeX1 * (iz + 1);\n            d = (ix + 1) + planeX1 * iz;\n\n            indices[offset] = d;\n            indices[offset + 1] = b;\n            indices[offset + 2] = a;\n\n            indices[offset + 3] = d;\n            indices[offset + 4] = c;\n            indices[offset + 5] = b;\n\n            offset += 6;\n        }\n    }\n\n    return {\n        primitiveType: \"triangles\",\n        positions: positions,\n        normals: normals,\n        uv: uvs,\n        indices: indices\n    };\n}\n\nexport {buildPlaneGeometry};\n",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/geometryBuilders/buildPlaneGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 183,
    "kind": "function",
    "name": "buildPlaneGeometry",
    "memberof": "src/geometryBuilders/buildPlaneGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildPlaneGeometry.js~buildPlaneGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/geometryBuilders/buildPlaneGeometry.js",
    "importStyle": "{buildPlaneGeometry}",
    "description": "Creates plane-shaped geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a plane-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildPlaneGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst plane = buildPlaneGeometry({\n     center: [0,0,0],\n     xSize: 2,\n     zSize: 2,\n     xSegments: 10,\n     zSegments: 10\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"planeGeometry\",\n     primitiveType: plane.primitiveType, // Will be \"triangles\"\n     positions: plane.positions,\n     normals: plane.normals,\n     indices: plane.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redPlaneMesh\",\n     geometryId: \"planeGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redPlane\",\n     meshIds: [\"redPlaneMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 56,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildPlaneGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.xSize",
        "description": "Dimension on the X-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.zSize",
        "description": "Dimension on the Z-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.xSegments",
        "description": "Number of segments on the X-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.zSegments",
        "description": "Number of segments on the Z-axis."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 184,
    "kind": "file",
    "name": "src/geometryBuilders/buildSphereGeometry.js",
    "content": "/**\n * @desc Creates sphere-shaped geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a sphere-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildSphereGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const sphere = buildSphereGeometry({\n *      center: [0,0,0],\n *      radius: 1.5,\n *      heightSegments: 60,\n *      widthSegments: 60\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"sphereGeometry\",\n *      primitiveType: sphere.primitiveType, // Will be \"triangles\"\n *      positions: sphere.positions,\n *      normals: sphere.normals,\n *      indices: sphere.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redSphereMesh\",\n *      geometryId: \"sphereGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n *const xktEntity = xktModel.createEntity({\n *      entityId: \"redSphere\",\n *      meshIds: [\"redSphereMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildSphereGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center]  3D point indicating the center position.\n * @param {Number} [cfg.radius=1]  Radius.\n * @param {Number} [cfg.heightSegments=24] Number of latitudinal bands.\n * @param  {Number} [cfg.widthSegments=18] Number of longitudinal bands.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildSphereGeometry(cfg = {}) {\n\n    const lod = cfg.lod || 1;\n\n    const centerX = cfg.center ? cfg.center[0] : 0;\n    const centerY = cfg.center ? cfg.center[1] : 0;\n    const centerZ = cfg.center ? cfg.center[2] : 0;\n\n    let radius = cfg.radius || 1;\n    if (radius < 0) {\n        console.error(\"negative radius not allowed - will invert\");\n        radius *= -1;\n    }\n\n    let heightSegments = cfg.heightSegments || 18;\n    if (heightSegments < 0) {\n        console.error(\"negative heightSegments not allowed - will invert\");\n        heightSegments *= -1;\n    }\n    heightSegments = Math.floor(lod * heightSegments);\n    if (heightSegments < 18) {\n        heightSegments = 18;\n    }\n\n    let widthSegments = cfg.widthSegments || 18;\n    if (widthSegments < 0) {\n        console.error(\"negative widthSegments not allowed - will invert\");\n        widthSegments *= -1;\n    }\n    widthSegments = Math.floor(lod * widthSegments);\n    if (widthSegments < 18) {\n        widthSegments = 18;\n    }\n\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n\n    let i;\n    let j;\n\n    let theta;\n    let sinTheta;\n    let cosTheta;\n\n    let phi;\n    let sinPhi;\n    let cosPhi;\n\n    let x;\n    let y;\n    let z;\n\n    let u;\n    let v;\n\n    let first;\n    let second;\n\n    for (i = 0; i <= heightSegments; i++) {\n\n        theta = i * Math.PI / heightSegments;\n        sinTheta = Math.sin(theta);\n        cosTheta = Math.cos(theta);\n\n        for (j = 0; j <= widthSegments; j++) {\n\n            phi = j * 2 * Math.PI / widthSegments;\n            sinPhi = Math.sin(phi);\n            cosPhi = Math.cos(phi);\n\n            x = cosPhi * sinTheta;\n            y = cosTheta;\n            z = sinPhi * sinTheta;\n            u = 1.0 - j / widthSegments;\n            v = i / heightSegments;\n\n            normals.push(x);\n            normals.push(y);\n            normals.push(z);\n\n            uvs.push(u);\n            uvs.push(v);\n\n            positions.push(centerX + radius * x);\n            positions.push(centerY + radius * y);\n            positions.push(centerZ + radius * z);\n        }\n    }\n\n    for (i = 0; i < heightSegments; i++) {\n        for (j = 0; j < widthSegments; j++) {\n\n            first = (i * (widthSegments + 1)) + j;\n            second = first + widthSegments + 1;\n\n            indices.push(first + 1);\n            indices.push(second + 1);\n            indices.push(second);\n            indices.push(first + 1);\n            indices.push(second);\n            indices.push(first);\n        }\n    }\n\n    return {\n        primitiveType: \"triangles\",\n        positions: positions,\n        normals: normals,\n        uv: uvs,\n        indices: indices\n    };\n}\n\nexport {buildSphereGeometry};\n",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/geometryBuilders/buildSphereGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 185,
    "kind": "function",
    "name": "buildSphereGeometry",
    "memberof": "src/geometryBuilders/buildSphereGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildSphereGeometry.js~buildSphereGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/geometryBuilders/buildSphereGeometry.js",
    "importStyle": "{buildSphereGeometry}",
    "description": "Creates sphere-shaped geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a sphere-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildSphereGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst sphere = buildSphereGeometry({\n     center: [0,0,0],\n     radius: 1.5,\n     heightSegments: 60,\n     widthSegments: 60\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"sphereGeometry\",\n     primitiveType: sphere.primitiveType, // Will be \"triangles\"\n     positions: sphere.positions,\n     normals: sphere.normals,\n     indices: sphere.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redSphereMesh\",\n     geometryId: \"sphereGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redSphere\",\n     meshIds: [\"redSphereMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildSphereGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.radius",
        "description": "Radius."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "24",
        "defaultRaw": 24,
        "name": "cfg.heightSegments",
        "description": "Number of latitudinal bands."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "18",
        "defaultRaw": 18,
        "name": "cfg.widthSegments",
        "description": "Number of longitudinal bands."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 186,
    "kind": "file",
    "name": "src/geometryBuilders/buildTorusGeometry.js",
    "content": "import {math} from '../lib/math.js';\n\n/**\n * @desc Creates torus-shaped geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a torus-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildTorusGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const torus = buildTorusGeometry({\n *      center: [0,0,0],\n *      radius: 1.0,\n *      tube: 0.5,\n *      radialSegments: 32,\n *      tubeSegments: 24,\n *      arc: Math.PI * 2.0\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"torusGeometry\",\n *      primitiveType: torus.primitiveType, // Will be \"triangles\"\n *      positions: torus.positions,\n *      normals: torus.normals,\n *      indices: torus.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redTorusMesh\",\n *      geometryId: \"torusGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redTorus\",\n *      meshIds: [\"redTorusMesh\"]\n * });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildTorusGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center] 3D point indicating the center position.\n * @param {Number} [cfg.radius=1] The overall radius.\n * @param {Number} [cfg.tube=0.3] The tube radius.\n * @param {Number} [cfg.radialSegments=32] The number of radial segments.\n * @param {Number} [cfg.tubeSegments=24] The number of tubular segments.\n * @param {Number} [cfg.arc=Math.PI*0.5] The length of the arc in radians, where Math.PI*2 is a closed torus.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildTorusGeometry(cfg = {}) {\n\n    let radius = cfg.radius || 1;\n    if (radius < 0) {\n        console.error(\"negative radius not allowed - will invert\");\n        radius *= -1;\n    }\n    radius *= 0.5;\n\n    let tube = cfg.tube || 0.3;\n    if (tube < 0) {\n        console.error(\"negative tube not allowed - will invert\");\n        tube *= -1;\n    }\n\n    let radialSegments = cfg.radialSegments || 32;\n    if (radialSegments < 0) {\n        console.error(\"negative radialSegments not allowed - will invert\");\n        radialSegments *= -1;\n    }\n    if (radialSegments < 4) {\n        radialSegments = 4;\n    }\n\n    let tubeSegments = cfg.tubeSegments || 24;\n    if (tubeSegments < 0) {\n        console.error(\"negative tubeSegments not allowed - will invert\");\n        tubeSegments *= -1;\n    }\n    if (tubeSegments < 4) {\n        tubeSegments = 4;\n    }\n\n    let arc = cfg.arc || Math.PI * 2;\n    if (arc < 0) {\n        console.warn(\"negative arc not allowed - will invert\");\n        arc *= -1;\n    }\n    if (arc > 360) {\n        arc = 360;\n    }\n\n    const center = cfg.center;\n    let centerX = center ? center[0] : 0;\n    let centerY = center ? center[1] : 0;\n    const centerZ = center ? center[2] : 0;\n\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n\n    let u;\n    let v;\n    let x;\n    let y;\n    let z;\n    let vec;\n\n    let i;\n    let j;\n\n    for (j = 0; j <= tubeSegments; j++) {\n        for (i = 0; i <= radialSegments; i++) {\n\n            u = i / radialSegments * arc;\n            v = 0.785398 + (j / tubeSegments * Math.PI * 2);\n\n            centerX = radius * Math.cos(u);\n            centerY = radius * Math.sin(u);\n\n            x = (radius + tube * Math.cos(v)) * Math.cos(u);\n            y = (radius + tube * Math.cos(v)) * Math.sin(u);\n            z = tube * Math.sin(v);\n\n            positions.push(x + centerX);\n            positions.push(y + centerY);\n            positions.push(z + centerZ);\n\n            uvs.push(1 - (i / radialSegments));\n            uvs.push((j / tubeSegments));\n\n            vec = math.normalizeVec3(math.subVec3([x, y, z], [centerX, centerY, centerZ], []), []);\n\n            normals.push(vec[0]);\n            normals.push(vec[1]);\n            normals.push(vec[2]);\n        }\n    }\n\n    let a;\n    let b;\n    let c;\n    let d;\n\n    for (j = 1; j <= tubeSegments; j++) {\n        for (i = 1; i <= radialSegments; i++) {\n\n            a = (radialSegments + 1) * j + i - 1;\n            b = (radialSegments + 1) * (j - 1) + i - 1;\n            c = (radialSegments + 1) * (j - 1) + i;\n            d = (radialSegments + 1) * j + i;\n\n            indices.push(a);\n            indices.push(b);\n            indices.push(c);\n\n            indices.push(c);\n            indices.push(d);\n            indices.push(a);\n        }\n    }\n\n    return {\n        primitiveType: \"triangles\",\n        positions: positions,\n        normals: normals,\n        uv: uvs,\n        indices: indices\n    };\n}\n\nexport {buildTorusGeometry};\n",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/geometryBuilders/buildTorusGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 187,
    "kind": "function",
    "name": "buildTorusGeometry",
    "memberof": "src/geometryBuilders/buildTorusGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildTorusGeometry.js~buildTorusGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/geometryBuilders/buildTorusGeometry.js",
    "importStyle": "{buildTorusGeometry}",
    "description": "Creates torus-shaped geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a torus-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildTorusGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst torus = buildTorusGeometry({\n     center: [0,0,0],\n     radius: 1.0,\n     tube: 0.5,\n     radialSegments: 32,\n     tubeSegments: 24,\n     arc: Math.PI * 2.0\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"torusGeometry\",\n     primitiveType: torus.primitiveType, // Will be \"triangles\"\n     positions: torus.positions,\n     normals: torus.normals,\n     indices: torus.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redTorusMesh\",\n     geometryId: \"torusGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redTorus\",\n     meshIds: [\"redTorusMesh\"]\n});\n\nxktModel.finalize();\n````",
    "lineNumber": 60,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildTorusGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.radius",
        "description": "The overall radius."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0.3",
        "defaultRaw": 0.3,
        "name": "cfg.tube",
        "description": "The tube radius."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "32",
        "defaultRaw": 32,
        "name": "cfg.radialSegments",
        "description": "The number of radial segments."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "24",
        "defaultRaw": 24,
        "name": "cfg.tubeSegments",
        "description": "The number of tubular segments."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Math.PI*0.5",
        "defaultRaw": "Math.PI*0.5",
        "name": "cfg.arc",
        "description": "The length of the arc in radians, where Math.PI*2 is a closed torus."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 188,
    "kind": "file",
    "name": "src/geometryBuilders/buildVectorTextGeometry.js",
    "content": "const letters = {\n    ' ': {width: 16, points: []},\n    '!': {\n        width: 10, points: [\n            [5, 21],\n            [5, 7],\n            [-1, -1],\n            [5, 2],\n            [4, 1],\n            [5, 0],\n            [6, 1],\n            [5, 2]\n        ]\n    },\n    '\"': {\n        width: 16, points: [\n            [4, 21],\n            [4, 14],\n            [-1, -1],\n            [12, 21],\n            [12, 14]\n        ]\n    },\n    '#': {\n        width: 21, points: [\n            [11, 25],\n            [4, -7],\n            [-1, -1],\n            [17, 25],\n            [10, -7],\n            [-1, -1],\n            [4, 12],\n            [18, 12],\n            [-1, -1],\n            [3, 6],\n            [17, 6]\n        ]\n    },\n    '$': {\n        width: 20, points: [\n            [8, 25],\n            [8, -4],\n            [-1, -1],\n            [12, 25],\n            [12, -4],\n            [-1, -1],\n            [17, 18],\n            [15, 20],\n            [12, 21],\n            [8, 21],\n            [5, 20],\n            [3, 18],\n            [3, 16],\n            [4, 14],\n            [5, 13],\n            [7, 12],\n            [13, 10],\n            [15, 9],\n            [16, 8],\n            [17, 6],\n            [17, 3],\n            [15, 1],\n            [12, 0],\n            [8, 0],\n            [5, 1],\n            [3, 3]\n        ]\n    },\n    '%': {\n        width: 24, points: [\n            [21, 21],\n            [3, 0],\n            [-1, -1],\n            [8, 21],\n            [10, 19],\n            [10, 17],\n            [9, 15],\n            [7, 14],\n            [5, 14],\n            [3, 16],\n            [3, 18],\n            [4, 20],\n            [6, 21],\n            [8, 21],\n            [10, 20],\n            [13, 19],\n            [16, 19],\n            [19, 20],\n            [21, 21],\n            [-1, -1],\n            [17, 7],\n            [15, 6],\n            [14, 4],\n            [14, 2],\n            [16, 0],\n            [18, 0],\n            [20, 1],\n            [21, 3],\n            [21, 5],\n            [19, 7],\n            [17, 7]\n        ]\n    },\n    '&': {\n        width: 26, points: [\n            [23, 12],\n            [23, 13],\n            [22, 14],\n            [21, 14],\n            [20, 13],\n            [19, 11],\n            [17, 6],\n            [15, 3],\n            [13, 1],\n            [11, 0],\n            [7, 0],\n            [5, 1],\n            [4, 2],\n            [3, 4],\n            [3, 6],\n            [4, 8],\n            [5, 9],\n            [12, 13],\n            [13, 14],\n            [14, 16],\n            [14, 18],\n            [13, 20],\n            [11, 21],\n            [9, 20],\n            [8, 18],\n            [8, 16],\n            [9, 13],\n            [11, 10],\n            [16, 3],\n            [18, 1],\n            [20, 0],\n            [22, 0],\n            [23, 1],\n            [23, 2]\n        ]\n    },\n    '\\'': {\n        width: 10, points: [\n            [5, 19],\n            [4, 20],\n            [5, 21],\n            [6, 20],\n            [6, 18],\n            [5, 16],\n            [4, 15]\n        ]\n    },\n    '(': {\n        width: 14, points: [\n            [11, 25],\n            [9, 23],\n            [7, 20],\n            [5, 16],\n            [4, 11],\n            [4, 7],\n            [5, 2],\n            [7, -2],\n            [9, -5],\n            [11, -7]\n        ]\n    },\n    ')': {\n        width: 14, points: [\n            [3, 25],\n            [5, 23],\n            [7, 20],\n            [9, 16],\n            [10, 11],\n            [10, 7],\n            [9, 2],\n            [7, -2],\n            [5, -5],\n            [3, -7]\n        ]\n    },\n    '*': {\n        width: 16, points: [\n            [8, 21],\n            [8, 9],\n            [-1, -1],\n            [3, 18],\n            [13, 12],\n            [-1, -1],\n            [13, 18],\n            [3, 12]\n        ]\n    },\n    '+': {\n        width: 26, points: [\n            [13, 18],\n            [13, 0],\n            [-1, -1],\n            [4, 9],\n            [22, 9]\n        ]\n    },\n    ',': {\n        width: 10, points: [\n            [6, 1],\n            [5, 0],\n            [4, 1],\n            [5, 2],\n            [6, 1],\n            [6, -1],\n            [5, -3],\n            [4, -4]\n        ]\n    },\n    '-': {\n        width: 26, points: [\n            [4, 9],\n            [22, 9]\n        ]\n    },\n    '.': {\n        width: 10, points: [\n            [5, 2],\n            [4, 1],\n            [5, 0],\n            [6, 1],\n            [5, 2]\n        ]\n    },\n    '/': {\n        width: 22, points: [\n            [20, 25],\n            [2, -7]\n        ]\n    },\n    '0': {\n        width: 20, points: [\n            [9, 21],\n            [6, 20],\n            [4, 17],\n            [3, 12],\n            [3, 9],\n            [4, 4],\n            [6, 1],\n            [9, 0],\n            [11, 0],\n            [14, 1],\n            [16, 4],\n            [17, 9],\n            [17, 12],\n            [16, 17],\n            [14, 20],\n            [11, 21],\n            [9, 21]\n        ]\n    },\n    '1': {\n        width: 20, points: [\n            [6, 17],\n            [8, 18],\n            [11, 21],\n            [11, 0]\n        ]\n    },\n    '2': {\n        width: 20, points: [\n            [4, 16],\n            [4, 17],\n            [5, 19],\n            [6, 20],\n            [8, 21],\n            [12, 21],\n            [14, 20],\n            [15, 19],\n            [16, 17],\n            [16, 15],\n            [15, 13],\n            [13, 10],\n            [3, 0],\n            [17, 0]\n        ]\n    },\n    '3': {\n        width: 20, points: [\n            [5, 21],\n            [16, 21],\n            [10, 13],\n            [13, 13],\n            [15, 12],\n            [16, 11],\n            [17, 8],\n            [17, 6],\n            [16, 3],\n            [14, 1],\n            [11, 0],\n            [8, 0],\n            [5, 1],\n            [4, 2],\n            [3, 4]\n        ]\n    },\n    '4': {\n        width: 20, points: [\n            [13, 21],\n            [3, 7],\n            [18, 7],\n            [-1, -1],\n            [13, 21],\n            [13, 0]\n        ]\n    },\n    '5': {\n        width: 20, points: [\n            [15, 21],\n            [5, 21],\n            [4, 12],\n            [5, 13],\n            [8, 14],\n            [11, 14],\n            [14, 13],\n            [16, 11],\n            [17, 8],\n            [17, 6],\n            [16, 3],\n            [14, 1],\n            [11, 0],\n            [8, 0],\n            [5, 1],\n            [4, 2],\n            [3, 4]\n        ]\n    },\n    '6': {\n        width: 20, points: [\n            [16, 18],\n            [15, 20],\n            [12, 21],\n            [10, 21],\n            [7, 20],\n            [5, 17],\n            [4, 12],\n            [4, 7],\n            [5, 3],\n            [7, 1],\n            [10, 0],\n            [11, 0],\n            [14, 1],\n            [16, 3],\n            [17, 6],\n            [17, 7],\n            [16, 10],\n            [14, 12],\n            [11, 13],\n            [10, 13],\n            [7, 12],\n            [5, 10],\n            [4, 7]\n        ]\n    },\n    '7': {\n        width: 20, points: [\n            [17, 21],\n            [7, 0],\n            [-1, -1],\n            [3, 21],\n            [17, 21]\n        ]\n    },\n    '8': {\n        width: 20, points: [\n            [8, 21],\n            [5, 20],\n            [4, 18],\n            [4, 16],\n            [5, 14],\n            [7, 13],\n            [11, 12],\n            [14, 11],\n            [16, 9],\n            [17, 7],\n            [17, 4],\n            [16, 2],\n            [15, 1],\n            [12, 0],\n            [8, 0],\n            [5, 1],\n            [4, 2],\n            [3, 4],\n            [3, 7],\n            [4, 9],\n            [6, 11],\n            [9, 12],\n            [13, 13],\n            [15, 14],\n            [16, 16],\n            [16, 18],\n            [15, 20],\n            [12, 21],\n            [8, 21]\n        ]\n    },\n    '9': {\n        width: 20, points: [\n            [16, 14],\n            [15, 11],\n            [13, 9],\n            [10, 8],\n            [9, 8],\n            [6, 9],\n            [4, 11],\n            [3, 14],\n            [3, 15],\n            [4, 18],\n            [6, 20],\n            [9, 21],\n            [10, 21],\n            [13, 20],\n            [15, 18],\n            [16, 14],\n            [16, 9],\n            [15, 4],\n            [13, 1],\n            [10, 0],\n            [8, 0],\n            [5, 1],\n            [4, 3]\n        ]\n    },\n    ':': {\n        width: 10, points: [\n            [5, 14],\n            [4, 13],\n            [5, 12],\n            [6, 13],\n            [5, 14],\n            [-1, -1],\n            [5, 2],\n            [4, 1],\n            [5, 0],\n            [6, 1],\n            [5, 2]\n        ]\n    },\n    ';': {\n        width: 10, points: [\n            [5, 14],\n            [4, 13],\n            [5, 12],\n            [6, 13],\n            [5, 14],\n            [-1, -1],\n            [6, 1],\n            [5, 0],\n            [4, 1],\n            [5, 2],\n            [6, 1],\n            [6, -1],\n            [5, -3],\n            [4, -4]\n        ]\n    },\n    '<': {\n        width: 24, points: [\n            [20, 18],\n            [4, 9],\n            [20, 0]\n        ]\n    },\n    '=': {\n        width: 26, points: [\n            [4, 12],\n            [22, 12],\n            [-1, -1],\n            [4, 6],\n            [22, 6]\n        ]\n    },\n    '>': {\n        width: 24, points: [\n            [4, 18],\n            [20, 9],\n            [4, 0]\n        ]\n    },\n    '?': {\n        width: 18, points: [\n            [3, 16],\n            [3, 17],\n            [4, 19],\n            [5, 20],\n            [7, 21],\n            [11, 21],\n            [13, 20],\n            [14, 19],\n            [15, 17],\n            [15, 15],\n            [14, 13],\n            [13, 12],\n            [9, 10],\n            [9, 7],\n            [-1, -1],\n            [9, 2],\n            [8, 1],\n            [9, 0],\n            [10, 1],\n            [9, 2]\n        ]\n    },\n    '@': {\n        width: 27, points: [\n            [18, 13],\n            [17, 15],\n            [15, 16],\n            [12, 16],\n            [10, 15],\n            [9, 14],\n            [8, 11],\n            [8, 8],\n            [9, 6],\n            [11, 5],\n            [14, 5],\n            [16, 6],\n            [17, 8],\n            [-1, -1],\n            [12, 16],\n            [10, 14],\n            [9, 11],\n            [9, 8],\n            [10, 6],\n            [11, 5],\n            [-1, -1],\n            [18, 16],\n            [17, 8],\n            [17, 6],\n            [19, 5],\n            [21, 5],\n            [23, 7],\n            [24, 10],\n            [24, 12],\n            [23, 15],\n            [22, 17],\n            [20, 19],\n            [18, 20],\n            [15, 21],\n            [12, 21],\n            [9, 20],\n            [7, 19],\n            [5, 17],\n            [4, 15],\n            [3, 12],\n            [3, 9],\n            [4, 6],\n            [5, 4],\n            [7, 2],\n            [9, 1],\n            [12, 0],\n            [15, 0],\n            [18, 1],\n            [20, 2],\n            [21, 3],\n            [-1, -1],\n            [19, 16],\n            [18, 8],\n            [18, 6],\n            [19, 5]\n        ]\n    },\n    'A': {\n        width: 18, points: [\n            [9, 21],\n            [1, 0],\n            [-1, -1],\n            [9, 21],\n            [17, 0],\n            [-1, -1],\n            [4, 7],\n            [14, 7]\n        ]\n    },\n    'B': {\n        width: 21, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [13, 21],\n            [16, 20],\n            [17, 19],\n            [18, 17],\n            [18, 15],\n            [17, 13],\n            [16, 12],\n            [13, 11],\n            [-1, -1],\n            [4, 11],\n            [13, 11],\n            [16, 10],\n            [17, 9],\n            [18, 7],\n            [18, 4],\n            [17, 2],\n            [16, 1],\n            [13, 0],\n            [4, 0]\n        ]\n    },\n    'C': {\n        width: 21, points: [\n            [18, 16],\n            [17, 18],\n            [15, 20],\n            [13, 21],\n            [9, 21],\n            [7, 20],\n            [5, 18],\n            [4, 16],\n            [3, 13],\n            [3, 8],\n            [4, 5],\n            [5, 3],\n            [7, 1],\n            [9, 0],\n            [13, 0],\n            [15, 1],\n            [17, 3],\n            [18, 5]\n        ]\n    },\n    'D': {\n        width: 21, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [11, 21],\n            [14, 20],\n            [16, 18],\n            [17, 16],\n            [18, 13],\n            [18, 8],\n            [17, 5],\n            [16, 3],\n            [14, 1],\n            [11, 0],\n            [4, 0]\n        ]\n    },\n    'E': {\n        width: 19, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [17, 21],\n            [-1, -1],\n            [4, 11],\n            [12, 11],\n            [-1, -1],\n            [4, 0],\n            [17, 0]\n        ]\n    },\n    'F': {\n        width: 18, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [17, 21],\n            [-1, -1],\n            [4, 11],\n            [12, 11]\n        ]\n    },\n    'G': {\n        width: 21, points: [\n            [18, 16],\n            [17, 18],\n            [15, 20],\n            [13, 21],\n            [9, 21],\n            [7, 20],\n            [5, 18],\n            [4, 16],\n            [3, 13],\n            [3, 8],\n            [4, 5],\n            [5, 3],\n            [7, 1],\n            [9, 0],\n            [13, 0],\n            [15, 1],\n            [17, 3],\n            [18, 5],\n            [18, 8],\n            [-1, -1],\n            [13, 8],\n            [18, 8]\n        ]\n    },\n    'H': {\n        width: 22, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [18, 21],\n            [18, 0],\n            [-1, -1],\n            [4, 11],\n            [18, 11]\n        ]\n    },\n    'I': {\n        width: 8, points: [\n            [4, 21],\n            [4, 0]\n        ]\n    },\n    'J': {\n        width: 16, points: [\n            [12, 21],\n            [12, 5],\n            [11, 2],\n            [10, 1],\n            [8, 0],\n            [6, 0],\n            [4, 1],\n            [3, 2],\n            [2, 5],\n            [2, 7]\n        ]\n    },\n    'K': {\n        width: 21, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [18, 21],\n            [4, 7],\n            [-1, -1],\n            [9, 12],\n            [18, 0]\n        ]\n    },\n    'L': {\n        width: 17, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 0],\n            [16, 0]\n        ]\n    },\n    'M': {\n        width: 24, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [12, 0],\n            [-1, -1],\n            [20, 21],\n            [12, 0],\n            [-1, -1],\n            [20, 21],\n            [20, 0]\n        ]\n    },\n    'N': {\n        width: 22, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [18, 0],\n            [-1, -1],\n            [18, 21],\n            [18, 0]\n        ]\n    },\n    'O': {\n        width: 22, points: [\n            [9, 21],\n            [7, 20],\n            [5, 18],\n            [4, 16],\n            [3, 13],\n            [3, 8],\n            [4, 5],\n            [5, 3],\n            [7, 1],\n            [9, 0],\n            [13, 0],\n            [15, 1],\n            [17, 3],\n            [18, 5],\n            [19, 8],\n            [19, 13],\n            [18, 16],\n            [17, 18],\n            [15, 20],\n            [13, 21],\n            [9, 21]\n        ]\n    },\n    'P': {\n        width: 21, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [13, 21],\n            [16, 20],\n            [17, 19],\n            [18, 17],\n            [18, 14],\n            [17, 12],\n            [16, 11],\n            [13, 10],\n            [4, 10]\n        ]\n    },\n    'Q': {\n        width: 22, points: [\n            [9, 21],\n            [7, 20],\n            [5, 18],\n            [4, 16],\n            [3, 13],\n            [3, 8],\n            [4, 5],\n            [5, 3],\n            [7, 1],\n            [9, 0],\n            [13, 0],\n            [15, 1],\n            [17, 3],\n            [18, 5],\n            [19, 8],\n            [19, 13],\n            [18, 16],\n            [17, 18],\n            [15, 20],\n            [13, 21],\n            [9, 21],\n            [-1, -1],\n            [12, 4],\n            [18, -2]\n        ]\n    },\n    'R': {\n        width: 21, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [13, 21],\n            [16, 20],\n            [17, 19],\n            [18, 17],\n            [18, 15],\n            [17, 13],\n            [16, 12],\n            [13, 11],\n            [4, 11],\n            [-1, -1],\n            [11, 11],\n            [18, 0]\n        ]\n    },\n    'S': {\n        width: 20, points: [\n            [17, 18],\n            [15, 20],\n            [12, 21],\n            [8, 21],\n            [5, 20],\n            [3, 18],\n            [3, 16],\n            [4, 14],\n            [5, 13],\n            [7, 12],\n            [13, 10],\n            [15, 9],\n            [16, 8],\n            [17, 6],\n            [17, 3],\n            [15, 1],\n            [12, 0],\n            [8, 0],\n            [5, 1],\n            [3, 3]\n        ]\n    },\n    'T': {\n        width: 16, points: [\n            [8, 21],\n            [8, 0],\n            [-1, -1],\n            [1, 21],\n            [15, 21]\n        ]\n    },\n    'U': {\n        width: 22, points: [\n            [4, 21],\n            [4, 6],\n            [5, 3],\n            [7, 1],\n            [10, 0],\n            [12, 0],\n            [15, 1],\n            [17, 3],\n            [18, 6],\n            [18, 21]\n        ]\n    },\n    'V': {\n        width: 18, points: [\n            [1, 21],\n            [9, 0],\n            [-1, -1],\n            [17, 21],\n            [9, 0]\n        ]\n    },\n    'W': {\n        width: 24, points: [\n            [2, 21],\n            [7, 0],\n            [-1, -1],\n            [12, 21],\n            [7, 0],\n            [-1, -1],\n            [12, 21],\n            [17, 0],\n            [-1, -1],\n            [22, 21],\n            [17, 0]\n        ]\n    },\n    'X': {\n        width: 20, points: [\n            [3, 21],\n            [17, 0],\n            [-1, -1],\n            [17, 21],\n            [3, 0]\n        ]\n    },\n    'Y': {\n        width: 18, points: [\n            [1, 21],\n            [9, 11],\n            [9, 0],\n            [-1, -1],\n            [17, 21],\n            [9, 11]\n        ]\n    },\n    'Z': {\n        width: 20, points: [\n            [17, 21],\n            [3, 0],\n            [-1, -1],\n            [3, 21],\n            [17, 21],\n            [-1, -1],\n            [3, 0],\n            [17, 0]\n        ]\n    },\n    '[': {\n        width: 14, points: [\n            [4, 25],\n            [4, -7],\n            [-1, -1],\n            [5, 25],\n            [5, -7],\n            [-1, -1],\n            [4, 25],\n            [11, 25],\n            [-1, -1],\n            [4, -7],\n            [11, -7]\n        ]\n    },\n    '\\\\': {\n        width: 14, points: [\n            [0, 21],\n            [14, -3]\n        ]\n    },\n    ']': {\n        width: 14, points: [\n            [9, 25],\n            [9, -7],\n            [-1, -1],\n            [10, 25],\n            [10, -7],\n            [-1, -1],\n            [3, 25],\n            [10, 25],\n            [-1, -1],\n            [3, -7],\n            [10, -7]\n        ]\n    },\n    '^': {\n        width: 16, points: [\n            [6, 15],\n            [8, 18],\n            [10, 15],\n            [-1, -1],\n            [3, 12],\n            [8, 17],\n            [13, 12],\n            [-1, -1],\n            [8, 17],\n            [8, 0]\n        ]\n    },\n    '_': {\n        width: 16, points: [\n            [0, -2],\n            [16, -2]\n        ]\n    },\n    '`': {\n        width: 10, points: [\n            [6, 21],\n            [5, 20],\n            [4, 18],\n            [4, 16],\n            [5, 15],\n            [6, 16],\n            [5, 17]\n        ]\n    },\n    'a': {\n        width: 19, points: [\n            [15, 14],\n            [15, 0],\n            [-1, -1],\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'b': {\n        width: 19, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 11],\n            [6, 13],\n            [8, 14],\n            [11, 14],\n            [13, 13],\n            [15, 11],\n            [16, 8],\n            [16, 6],\n            [15, 3],\n            [13, 1],\n            [11, 0],\n            [8, 0],\n            [6, 1],\n            [4, 3]\n        ]\n    },\n    'c': {\n        width: 18, points: [\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'd': {\n        width: 19, points: [\n            [15, 21],\n            [15, 0],\n            [-1, -1],\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'e': {\n        width: 18, points: [\n            [3, 8],\n            [15, 8],\n            [15, 10],\n            [14, 12],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'f': {\n        width: 12, points: [\n            [10, 21],\n            [8, 21],\n            [6, 20],\n            [5, 17],\n            [5, 0],\n            [-1, -1],\n            [2, 14],\n            [9, 14]\n        ]\n    },\n    'g': {\n        width: 19, points: [\n            [15, 14],\n            [15, -2],\n            [14, -5],\n            [13, -6],\n            [11, -7],\n            [8, -7],\n            [6, -6],\n            [-1, -1],\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'h': {\n        width: 19, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 10],\n            [7, 13],\n            [9, 14],\n            [12, 14],\n            [14, 13],\n            [15, 10],\n            [15, 0]\n        ]\n    },\n    'i': {\n        width: 8, points: [\n            [3, 21],\n            [4, 20],\n            [5, 21],\n            [4, 22],\n            [3, 21],\n            [-1, -1],\n            [4, 14],\n            [4, 0]\n        ]\n    },\n    'j': {\n        width: 10, points: [\n            [5, 21],\n            [6, 20],\n            [7, 21],\n            [6, 22],\n            [5, 21],\n            [-1, -1],\n            [6, 14],\n            [6, -3],\n            [5, -6],\n            [3, -7],\n            [1, -7]\n        ]\n    },\n    'k': {\n        width: 17, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [14, 14],\n            [4, 4],\n            [-1, -1],\n            [8, 8],\n            [15, 0]\n        ]\n    },\n    'l': {\n        width: 8, points: [\n            [4, 21],\n            [4, 0]\n        ]\n    },\n    'm': {\n        width: 30, points: [\n            [4, 14],\n            [4, 0],\n            [-1, -1],\n            [4, 10],\n            [7, 13],\n            [9, 14],\n            [12, 14],\n            [14, 13],\n            [15, 10],\n            [15, 0],\n            [-1, -1],\n            [15, 10],\n            [18, 13],\n            [20, 14],\n            [23, 14],\n            [25, 13],\n            [26, 10],\n            [26, 0]\n        ]\n    },\n    'n': {\n        width: 19, points: [\n            [4, 14],\n            [4, 0],\n            [-1, -1],\n            [4, 10],\n            [7, 13],\n            [9, 14],\n            [12, 14],\n            [14, 13],\n            [15, 10],\n            [15, 0]\n        ]\n    },\n    'o': {\n        width: 19, points: [\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3],\n            [16, 6],\n            [16, 8],\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14]\n        ]\n    },\n    'p': {\n        width: 19, points: [\n            [4, 14],\n            [4, -7],\n            [-1, -1],\n            [4, 11],\n            [6, 13],\n            [8, 14],\n            [11, 14],\n            [13, 13],\n            [15, 11],\n            [16, 8],\n            [16, 6],\n            [15, 3],\n            [13, 1],\n            [11, 0],\n            [8, 0],\n            [6, 1],\n            [4, 3]\n        ]\n    },\n    'q': {\n        width: 19, points: [\n            [15, 14],\n            [15, -7],\n            [-1, -1],\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'r': {\n        width: 13, points: [\n            [4, 14],\n            [4, 0],\n            [-1, -1],\n            [4, 8],\n            [5, 11],\n            [7, 13],\n            [9, 14],\n            [12, 14]\n        ]\n    },\n    's': {\n        width: 17, points: [\n            [14, 11],\n            [13, 13],\n            [10, 14],\n            [7, 14],\n            [4, 13],\n            [3, 11],\n            [4, 9],\n            [6, 8],\n            [11, 7],\n            [13, 6],\n            [14, 4],\n            [14, 3],\n            [13, 1],\n            [10, 0],\n            [7, 0],\n            [4, 1],\n            [3, 3]\n        ]\n    },\n    't': {\n        width: 12, points: [\n            [5, 21],\n            [5, 4],\n            [6, 1],\n            [8, 0],\n            [10, 0],\n            [-1, -1],\n            [2, 14],\n            [9, 14]\n        ]\n    },\n    'u': {\n        width: 19, points: [\n            [4, 14],\n            [4, 4],\n            [5, 1],\n            [7, 0],\n            [10, 0],\n            [12, 1],\n            [15, 4],\n            [-1, -1],\n            [15, 14],\n            [15, 0]\n        ]\n    },\n    'v': {\n        width: 16, points: [\n            [2, 14],\n            [8, 0],\n            [-1, -1],\n            [14, 14],\n            [8, 0]\n        ]\n    },\n    'w': {\n        width: 22, points: [\n            [3, 14],\n            [7, 0],\n            [-1, -1],\n            [11, 14],\n            [7, 0],\n            [-1, -1],\n            [11, 14],\n            [15, 0],\n            [-1, -1],\n            [19, 14],\n            [15, 0]\n        ]\n    },\n    'x': {\n        width: 17, points: [\n            [3, 14],\n            [14, 0],\n            [-1, -1],\n            [14, 14],\n            [3, 0]\n        ]\n    },\n    'y': {\n        width: 16, points: [\n            [2, 14],\n            [8, 0],\n            [-1, -1],\n            [14, 14],\n            [8, 0],\n            [6, -4],\n            [4, -6],\n            [2, -7],\n            [1, -7]\n        ]\n    },\n    'z': {\n        width: 17, points: [\n            [14, 14],\n            [3, 0],\n            [-1, -1],\n            [3, 14],\n            [14, 14],\n            [-1, -1],\n            [3, 0],\n            [14, 0]\n        ]\n    },\n    '{': {\n        width: 14, points: [\n            [9, 25],\n            [7, 24],\n            [6, 23],\n            [5, 21],\n            [5, 19],\n            [6, 17],\n            [7, 16],\n            [8, 14],\n            [8, 12],\n            [6, 10],\n            [-1, -1],\n            [7, 24],\n            [6, 22],\n            [6, 20],\n            [7, 18],\n            [8, 17],\n            [9, 15],\n            [9, 13],\n            [8, 11],\n            [4, 9],\n            [8, 7],\n            [9, 5],\n            [9, 3],\n            [8, 1],\n            [7, 0],\n            [6, -2],\n            [6, -4],\n            [7, -6],\n            [-1, -1],\n            [6, 8],\n            [8, 6],\n            [8, 4],\n            [7, 2],\n            [6, 1],\n            [5, -1],\n            [5, -3],\n            [6, -5],\n            [7, -6],\n            [9, -7]\n        ]\n    },\n    '|': {\n        width: 8, points: [\n            [4, 25],\n            [4, -7]\n        ]\n    },\n    '}': {\n        width: 14, points: [\n            [5, 25],\n            [7, 24],\n            [8, 23],\n            [9, 21],\n            [9, 19],\n            [8, 17],\n            [7, 16],\n            [6, 14],\n            [6, 12],\n            [8, 10],\n            [-1, -1],\n            [7, 24],\n            [8, 22],\n            [8, 20],\n            [7, 18],\n            [6, 17],\n            [5, 15],\n            [5, 13],\n            [6, 11],\n            [10, 9],\n            [6, 7],\n            [5, 5],\n            [5, 3],\n            [6, 1],\n            [7, 0],\n            [8, -2],\n            [8, -4],\n            [7, -6],\n            [-1, -1],\n            [8, 8],\n            [6, 6],\n            [6, 4],\n            [7, 2],\n            [8, 1],\n            [9, -1],\n            [9, -3],\n            [8, -5],\n            [7, -6],\n            [5, -7]\n        ]\n    },\n    '~': {\n        width: 24, points: [\n            [3, 6],\n            [3, 8],\n            [4, 11],\n            [6, 12],\n            [8, 12],\n            [10, 11],\n            [14, 8],\n            [16, 7],\n            [18, 7],\n            [20, 8],\n            [21, 10],\n            [-1, -1],\n            [3, 8],\n            [4, 10],\n            [6, 11],\n            [8, 11],\n            [10, 10],\n            [14, 7],\n            [16, 6],\n            [18, 6],\n            [20, 7],\n            [21, 10],\n            [21, 12]\n        ]\n    }\n};\n\n/**\n * @desc Creates wireframe text-shaped geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a text-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildVectorTextGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const text = buildVectorTextGeometry({\n *      origin: [0,0,0],\n *      text: \"On the other side of the screen, it all looked so easy\"\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"textGeometry\",\n *      primitiveType: text.primitiveType, // Will be \"lines\"\n *      positions: text.positions,\n *      indices: text.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redTextMesh\",\n *      geometryId: \"textGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redText\",\n *      meshIds: [\"redTextMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildVectorTextGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center]  3D point indicating the center position.\n * @param {Number[]} [cfg.origin] 3D point indicating the top left corner.\n * @param {Number} [cfg.size=1] Size of each character.\n * @param {String} [cfg.text=\"\"] The text.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildVectorTextGeometry(cfg = {}) {\n\n    var origin = cfg.origin || [0, 0, 0];\n    var xOrigin = origin[0];\n    var yOrigin = origin[1];\n    var zOrigin = origin[2];\n    var size = cfg.size || 1;\n\n    var positions = [];\n    var indices = [];\n    var text = (\"\" + cfg.text).trim();\n    var lines = (text || \"\").split(\"\\n\");\n    var countVerts = 0;\n    var y = 0;\n    var x;\n    var str;\n    var len;\n    var c;\n    var mag = 1.0 / 25.0;\n    var penUp;\n    var p1;\n    var p2;\n    var needLine;\n    var pointsLen;\n    var a;\n\n    for (var iLine = 0; iLine < lines.length; iLine++) {\n\n        x = 0;\n        str = lines[iLine];\n        len = str.length;\n\n        for (var i = 0; i < len; i++) {\n\n            c = letters[str.charAt(i)];\n\n            if (c === '\\n') {\n                //alert(\"newline\");\n            }\n\n            if (!c) {\n                continue;\n            }\n\n            penUp = 1;\n            p1 = -1;\n            p2 = -1;\n            needLine = false;\n\n            pointsLen = c.points.length;\n\n            for (var j = 0; j < pointsLen; j++) {\n                a = c.points[j];\n\n                if (a[0] === -1 && a[1] === -1) {\n                    penUp = 1;\n                    needLine = false;\n                    continue;\n                }\n\n                positions.push((x + (a[0] * size) * mag) + xOrigin);\n                positions.push((y + (a[1] * size) * mag) + yOrigin);\n                positions.push(0 + zOrigin);\n\n                if (p1 === -1) {\n                    p1 = countVerts;\n                } else if (p2 === -1) {\n                    p2 = countVerts;\n                } else {\n                    p1 = p2;\n                    p2 = countVerts;\n                }\n                countVerts++;\n\n                if (penUp) {\n                    penUp = false;\n\n                } else {\n                    indices.push(p1);\n                    indices.push(p2);\n                }\n\n                needLine = true;\n            }\n            x += c.width * mag * size;\n\n        }\n        y -= 35 * mag * size;\n    }\n\n    return {\n        primitiveType: \"lines\",\n        positions: positions,\n        indices: indices\n    };\n}\n\n\nexport {buildVectorTextGeometry}\n",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/geometryBuilders/buildVectorTextGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 189,
    "kind": "variable",
    "name": "letters",
    "memberof": "src/geometryBuilders/buildVectorTextGeometry.js",
    "static": true,
    "longname": "src/geometryBuilders/buildVectorTextGeometry.js~letters",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/geometryBuilders/buildVectorTextGeometry.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "type": {
      "types": [
        "{\" \": *, \"!\": *, \"\"\": *, \"#\": *, \"$\": *, \"%\": *, \"&\": *, \"'\": *, \"(\": *, \")\": *, \"*\": *, \"+\": *, \",\": *, \"-\": *, \".\": *, \"/\": *, \"0\": *, \"1\": *, \"2\": *, \"3\": *, \"4\": *, \"5\": *, \"6\": *, \"7\": *, \"8\": *, \"9\": *, \":\": *, \";\": *, \"<\": *, \"=\": *, \">\": *, \"?\": *, \"@\": *, \"A\": *, \"B\": *, \"C\": *, \"D\": *, \"E\": *, \"F\": *, \"G\": *, \"H\": *, \"I\": *, \"J\": *, \"K\": *, \"L\": *, \"M\": *, \"N\": *, \"O\": *, \"P\": *, \"Q\": *, \"R\": *, \"S\": *, \"T\": *, \"U\": *, \"V\": *, \"W\": *, \"X\": *, \"Y\": *, \"Z\": *, \"[\": *, \"\\\": *, \"]\": *, \"^\": *, \"_\": *, \"`\": *, \"a\": *, \"b\": *, \"c\": *, \"d\": *, \"e\": *, \"f\": *, \"g\": *, \"h\": *, \"i\": *, \"j\": *, \"k\": *, \"l\": *, \"m\": *, \"n\": *, \"o\": *, \"p\": *, \"q\": *, \"r\": *, \"s\": *, \"t\": *, \"u\": *, \"v\": *, \"w\": *, \"x\": *, \"y\": *, \"z\": *, \"{\": *, \"|\": *, \"}\": *, \"~\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 190,
    "kind": "function",
    "name": "buildVectorTextGeometry",
    "memberof": "src/geometryBuilders/buildVectorTextGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildVectorTextGeometry.js~buildVectorTextGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/geometryBuilders/buildVectorTextGeometry.js",
    "importStyle": "{buildVectorTextGeometry}",
    "description": "Creates wireframe text-shaped geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a text-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildVectorTextGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst text = buildVectorTextGeometry({\n     origin: [0,0,0],\n     text: \"On the other side of the screen, it all looked so easy\"\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"textGeometry\",\n     primitiveType: text.primitiveType, // Will be \"lines\"\n     positions: text.positions,\n     indices: text.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redTextMesh\",\n     geometryId: \"textGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redText\",\n     meshIds: [\"redTextMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 1625,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildVectorTextGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.origin",
        "description": "3D point indicating the top left corner."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.size",
        "description": "Size of each character."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\"\"",
        "defaultRaw": "",
        "name": "cfg.text",
        "description": "The text."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 191,
    "kind": "file",
    "name": "src/lib/math.js",
    "content": "// Some temporary vars to help avoid garbage collection\n\nconst doublePrecision = true;\nconst FloatArrayType = doublePrecision ? Float64Array : Float32Array;\n\nconst tempMat1 = new FloatArrayType(16);\nconst tempMat2 = new FloatArrayType(16);\nconst tempVec4 = new FloatArrayType(4);\n\n/**\n * @private\n */\nconst math = {\n\n    MIN_DOUBLE: -Number.MAX_SAFE_INTEGER,\n    MAX_DOUBLE:  Number.MAX_SAFE_INTEGER,\n\n    /**\n     * The number of radiians in a degree (0.0174532925).\n     * @property DEGTORAD\n     * @type {Number}\n     */\n    DEGTORAD: 0.0174532925,\n\n    /**\n     * The number of degrees in a radian.\n     * @property RADTODEG\n     * @type {Number}\n     */\n    RADTODEG: 57.295779513,\n\n    /**\n     * Returns a new, uninitialized two-element vector.\n     * @method vec2\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec2(values) {\n        return new FloatArrayType(values || 2);\n    },\n\n    /**\n     * Returns a new, uninitialized three-element vector.\n     * @method vec3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec3(values) {\n        return new FloatArrayType(values || 3);\n    },\n\n    /**\n     * Returns a new, uninitialized four-element vector.\n     * @method vec4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec4(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3x3 matrix.\n     * @method mat3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat3(values) {\n        return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Converts a 3x3 matrix to 4x4\n     * @method mat3ToMat4\n     * @param mat3 3x3 matrix.\n     * @param mat4 4x4 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat3ToMat4(mat3, mat4 = new FloatArrayType(16)) {\n        mat4[0] = mat3[0];\n        mat4[1] = mat3[1];\n        mat4[2] = mat3[2];\n        mat4[3] = 0;\n        mat4[4] = mat3[3];\n        mat4[5] = mat3[4];\n        mat4[6] = mat3[5];\n        mat4[7] = 0;\n        mat4[8] = mat3[6];\n        mat4[9] = mat3[7];\n        mat4[10] = mat3[8];\n        mat4[11] = 0;\n        mat4[12] = 0;\n        mat4[13] = 0;\n        mat4[14] = 0;\n        mat4[15] = 1;\n        return mat4;\n    },\n\n    /**\n     * Returns a new, uninitialized 4x4 matrix.\n     * @method mat4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat4(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /**\n     * Converts a 4x4 matrix to 3x3\n     * @method mat4ToMat3\n     * @param mat4 4x4 matrix.\n     * @param mat3 3x3 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat4ToMat3(mat4, mat3) { // TODO\n        //return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Returns a new UUID.\n     * @method createUUID\n     * @static\n     * @return string The new UUID\n     */\n    createUUID: ((() => {\n        const self = {};\n        const lut = [];\n        for (let i = 0; i < 256; i++) {\n            lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n        }\n        return () => {\n            const d0 = Math.random() * 0xffffffff | 0;\n            const d1 = Math.random() * 0xffffffff | 0;\n            const d2 = Math.random() * 0xffffffff | 0;\n            const d3 = Math.random() * 0xffffffff | 0;\n            return `${lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff]}-${lut[d1 & 0xff]}${lut[d1 >> 8 & 0xff]}-${lut[d1 >> 16 & 0x0f | 0x40]}${lut[d1 >> 24 & 0xff]}-${lut[d2 & 0x3f | 0x80]}${lut[d2 >> 8 & 0xff]}-${lut[d2 >> 16 & 0xff]}${lut[d2 >> 24 & 0xff]}${lut[d3 & 0xff]}${lut[d3 >> 8 & 0xff]}${lut[d3 >> 16 & 0xff]}${lut[d3 >> 24 & 0xff]}`;\n        };\n    }))(),\n\n    /**\n     * Clamps a value to the given range.\n     * @param {Number} value Value to clamp.\n     * @param {Number} min Lower bound.\n     * @param {Number} max Upper bound.\n     * @returns {Number} Clamped result.\n     */\n    clamp(value, min, max) {\n        return Math.max(min, Math.min(max, value));\n    },\n\n    /**\n     * Floating-point modulus\n     * @method fmod\n     * @static\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {*}\n     */\n    fmod(a, b) {\n        if (a < b) {\n            console.error(\"math.fmod : Attempting to find modulus within negative range - would be infinite loop - ignoring\");\n            return a;\n        }\n        while (b <= a) {\n            a -= b;\n        }\n        return a;\n    },\n\n    /**\n     * Negates a four-element vector.\n     * @method negateVec4\n     * @static\n     * @param {Array(Number)} v Vector to negate\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    negateVec4(v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = -v[0];\n        dest[1] = -v[1];\n        dest[2] = -v[2];\n        dest[3] = -v[3];\n        return dest;\n    },\n\n    /**\n     * Adds one four-element vector to another.\n     * @method addVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        dest[3] = u[3] + v[3];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a four-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        dest[3] = v[3] + s;\n        return dest;\n    },\n\n    /**\n     * Adds one three-element vector to another.\n     * @method addVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a three-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        return dest;\n    },\n\n    /**\n     * Subtracts one four-element vector from another.\n     * @method subVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        dest[3] = u[3] - v[3];\n        return dest;\n    },\n\n    /**\n     * Subtracts one three-element vector from another.\n     * @method subVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        return dest;\n    },\n\n    /**\n     * Subtracts one two-element vector from another.\n     * @method subVec2\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec2(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        return dest;\n    },\n\n    /**\n     * Subtracts a scalar value from each element of a four-element vector.\n     * @method subVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] - s;\n        dest[1] = v[1] - s;\n        dest[2] = v[2] - s;\n        dest[3] = v[3] - s;\n        return dest;\n    },\n\n    /**\n     * Sets each element of a 4-element vector to a scalar value minus the value of that element.\n     * @method subScalarVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subScalarVec4(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s - v[0];\n        dest[1] = s - v[1];\n        dest[2] = s - v[2];\n        dest[3] = s - v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies one three-element vector by another.\n     * @method mulVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    mulVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] * v[0];\n        dest[1] = u[1] * v[1];\n        dest[2] = u[2] * v[2];\n        dest[3] = u[3] * v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a four-element vector by a scalar.\n     * @method mulVec34calar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        dest[3] = v[3] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a three-element vector by a scalar.\n     * @method mulVec3Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a two-element vector by a scalar.\n     * @method mulVec2Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec2Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        return dest;\n    },\n\n    /**\n     * Divides one three-element vector by another.\n     * @method divVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides one four-element vector by another.\n     * @method divVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        dest[3] = u[3] / v[3];\n        return dest;\n    },\n\n    /**\n     * Divides a scalar by a three-element vector, returning a new vector.\n     * @method divScalarVec3\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec3(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides a three-element vector by a scalar.\n     * @method divVec3Scalar\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        return dest;\n    },\n\n    /**\n     * Divides a four-element vector by a scalar.\n     * @method divVec4Scalar\n     * @static\n     * @param v vec4\n     * @param s scalar\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        dest[3] = v[3] / s;\n        return dest;\n    },\n\n\n    /**\n     * Divides a scalar by a four-element vector, returning a new vector.\n     * @method divScalarVec4\n     * @static\n     * @param s scalar\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec4(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        dest[3] = s / v[3];\n        return dest;\n    },\n\n    /**\n     * Returns the dot product of two four-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec4(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3]);\n    },\n\n    /**\n     * Returns the cross product of two four-element vectors.\n     * @method cross3Vec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec4(u, v) {\n        const u0 = u[0];\n        const u1 = u[1];\n        const u2 = u[2];\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        return [\n            u1 * v2 - u2 * v1,\n            u2 * v0 - u0 * v2,\n            u0 * v1 - u1 * v0,\n            0.0];\n    },\n\n    /**\n     * Returns the cross product of two three-element vectors.\n     * @method cross3Vec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        const x = u[0];\n        const y = u[1];\n        const z = u[2];\n        const x2 = v[0];\n        const y2 = v[1];\n        const z2 = v[2];\n        dest[0] = y * z2 - z * y2;\n        dest[1] = z * x2 - x * z2;\n        dest[2] = x * y2 - y * x2;\n        return dest;\n    },\n\n\n    sqLenVec4(v) { // TODO\n        return math.dotVec4(v, v);\n    },\n\n    /**\n     * Returns the length of a four-element vector.\n     * @method lenVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec4(v) {\n        return Math.sqrt(math.sqLenVec4(v));\n    },\n\n    /**\n     * Returns the dot product of two three-element vectors.\n     * @method dotVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec3(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2]);\n    },\n\n    /**\n     * Returns the dot product of two two-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec2(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]);\n    },\n\n\n    sqLenVec3(v) {\n        return math.dotVec3(v, v);\n    },\n\n\n    sqLenVec2(v) {\n        return math.dotVec2(v, v);\n    },\n\n    /**\n     * Returns the length of a three-element vector.\n     * @method lenVec3\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec3(v) {\n        return Math.sqrt(math.sqLenVec3(v));\n    },\n\n    distVec3: ((() => {\n        const vec = new FloatArrayType(3);\n        return (v, w) => math.lenVec3(math.subVec3(v, w, vec));\n    }))(),\n\n    /**\n     * Returns the length of a two-element vector.\n     * @method lenVec2\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec2(v) {\n        return Math.sqrt(math.sqLenVec2(v));\n    },\n\n    distVec2: ((() => {\n        const vec = new FloatArrayType(2);\n        return (v, w) => math.lenVec2(math.subVec2(v, w, vec));\n    }))(),\n\n    /**\n     * @method rcpVec3\n     * @static\n     * @param v vec3\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    rcpVec3(v, dest) {\n        return math.divScalarVec3(1.0, v, dest);\n    },\n\n    /**\n     * Normalizes a four-element vector\n     * @method normalizeVec4\n     * @static\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    normalizeVec4(v, dest) {\n        const f = 1.0 / math.lenVec4(v);\n        return math.mulVec4Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a three-element vector\n     * @method normalizeVec4\n     * @static\n     */\n    normalizeVec3(v, dest) {\n        const f = 1.0 / math.lenVec3(v);\n        return math.mulVec3Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a two-element vector\n     * @method normalizeVec2\n     * @static\n     */\n    normalizeVec2(v, dest) {\n        const f = 1.0 / math.lenVec2(v);\n        return math.mulVec2Scalar(v, f, dest);\n    },\n\n    /**\n     * Gets the angle between two vectors\n     * @method angleVec3\n     * @param v\n     * @param w\n     * @returns {number}\n     */\n    angleVec3(v, w) {\n        let theta = math.dotVec3(v, w) / (Math.sqrt(math.sqLenVec3(v) * math.sqLenVec3(w)));\n        theta = theta < -1 ? -1 : (theta > 1 ? 1 : theta);  // Clamp to handle numerical problems\n        return Math.acos(theta);\n    },\n\n    /**\n     * Creates a three-element vector from the rotation part of a sixteen-element matrix.\n     * @param m\n     * @param dest\n     */\n    vec3FromMat4Scale: ((() => {\n\n        const tempVec3 = new FloatArrayType(3);\n\n        return (m, dest) => {\n\n            tempVec3[0] = m[0];\n            tempVec3[1] = m[1];\n            tempVec3[2] = m[2];\n\n            dest[0] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[4];\n            tempVec3[1] = m[5];\n            tempVec3[2] = m[6];\n\n            dest[1] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[8];\n            tempVec3[1] = m[9];\n            tempVec3[2] = m[10];\n\n            dest[2] = math.lenVec3(tempVec3);\n\n            return dest;\n        };\n    }))(),\n\n    /**\n     * Converts an n-element vector to a JSON-serializable\n     * array with values rounded to two decimal places.\n     */\n    vecToArray: ((() => {\n        function trunc(v) {\n            return Math.round(v * 100000) / 100000\n        }\n\n        return v => {\n            v = Array.prototype.slice.call(v);\n            for (let i = 0, len = v.length; i < len; i++) {\n                v[i] = trunc(v[i]);\n            }\n            return v;\n        };\n    }))(),\n\n    /**\n     * Converts a 3-element vector from an array to an object of the form ````{x:999, y:999, z:999}````.\n     * @param arr\n     * @returns {{x: *, y: *, z: *}}\n     */\n    xyzArrayToObject(arr) {\n        return {\"x\": arr[0], \"y\": arr[1], \"z\": arr[2]};\n    },\n\n    /**\n     * Converts a 3-element vector object of the form ````{x:999, y:999, z:999}```` to an array.\n     * @param xyz\n     * @param  [arry]\n     * @returns {*[]}\n     */\n    xyzObjectToArray(xyz, arry) {\n        arry = arry || new FloatArrayType(3);\n        arry[0] = xyz.x;\n        arry[1] = xyz.y;\n        arry[2] = xyz.z;\n        return arry;\n    },\n\n    /**\n     * Duplicates a 4x4 identity matrix.\n     * @method dupMat4\n     * @static\n     */\n    dupMat4(m) {\n        return m.slice(0, 16);\n    },\n\n    /**\n     * Extracts a 3x3 matrix from a 4x4 matrix.\n     * @method mat4To3\n     * @static\n     */\n    mat4To3(m) {\n        return [\n            m[0], m[1], m[2],\n            m[4], m[5], m[6],\n            m[8], m[9], m[10]\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to the given scalar value.\n     * @method m4s\n     * @static\n     */\n    m4s(s) {\n        return [\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to zero.\n     * @method setMat4ToZeroes\n     * @static\n     */\n    setMat4ToZeroes() {\n        return math.m4s(0.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    setMat4ToOnes() {\n        return math.m4s(1.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    diagonalMat4v(v) {\n        return new FloatArrayType([\n            v[0], 0.0, 0.0, 0.0,\n            0.0, v[1], 0.0, 0.0,\n            0.0, 0.0, v[2], 0.0,\n            0.0, 0.0, 0.0, v[3]\n        ]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given vector.\n     * @method diagonalMat4c\n     * @static\n     */\n    diagonalMat4c(x, y, z, w) {\n        return math.diagonalMat4v([x, y, z, w]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given scalar.\n     * @method diagonalMat4s\n     * @static\n     */\n    diagonalMat4s(s) {\n        return math.diagonalMat4c(s, s, s, s);\n    },\n\n    /**\n     * Returns a 4x4 identity matrix.\n     * @method identityMat4\n     * @static\n     */\n    identityMat4(mat = new FloatArrayType(16)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n        mat[3] = 0.0;\n\n        mat[4] = 0.0;\n        mat[5] = 1.0;\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n\n        mat[8] = 0.0;\n        mat[9] = 0.0;\n        mat[10] = 1.0;\n        mat[11] = 0.0;\n\n        mat[12] = 0.0;\n        mat[13] = 0.0;\n        mat[14] = 0.0;\n        mat[15] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Returns a 3x3 identity matrix.\n     * @method identityMat3\n     * @static\n     */\n    identityMat3(mat = new FloatArrayType(9)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n\n        mat[3] = 0.0;\n        mat[4] = 1.0;\n        mat[5] = 0.0;\n\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n        mat[8] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Tests if the given 4x4 matrix is the identity matrix.\n     * @method isIdentityMat4\n     * @static\n     */\n    isIdentityMat4(m) {\n        if (m[0] !== 1.0 || m[1] !== 0.0 || m[2] !== 0.0 || m[3] !== 0.0 ||\n            m[4] !== 0.0 || m[5] !== 1.0 || m[6] !== 0.0 || m[7] !== 0.0 ||\n            m[8] !== 0.0 || m[9] !== 0.0 || m[10] !== 1.0 || m[11] !== 0.0 ||\n            m[12] !== 0.0 || m[13] !== 0.0 || m[14] !== 0.0 || m[15] !== 1.0) {\n            return false;\n        }\n        return true;\n    },\n\n    /**\n     * Negates the given 4x4 matrix.\n     * @method negateMat4\n     * @static\n     */\n    negateMat4(m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = -m[0];\n        dest[1] = -m[1];\n        dest[2] = -m[2];\n        dest[3] = -m[3];\n        dest[4] = -m[4];\n        dest[5] = -m[5];\n        dest[6] = -m[6];\n        dest[7] = -m[7];\n        dest[8] = -m[8];\n        dest[9] = -m[9];\n        dest[10] = -m[10];\n        dest[11] = -m[11];\n        dest[12] = -m[12];\n        dest[13] = -m[13];\n        dest[14] = -m[14];\n        dest[15] = -m[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given 4x4 matrices together.\n     * @method addMat4\n     * @static\n     */\n    addMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] + b[0];\n        dest[1] = a[1] + b[1];\n        dest[2] = a[2] + b[2];\n        dest[3] = a[3] + b[3];\n        dest[4] = a[4] + b[4];\n        dest[5] = a[5] + b[5];\n        dest[6] = a[6] + b[6];\n        dest[7] = a[7] + b[7];\n        dest[8] = a[8] + b[8];\n        dest[9] = a[9] + b[9];\n        dest[10] = a[10] + b[10];\n        dest[11] = a[11] + b[11];\n        dest[12] = a[12] + b[12];\n        dest[13] = a[13] + b[13];\n        dest[14] = a[14] + b[14];\n        dest[15] = a[15] + b[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addMat4Scalar\n     * @static\n     */\n    addMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] + s;\n        dest[1] = m[1] + s;\n        dest[2] = m[2] + s;\n        dest[3] = m[3] + s;\n        dest[4] = m[4] + s;\n        dest[5] = m[5] + s;\n        dest[6] = m[6] + s;\n        dest[7] = m[7] + s;\n        dest[8] = m[8] + s;\n        dest[9] = m[9] + s;\n        dest[10] = m[10] + s;\n        dest[11] = m[11] + s;\n        dest[12] = m[12] + s;\n        dest[13] = m[13] + s;\n        dest[14] = m[14] + s;\n        dest[15] = m[15] + s;\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addScalarMat4\n     * @static\n     */\n    addScalarMat4(s, m, dest) {\n        return math.addMat4Scalar(m, s, dest);\n    },\n\n    /**\n     * Subtracts the second 4x4 matrix from the first.\n     * @method subMat4\n     * @static\n     */\n    subMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] - b[0];\n        dest[1] = a[1] - b[1];\n        dest[2] = a[2] - b[2];\n        dest[3] = a[3] - b[3];\n        dest[4] = a[4] - b[4];\n        dest[5] = a[5] - b[5];\n        dest[6] = a[6] - b[6];\n        dest[7] = a[7] - b[7];\n        dest[8] = a[8] - b[8];\n        dest[9] = a[9] - b[9];\n        dest[10] = a[10] - b[10];\n        dest[11] = a[11] - b[11];\n        dest[12] = a[12] - b[12];\n        dest[13] = a[13] - b[13];\n        dest[14] = a[14] - b[14];\n        dest[15] = a[15] - b[15];\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subMat4Scalar\n     * @static\n     */\n    subMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] - s;\n        dest[1] = m[1] - s;\n        dest[2] = m[2] - s;\n        dest[3] = m[3] - s;\n        dest[4] = m[4] - s;\n        dest[5] = m[5] - s;\n        dest[6] = m[6] - s;\n        dest[7] = m[7] - s;\n        dest[8] = m[8] - s;\n        dest[9] = m[9] - s;\n        dest[10] = m[10] - s;\n        dest[11] = m[11] - s;\n        dest[12] = m[12] - s;\n        dest[13] = m[13] - s;\n        dest[14] = m[14] - s;\n        dest[15] = m[15] - s;\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subScalarMat4\n     * @static\n     */\n    subScalarMat4(s, m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = s - m[0];\n        dest[1] = s - m[1];\n        dest[2] = s - m[2];\n        dest[3] = s - m[3];\n        dest[4] = s - m[4];\n        dest[5] = s - m[5];\n        dest[6] = s - m[6];\n        dest[7] = s - m[7];\n        dest[8] = s - m[8];\n        dest[9] = s - m[9];\n        dest[10] = s - m[10];\n        dest[11] = s - m[11];\n        dest[12] = s - m[12];\n        dest[13] = s - m[13];\n        dest[14] = s - m[14];\n        dest[15] = s - m[15];\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 4x4 matrix by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = a[0];\n\n        const a01 = a[1];\n        const a02 = a[2];\n        const a03 = a[3];\n        const a10 = a[4];\n        const a11 = a[5];\n        const a12 = a[6];\n        const a13 = a[7];\n        const a20 = a[8];\n        const a21 = a[9];\n        const a22 = a[10];\n        const a23 = a[11];\n        const a30 = a[12];\n        const a31 = a[13];\n        const a32 = a[14];\n        const a33 = a[15];\n        const b00 = b[0];\n        const b01 = b[1];\n        const b02 = b[2];\n        const b03 = b[3];\n        const b10 = b[4];\n        const b11 = b[5];\n        const b12 = b[6];\n        const b13 = b[7];\n        const b20 = b[8];\n        const b21 = b[9];\n        const b22 = b[10];\n        const b23 = b[11];\n        const b30 = b[12];\n        const b31 = b[13];\n        const b32 = b[14];\n        const b33 = b[15];\n\n        dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;\n        dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;\n        dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;\n        dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;\n        dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;\n        dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;\n        dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;\n        dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;\n        dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;\n        dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;\n        dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;\n        dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;\n        dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;\n        dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;\n        dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;\n        dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 3x3 matrices by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat3(a, b, dest) {\n        if (!dest) {\n            dest = new FloatArrayType(9);\n        }\n\n        const a11 = a[0];\n        const a12 = a[3];\n        const a13 = a[6];\n        const a21 = a[1];\n        const a22 = a[4];\n        const a23 = a[7];\n        const a31 = a[2];\n        const a32 = a[5];\n        const a33 = a[8];\n        const b11 = b[0];\n        const b12 = b[3];\n        const b13 = b[6];\n        const b21 = b[1];\n        const b22 = b[4];\n        const b23 = b[7];\n        const b31 = b[2];\n        const b32 = b[5];\n        const b33 = b[8];\n\n        dest[0] = a11 * b11 + a12 * b21 + a13 * b31;\n        dest[3] = a11 * b12 + a12 * b22 + a13 * b32;\n        dest[6] = a11 * b13 + a12 * b23 + a13 * b33;\n\n        dest[1] = a21 * b11 + a22 * b21 + a23 * b31;\n        dest[4] = a21 * b12 + a22 * b22 + a23 * b32;\n        dest[7] = a21 * b13 + a22 * b23 + a23 * b33;\n\n        dest[2] = a31 * b11 + a32 * b21 + a33 * b31;\n        dest[5] = a31 * b12 + a32 * b22 + a33 * b32;\n        dest[8] = a31 * b13 + a32 * b23 + a33 * b33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of the given 4x4 matrix by the given scalar.\n     * @method mulMat4Scalar\n     * @static\n     */\n    mulMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] * s;\n        dest[1] = m[1] * s;\n        dest[2] = m[2] * s;\n        dest[3] = m[3] * s;\n        dest[4] = m[4] * s;\n        dest[5] = m[5] * s;\n        dest[6] = m[6] * s;\n        dest[7] = m[7] * s;\n        dest[8] = m[8] * s;\n        dest[9] = m[9] * s;\n        dest[10] = m[10] * s;\n        dest[11] = m[11] * s;\n        dest[12] = m[12] * s;\n        dest[13] = m[13] * s;\n        dest[14] = m[14] * s;\n        dest[15] = m[15] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies the given 4x4 matrix by the given four-element vector.\n     * @method mulMat4v4\n     * @static\n     */\n    mulMat4v4(m, v, dest = math.vec4()) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Transposes the given 4x4 matrix.\n     * @method transposeMat4\n     * @static\n     */\n    transposeMat4(mat, dest) {\n        // If we are transposing ourselves we can skip a few steps but have to cache some values\n        const m4 = mat[4];\n\n        const m14 = mat[14];\n        const m8 = mat[8];\n        const m13 = mat[13];\n        const m12 = mat[12];\n        const m9 = mat[9];\n        if (!dest || mat === dest) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a03 = mat[3];\n            const a12 = mat[6];\n            const a13 = mat[7];\n            const a23 = mat[11];\n            mat[1] = m4;\n            mat[2] = m8;\n            mat[3] = m12;\n            mat[4] = a01;\n            mat[6] = m9;\n            mat[7] = m13;\n            mat[8] = a02;\n            mat[9] = a12;\n            mat[11] = m14;\n            mat[12] = a03;\n            mat[13] = a13;\n            mat[14] = a23;\n            return mat;\n        }\n        dest[0] = mat[0];\n        dest[1] = m4;\n        dest[2] = m8;\n        dest[3] = m12;\n        dest[4] = mat[1];\n        dest[5] = mat[5];\n        dest[6] = m9;\n        dest[7] = m13;\n        dest[8] = mat[2];\n        dest[9] = mat[6];\n        dest[10] = mat[10];\n        dest[11] = m14;\n        dest[12] = mat[3];\n        dest[13] = mat[7];\n        dest[14] = mat[11];\n        dest[15] = mat[15];\n        return dest;\n    },\n\n    /**\n     * Transposes the given 3x3 matrix.\n     *\n     * @method transposeMat3\n     * @static\n     */\n    transposeMat3(mat, dest) {\n        if (dest === mat) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a12 = mat[5];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = a01;\n            dest[5] = mat[7];\n            dest[6] = a02;\n            dest[7] = a12;\n        } else {\n            dest[0] = mat[0];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = mat[1];\n            dest[4] = mat[4];\n            dest[5] = mat[7];\n            dest[6] = mat[2];\n            dest[7] = mat[5];\n            dest[8] = mat[8];\n        }\n        return dest;\n    },\n\n    /**\n     * Returns the determinant of the given 4x4 matrix.\n     * @method determinantMat4\n     * @static\n     */\n    determinantMat4(mat) {\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +\n            a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +\n            a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +\n            a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +\n            a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +\n            a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;\n    },\n\n    /**\n     * Returns the inverse of the given 4x4 matrix.\n     * @method inverseMat4\n     * @static\n     */\n    inverseMat4(mat, dest) {\n        if (!dest) {\n            dest = mat;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        const b00 = a00 * a11 - a01 * a10;\n        const b01 = a00 * a12 - a02 * a10;\n        const b02 = a00 * a13 - a03 * a10;\n        const b03 = a01 * a12 - a02 * a11;\n        const b04 = a01 * a13 - a03 * a11;\n        const b05 = a02 * a13 - a03 * a12;\n        const b06 = a20 * a31 - a21 * a30;\n        const b07 = a20 * a32 - a22 * a30;\n        const b08 = a20 * a33 - a23 * a30;\n        const b09 = a21 * a32 - a22 * a31;\n        const b10 = a21 * a33 - a23 * a31;\n        const b11 = a22 * a33 - a23 * a32;\n\n        // Calculate the determinant (inlined to avoid double-caching)\n        const invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);\n\n        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;\n        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;\n        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;\n        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;\n        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;\n        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;\n        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;\n        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;\n        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;\n        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;\n        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;\n        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;\n        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;\n        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;\n        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;\n        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;\n\n        return dest;\n    },\n\n    /**\n     * Returns the trace of the given 4x4 matrix.\n     * @method traceMat4\n     * @static\n     */\n    traceMat4(m) {\n        return (m[0] + m[5] + m[10] + m[15]);\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4\n     * @static\n     */\n    translationMat4v(v, dest) {\n        const m = dest || math.identityMat4();\n        m[12] = v[0];\n        m[13] = v[1];\n        m[14] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 translation matrix.\n     * @method translationMat3\n     * @static\n     */\n    translationMat3v(v, dest) {\n        const m = dest || math.identityMat3();\n        m[6] = v[0];\n        m[7] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4c\n     * @static\n     */\n    translationMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.translationMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4s\n     * @static\n     */\n    translationMat4s(s, dest) {\n        return math.translationMat4c(s, s, s, dest);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param v\n     * @param m\n     */\n    translateMat4v(xyz, m) {\n        return math.translateMat4c(xyz[0], xyz[1], xyz[2], m);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    OLDtranslateMat4c(x, y, z, m) {\n\n        const m12 = m[12];\n        m[0] += m12 * x;\n        m[4] += m12 * y;\n        m[8] += m12 * z;\n\n        const m13 = m[13];\n        m[1] += m13 * x;\n        m[5] += m13 * y;\n        m[9] += m13 * z;\n\n        const m14 = m[14];\n        m[2] += m14 * x;\n        m[6] += m14 * y;\n        m[10] += m14 * z;\n\n        const m15 = m[15];\n        m[3] += m15 * x;\n        m[7] += m15 * y;\n        m[11] += m15 * z;\n\n        return m;\n    },\n\n    translateMat4c(x, y, z, m) {\n\n        const m3 = m[3];\n        m[0] += m3 * x;\n        m[1] += m3 * y;\n        m[2] += m3 * z;\n\n        const m7 = m[7];\n        m[4] += m7 * x;\n        m[5] += m7 * y;\n        m[6] += m7 * z;\n\n        const m11 = m[11];\n        m[8] += m11 * x;\n        m[9] += m11 * y;\n        m[10] += m11 * z;\n\n        const m15 = m[15];\n        m[12] += m15 * x;\n        m[13] += m15 * y;\n        m[14] += m15 * z;\n\n        return m;\n    },\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4v\n     * @static\n     */\n    rotationMat4v(anglerad, axis, m) {\n        const ax = math.normalizeVec4([axis[0], axis[1], axis[2], 0.0], []);\n        const s = Math.sin(anglerad);\n        const c = Math.cos(anglerad);\n        const q = 1.0 - c;\n\n        const x = ax[0];\n        const y = ax[1];\n        const z = ax[2];\n\n        let xy;\n        let yz;\n        let zx;\n        let xs;\n        let ys;\n        let zs;\n\n        //xx = x * x; used once\n        //yy = y * y; used once\n        //zz = z * z; used once\n        xy = x * y;\n        yz = y * z;\n        zx = z * x;\n        xs = x * s;\n        ys = y * s;\n        zs = z * s;\n\n        m = m || math.mat4();\n\n        m[0] = (q * x * x) + c;\n        m[1] = (q * xy) + zs;\n        m[2] = (q * zx) - ys;\n        m[3] = 0.0;\n\n        m[4] = (q * xy) - zs;\n        m[5] = (q * y * y) + c;\n        m[6] = (q * yz) + xs;\n        m[7] = 0.0;\n\n        m[8] = (q * zx) + ys;\n        m[9] = (q * yz) - xs;\n        m[10] = (q * z * z) + c;\n        m[11] = 0.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = 0.0;\n        m[15] = 1.0;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4c\n     * @static\n     */\n    rotationMat4c(anglerad, x, y, z, mat) {\n        return math.rotationMat4v(anglerad, [x, y, z], mat);\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4v\n     * @static\n     */\n    scalingMat4v(v, m = math.identityMat4()) {\n        m[0] = v[0];\n        m[5] = v[1];\n        m[10] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 scale matrix.\n     * @method scalingMat3v\n     * @static\n     */\n    scalingMat3v(v, m = math.identityMat3()) {\n        m[0] = v[0];\n        m[4] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4c\n     * @static\n     */\n    scalingMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.scalingMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    scaleMat4c(x, y, z, m) {\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n        return m;\n    },\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param xyz\n     * @param m\n     */\n    scaleMat4v(xyz, m) {\n\n        const x = xyz[0];\n        const y = xyz[1];\n        const z = xyz[2];\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4s\n     * @static\n     */\n    scalingMat4s(s) {\n        return math.scalingMat4c(s, s, s);\n    },\n\n    /**\n     * Creates a matrix from a quaternion rotation and vector translation\n     *\n     * @param {Number[]} q Rotation quaternion\n     * @param {Number[]} v Translation vector\n     * @param {Number[]} dest Destination matrix\n     * @returns {Number[]} dest\n     */\n    rotationTranslationMat4(q, v, dest = math.mat4()) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        dest[0] = 1 - (yy + zz);\n        dest[1] = xy + wz;\n        dest[2] = xz - wy;\n        dest[3] = 0;\n        dest[4] = xy - wz;\n        dest[5] = 1 - (xx + zz);\n        dest[6] = yz + wx;\n        dest[7] = 0;\n        dest[8] = xz + wy;\n        dest[9] = yz - wx;\n        dest[10] = 1 - (xx + yy);\n        dest[11] = 0;\n        dest[12] = v[0];\n        dest[13] = v[1];\n        dest[14] = v[2];\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Gets Euler angles from a 4x4 matrix.\n     *\n     * @param {Number[]} mat The 4x4 matrix.\n     * @param {String} order Desired Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination Euler angles, created by default.\n     * @returns {Number[]} The Euler angles.\n     */\n    mat4ToEuler(mat, order, dest = math.vec4()) {\n        const clamp = math.clamp;\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = mat[0];\n\n        const m12 = mat[4];\n        const m13 = mat[8];\n        const m21 = mat[1];\n        const m22 = mat[5];\n        const m23 = mat[9];\n        const m31 = mat[2];\n        const m32 = mat[6];\n        const m33 = mat[10];\n\n        if (order === 'XYZ') {\n\n            dest[1] = Math.asin(clamp(m13, -1, 1));\n\n            if (Math.abs(m13) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[2] = Math.atan2(-m12, m11);\n            } else {\n                dest[0] = Math.atan2(m32, m22);\n                dest[2] = 0;\n\n            }\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = Math.asin(-clamp(m23, -1, 1));\n\n            if (Math.abs(m23) < 0.99999) {\n                dest[1] = Math.atan2(m13, m33);\n                dest[2] = Math.atan2(m21, m22);\n            } else {\n                dest[1] = Math.atan2(-m31, m11);\n                dest[2] = 0;\n            }\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = Math.asin(clamp(m32, -1, 1));\n\n            if (Math.abs(m32) < 0.99999) {\n                dest[1] = Math.atan2(-m31, m33);\n                dest[2] = Math.atan2(-m12, m22);\n            } else {\n                dest[1] = 0;\n                dest[2] = Math.atan2(m21, m11);\n            }\n\n        } else if (order === 'ZYX') {\n\n            dest[1] = Math.asin(-clamp(m31, -1, 1));\n\n            if (Math.abs(m31) < 0.99999) {\n                dest[0] = Math.atan2(m32, m33);\n                dest[2] = Math.atan2(m21, m11);\n            } else {\n                dest[0] = 0;\n                dest[2] = Math.atan2(-m12, m22);\n            }\n\n        } else if (order === 'YZX') {\n\n            dest[2] = Math.asin(clamp(m21, -1, 1));\n\n            if (Math.abs(m21) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m22);\n                dest[1] = Math.atan2(-m31, m11);\n            } else {\n                dest[0] = 0;\n                dest[1] = Math.atan2(m13, m33);\n            }\n\n        } else if (order === 'XZY') {\n\n            dest[2] = Math.asin(-clamp(m12, -1, 1));\n\n            if (Math.abs(m12) < 0.99999) {\n                dest[0] = Math.atan2(m32, m22);\n                dest[1] = Math.atan2(m13, m11);\n            } else {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[1] = 0;\n            }\n        }\n\n        return dest;\n    },\n\n    composeMat4(position, quaternion, scale, mat = math.mat4()) {\n        math.quaternionToRotationMat4(quaternion, mat);\n        math.scaleMat4v(scale, mat);\n        math.translateMat4v(position, mat);\n\n        return mat;\n    },\n\n    decomposeMat4: (() => {\n\n        const vec = new FloatArrayType(3);\n        const matrix = new FloatArrayType(16);\n\n        return function decompose(mat, position, quaternion, scale) {\n\n            vec[0] = mat[0];\n            vec[1] = mat[1];\n            vec[2] = mat[2];\n\n            let sx = math.lenVec3(vec);\n\n            vec[0] = mat[4];\n            vec[1] = mat[5];\n            vec[2] = mat[6];\n\n            const sy = math.lenVec3(vec);\n\n            vec[8] = mat[8];\n            vec[9] = mat[9];\n            vec[10] = mat[10];\n\n            const sz = math.lenVec3(vec);\n\n            // if determine is negative, we need to invert one scale\n            const det = math.determinantMat4(mat);\n\n            if (det < 0) {\n                sx = -sx;\n            }\n\n            position[0] = mat[12];\n            position[1] = mat[13];\n            position[2] = mat[14];\n\n            // scale the rotation part\n            matrix.set(mat);\n\n            const invSX = 1 / sx;\n            const invSY = 1 / sy;\n            const invSZ = 1 / sz;\n\n            matrix[0] *= invSX;\n            matrix[1] *= invSX;\n            matrix[2] *= invSX;\n\n            matrix[4] *= invSY;\n            matrix[5] *= invSY;\n            matrix[6] *= invSY;\n\n            matrix[8] *= invSZ;\n            matrix[9] *= invSZ;\n            matrix[10] *= invSZ;\n\n            math.mat4ToQuaternion(matrix, quaternion);\n\n            scale[0] = sx;\n            scale[1] = sy;\n            scale[2] = sz;\n\n            return this;\n\n        };\n\n    })(),\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4v\n     * @param pos vec3 position of the viewer\n     * @param target vec3 point the viewer is looking at\n     * @param up vec3 pointing \"up\"\n     * @param dest mat4 Optional, mat4 matrix will be written into\n     *\n     * @return {mat4} dest if specified, a new mat4 otherwise\n     */\n    lookAtMat4v(pos, target, up, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n\n        const posx = pos[0];\n        const posy = pos[1];\n        const posz = pos[2];\n        const upx = up[0];\n        const upy = up[1];\n        const upz = up[2];\n        const targetx = target[0];\n        const targety = target[1];\n        const targetz = target[2];\n\n        if (posx === targetx && posy === targety && posz === targetz) {\n            return math.identityMat4();\n        }\n\n        let z0;\n        let z1;\n        let z2;\n        let x0;\n        let x1;\n        let x2;\n        let y0;\n        let y1;\n        let y2;\n        let len;\n\n        //vec3.direction(eye, center, z);\n        z0 = posx - targetx;\n        z1 = posy - targety;\n        z2 = posz - targetz;\n\n        // normalize (no check needed for 0 because of early return)\n        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n\n        //vec3.normalize(vec3.cross(up, z, x));\n        x0 = upy * z2 - upz * z1;\n        x1 = upz * z0 - upx * z2;\n        x2 = upx * z1 - upy * z0;\n        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n        if (!len) {\n            x0 = 0;\n            x1 = 0;\n            x2 = 0;\n        } else {\n            len = 1 / len;\n            x0 *= len;\n            x1 *= len;\n            x2 *= len;\n        }\n\n        //vec3.normalize(vec3.cross(z, x, y));\n        y0 = z1 * x2 - z2 * x1;\n        y1 = z2 * x0 - z0 * x2;\n        y2 = z0 * x1 - z1 * x0;\n\n        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n        if (!len) {\n            y0 = 0;\n            y1 = 0;\n            y2 = 0;\n        } else {\n            len = 1 / len;\n            y0 *= len;\n            y1 *= len;\n            y2 *= len;\n        }\n\n        dest[0] = x0;\n        dest[1] = y0;\n        dest[2] = z0;\n        dest[3] = 0;\n        dest[4] = x1;\n        dest[5] = y1;\n        dest[6] = z1;\n        dest[7] = 0;\n        dest[8] = x2;\n        dest[9] = y2;\n        dest[10] = z2;\n        dest[11] = 0;\n        dest[12] = -(x0 * posx + x1 * posy + x2 * posz);\n        dest[13] = -(y0 * posx + y1 * posy + y2 * posz);\n        dest[14] = -(z0 * posx + z1 * posy + z2 * posz);\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4c\n     * @static\n     */\n    lookAtMat4c(posx, posy, posz, targetx, targety, targetz, upx, upy, upz) {\n        return math.lookAtMat4v([posx, posy, posz], [targetx, targety, targetz], [upx, upy, upz], []);\n    },\n\n    /**\n     * Returns a 4x4 orthographic projection matrix.\n     * @method orthoMat4c\n     * @static\n     */\n    orthoMat4c(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n\n        dest[0] = 2.0 / rl;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 0.0;\n\n        dest[4] = 0.0;\n        dest[5] = 2.0 / tb;\n        dest[6] = 0.0;\n        dest[7] = 0.0;\n\n        dest[8] = 0.0;\n        dest[9] = 0.0;\n        dest[10] = -2.0 / fn;\n        dest[11] = 0.0;\n\n        dest[12] = -(left + right) / rl;\n        dest[13] = -(top + bottom) / tb;\n        dest[14] = -(far + near) / fn;\n        dest[15] = 1.0;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4v(fmin, fmax, m) {\n        if (!m) {\n            m = math.mat4();\n        }\n\n        const fmin4 = [fmin[0], fmin[1], fmin[2], 0.0];\n        const fmax4 = [fmax[0], fmax[1], fmax[2], 0.0];\n\n        math.addVec4(fmax4, fmin4, tempMat1);\n        math.subVec4(fmax4, fmin4, tempMat2);\n\n        const t = 2.0 * fmin4[2];\n\n        const tempMat20 = tempMat2[0];\n        const tempMat21 = tempMat2[1];\n        const tempMat22 = tempMat2[2];\n\n        m[0] = t / tempMat20;\n        m[1] = 0.0;\n        m[2] = 0.0;\n        m[3] = 0.0;\n\n        m[4] = 0.0;\n        m[5] = t / tempMat21;\n        m[6] = 0.0;\n        m[7] = 0.0;\n\n        m[8] = tempMat1[0] / tempMat20;\n        m[9] = tempMat1[1] / tempMat21;\n        m[10] = -tempMat1[2] / tempMat22;\n        m[11] = -1.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = -t * fmax4[2] / tempMat22;\n        m[15] = 0.0;\n\n        return m;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n        dest[0] = (near * 2) / rl;\n        dest[1] = 0;\n        dest[2] = 0;\n        dest[3] = 0;\n        dest[4] = 0;\n        dest[5] = (near * 2) / tb;\n        dest[6] = 0;\n        dest[7] = 0;\n        dest[8] = (right + left) / rl;\n        dest[9] = (top + bottom) / tb;\n        dest[10] = -(far + near) / fn;\n        dest[11] = -1;\n        dest[12] = 0;\n        dest[13] = 0;\n        dest[14] = -(far * near * 2) / fn;\n        dest[15] = 0;\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method perspectiveMat4v\n     * @static\n     */\n    perspectiveMat4(fovyrad, aspectratio, znear, zfar, m) {\n        const pmin = [];\n        const pmax = [];\n\n        pmin[2] = znear;\n        pmax[2] = zfar;\n\n        pmax[1] = pmin[2] * Math.tan(fovyrad / 2.0);\n        pmin[1] = -pmax[1];\n\n        pmax[0] = pmax[1] * aspectratio;\n        pmin[0] = -pmax[0];\n\n        return math.frustumMat4v(pmin, pmax, m);\n    },\n\n    /**\n     * Transforms a three-element position by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint3(m, p, dest = math.vec3()) {\n\n        const x = p[0];\n        const y = p[1];\n        const z = p[2];\n\n        dest[0] = (m[0] * x) + (m[4] * y) + (m[8] * z) + m[12];\n        dest[1] = (m[1] * x) + (m[5] * y) + (m[9] * z) + m[13];\n        dest[2] = (m[2] * x) + (m[6] * y) + (m[10] * z) + m[14];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a homogeneous coordinate by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint4(m, v, dest = math.vec4()) {\n        dest[0] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3];\n        dest[1] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3];\n        dest[2] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3];\n        dest[3] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3];\n\n        return dest;\n    },\n\n\n    /**\n     * Transforms an array of three-element positions by a 4x4 matrix.\n     * @method transformPoints3\n     * @static\n     */\n    transformPoints3(m, points, points2) {\n        const result = points2 || [];\n        const len = points.length;\n        let p0;\n        let p1;\n        let p2;\n        let pi;\n\n        // cache values\n        const m0 = m[0];\n\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        let r;\n\n        for (let i = 0; i < len; ++i) {\n\n            // cache values\n            pi = points[i];\n\n            p0 = pi[0];\n            p1 = pi[1];\n            p2 = pi[2];\n\n            r = result[i] || (result[i] = [0, 0, 0]);\n\n            r[0] = (m0 * p0) + (m4 * p1) + (m8 * p2) + m12;\n            r[1] = (m1 * p0) + (m5 * p1) + (m9 * p2) + m13;\n            r[2] = (m2 * p0) + (m6 * p1) + (m10 * p2) + m14;\n            r[3] = (m3 * p0) + (m7 * p1) + (m11 * p2) + m15;\n        }\n\n        result.length = len;\n\n        return result;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions3\n     * @static\n     */\n    transformPositions3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 3) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions4\n     * @static\n     */\n    transformPositions4(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms a three-element vector by a 4x4 matrix.\n     * @method transformVec3\n     * @static\n     */\n    transformVec3(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        dest = dest || this.vec3();\n        dest[0] = (m[0] * v0) + (m[4] * v1) + (m[8] * v2);\n        dest[1] = (m[1] * v0) + (m[5] * v1) + (m[9] * v2);\n        dest[2] = (m[2] * v0) + (m[6] * v1) + (m[10] * v2);\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 matrix.\n     * @method transformVec4\n     * @static\n     */\n    transformVec4(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest = dest || math.vec4();\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the x-axis\n     *\n     * @method rotateVec3X\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3X(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0];\n        r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);\n        r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the y-axis\n     *\n     * @method rotateVec3Y\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Y(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);\n        r[1] = p[1];\n        r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the z-axis\n     *\n     * @method rotateVec3Z\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Z(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);\n        r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);\n        r[2] = p[2];\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 projection matrix.\n     *\n     * @method projectVec4\n     * @param {Number[]} p 3D View-space coordinate\n     * @param {Number[]} q 2D Projected coordinate\n     * @returns {Number[]} 2D Projected coordinate\n     * @static\n     */\n    projectVec4(p, q) {\n        const f = 1.0 / p[3];\n        q = q || math.vec2();\n        q[0] = v[0] * f;\n        q[1] = v[1] * f;\n        return q;\n    },\n\n    /**\n     * Unprojects a three-element vector.\n     *\n     * @method unprojectVec3\n     * @param {Number[]} p 3D Projected coordinate\n     * @param {Number[]} viewMat View matrix\n     * @returns {Number[]} projMat Projection matrix\n     * @static\n     */\n    unprojectVec3: ((() => {\n        const mat = new FloatArrayType(16);\n        const mat2 = new FloatArrayType(16);\n        const mat3 = new FloatArrayType(16);\n        return function (p, viewMat, projMat, q) {\n            return this.transformVec3(this.mulMat4(this.inverseMat4(viewMat, mat), this.inverseMat4(projMat, mat2), mat3), p, q)\n        };\n    }))(),\n\n    /**\n     * Linearly interpolates between two 3D vectors.\n     * @method lerpVec3\n     * @static\n     */\n    lerpVec3(t, t1, t2, p1, p2, dest) {\n        const result = dest || math.vec3();\n        const f = (t - t1) / (t2 - t1);\n        result[0] = p1[0] + (f * (p2[0] - p1[0]));\n        result[1] = p1[1] + (f * (p2[1] - p1[1]));\n        result[2] = p1[2] + (f * (p2[2] - p1[2]));\n        return result;\n    },\n\n\n    /**\n     * Flattens a two-dimensional array into a one-dimensional array.\n     *\n     * @method flatten\n     * @static\n     * @param {Array of Arrays} a A 2D array\n     * @returns Flattened 1D array\n     */\n    flatten(a) {\n\n        const result = [];\n\n        let i;\n        let leni;\n        let j;\n        let lenj;\n        let item;\n\n        for (i = 0, leni = a.length; i < leni; i++) {\n            item = a[i];\n            for (j = 0, lenj = item.length; j < lenj; j++) {\n                result.push(item[j]);\n            }\n        }\n\n        return result;\n    },\n\n\n    identityQuaternion(dest = math.vec4()) {\n        dest[0] = 0.0;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 1.0;\n        return dest;\n    },\n\n    /**\n     * Initializes a quaternion from Euler angles.\n     *\n     * @param {Number[]} euler The Euler angles.\n     * @param {String} order Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination quaternion, created by default.\n     * @returns {Number[]} The quaternion.\n     */\n    eulerToQuaternion(euler, order, dest = math.vec4()) {\n        // http://www.mathworks.com/matlabcentral/fileexchange/\n        // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n        //\tcontent/SpinCalc.m\n\n        const a = (euler[0] * math.DEGTORAD) / 2;\n        const b = (euler[1] * math.DEGTORAD) / 2;\n        const c = (euler[2] * math.DEGTORAD) / 2;\n\n        const c1 = Math.cos(a);\n        const c2 = Math.cos(b);\n        const c3 = Math.cos(c);\n        const s1 = Math.sin(a);\n        const s2 = Math.sin(b);\n        const s3 = Math.sin(c);\n\n        if (order === 'XYZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'ZYX') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'YZX') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'XZY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n        }\n\n        return dest;\n    },\n\n    mat4ToQuaternion(m, dest = math.vec4()) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = m[0];\n        const m12 = m[4];\n        const m13 = m[8];\n        const m21 = m[1];\n        const m22 = m[5];\n        const m23 = m[9];\n        const m31 = m[2];\n        const m32 = m[6];\n        const m33 = m[10];\n        let s;\n\n        const trace = m11 + m22 + m33;\n\n        if (trace > 0) {\n\n            s = 0.5 / Math.sqrt(trace + 1.0);\n\n            dest[3] = 0.25 / s;\n            dest[0] = (m32 - m23) * s;\n            dest[1] = (m13 - m31) * s;\n            dest[2] = (m21 - m12) * s;\n\n        } else if (m11 > m22 && m11 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\n            dest[3] = (m32 - m23) / s;\n            dest[0] = 0.25 * s;\n            dest[1] = (m12 + m21) / s;\n            dest[2] = (m13 + m31) / s;\n\n        } else if (m22 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\n            dest[3] = (m13 - m31) / s;\n            dest[0] = (m12 + m21) / s;\n            dest[1] = 0.25 * s;\n            dest[2] = (m23 + m32) / s;\n\n        } else {\n\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\n            dest[3] = (m21 - m12) / s;\n            dest[0] = (m13 + m31) / s;\n            dest[1] = (m23 + m32) / s;\n            dest[2] = 0.25 * s;\n        }\n\n        return dest;\n    },\n\n    vec3PairToQuaternion(u, v, dest = math.vec4()) {\n        const norm_u_norm_v = Math.sqrt(math.dotVec3(u, u) * math.dotVec3(v, v));\n        let real_part = norm_u_norm_v + math.dotVec3(u, v);\n\n        if (real_part < 0.00000001 * norm_u_norm_v) {\n\n            // If u and v are exactly opposite, rotate 180 degrees\n            // around an arbitrary orthogonal axis. Axis normalisation\n            // can happen later, when we normalise the quaternion.\n\n            real_part = 0.0;\n\n            if (Math.abs(u[0]) > Math.abs(u[2])) {\n\n                dest[0] = -u[1];\n                dest[1] = u[0];\n                dest[2] = 0;\n\n            } else {\n                dest[0] = 0;\n                dest[1] = -u[2];\n                dest[2] = u[1]\n            }\n\n        } else {\n\n            // Otherwise, build quaternion the standard way.\n            math.cross3Vec3(u, v, dest);\n        }\n\n        dest[3] = real_part;\n\n        return math.normalizeQuaternion(dest);\n    },\n\n    angleAxisToQuaternion(angleAxis, dest = math.vec4()) {\n        const halfAngle = angleAxis[3] / 2.0;\n        const fsin = Math.sin(halfAngle);\n        dest[0] = fsin * angleAxis[0];\n        dest[1] = fsin * angleAxis[1];\n        dest[2] = fsin * angleAxis[2];\n        dest[3] = Math.cos(halfAngle);\n        return dest;\n    },\n\n    quaternionToEuler: ((() => {\n        const mat = new FloatArrayType(16);\n        return (q, order, dest) => {\n            dest = dest || math.vec3();\n            math.quaternionToRotationMat4(q, mat);\n            math.mat4ToEuler(mat, order, dest);\n            return dest;\n        };\n    }))(),\n\n    mulQuaternions(p, q, dest = math.vec4()) {\n        const p0 = p[0];\n        const p1 = p[1];\n        const p2 = p[2];\n        const p3 = p[3];\n        const q0 = q[0];\n        const q1 = q[1];\n        const q2 = q[2];\n        const q3 = q[3];\n        dest[0] = p3 * q0 + p0 * q3 + p1 * q2 - p2 * q1;\n        dest[1] = p3 * q1 + p1 * q3 + p2 * q0 - p0 * q2;\n        dest[2] = p3 * q2 + p2 * q3 + p0 * q1 - p1 * q0;\n        dest[3] = p3 * q3 - p0 * q0 - p1 * q1 - p2 * q2;\n        return dest;\n    },\n\n    vec3ApplyQuaternion(q, vec, dest = math.vec3()) {\n        const x = vec[0];\n        const y = vec[1];\n        const z = vec[2];\n\n        const qx = q[0];\n        const qy = q[1];\n        const qz = q[2];\n        const qw = q[3];\n\n        // calculate quat * vector\n\n        const ix = qw * x + qy * z - qz * y;\n        const iy = qw * y + qz * x - qx * z;\n        const iz = qw * z + qx * y - qy * x;\n        const iw = -qx * x - qy * y - qz * z;\n\n        // calculate result * inverse quat\n\n        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n        return dest;\n    },\n\n    quaternionToMat4(q, dest) {\n\n        dest = math.identityMat4(dest);\n\n        const q0 = q[0];  //x\n        const q1 = q[1];  //y\n        const q2 = q[2];  //z\n        const q3 = q[3];  //w\n\n        const tx = 2.0 * q0;\n        const ty = 2.0 * q1;\n        const tz = 2.0 * q2;\n\n        const twx = tx * q3;\n        const twy = ty * q3;\n        const twz = tz * q3;\n\n        const txx = tx * q0;\n        const txy = ty * q0;\n        const txz = tz * q0;\n\n        const tyy = ty * q1;\n        const tyz = tz * q1;\n        const tzz = tz * q2;\n\n        dest[0] = 1.0 - (tyy + tzz);\n        dest[1] = txy + twz;\n        dest[2] = txz - twy;\n\n        dest[4] = txy - twz;\n        dest[5] = 1.0 - (txx + tzz);\n        dest[6] = tyz + twx;\n\n        dest[8] = txz + twy;\n        dest[9] = tyz - twx;\n\n        dest[10] = 1.0 - (txx + tyy);\n\n        return dest;\n    },\n\n    quaternionToRotationMat4(q, m) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        m[0] = 1 - (yy + zz);\n        m[4] = xy - wz;\n        m[8] = xz + wy;\n\n        m[1] = xy + wz;\n        m[5] = 1 - (xx + zz);\n        m[9] = yz - wx;\n\n        m[2] = xz - wy;\n        m[6] = yz + wx;\n        m[10] = 1 - (xx + yy);\n\n        // last column\n        m[3] = 0;\n        m[7] = 0;\n        m[11] = 0;\n\n        // bottom row\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n\n        return m;\n    },\n\n    normalizeQuaternion(q, dest = q) {\n        const len = math.lenVec4([q[0], q[1], q[2], q[3]]);\n        dest[0] = q[0] / len;\n        dest[1] = q[1] / len;\n        dest[2] = q[2] / len;\n        dest[3] = q[3] / len;\n        return dest;\n    },\n\n    conjugateQuaternion(q, dest = q) {\n        dest[0] = -q[0];\n        dest[1] = -q[1];\n        dest[2] = -q[2];\n        dest[3] = q[3];\n        return dest;\n    },\n\n    inverseQuaternion(q, dest) {\n        return math.normalizeQuaternion(math.conjugateQuaternion(q, dest));\n    },\n\n    quaternionToAngleAxis(q, angleAxis = math.vec4()) {\n        q = math.normalizeQuaternion(q, tempVec4);\n        const q3 = q[3];\n        const angle = 2 * Math.acos(q3);\n        const s = Math.sqrt(1 - q3 * q3);\n        if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt\n            angleAxis[0] = q[0];\n            angleAxis[1] = q[1];\n            angleAxis[2] = q[2];\n        } else {\n            angleAxis[0] = q[0] / s;\n            angleAxis[1] = q[1] / s;\n            angleAxis[2] = q[2] / s;\n        }\n        angleAxis[3] = angle; // * 57.295779579;\n        return angleAxis;\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Boundaries\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Returns a new, uninitialized 3D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB3(values) {\n        return new FloatArrayType(values || 6);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB2(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB3(values) {\n        return new FloatArrayType(values || 32);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB2(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /** Returns a new 3D bounding sphere */\n    Sphere3(x, y, z, r) {\n        return new FloatArrayType([x, y, z, r]);\n    },\n\n    /**\n     * Transforms an OBB3 by a 4x4 matrix.\n     *\n     * @private\n     */\n    transformOBB3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /** Returns true if the first AABB contains the second AABB.\n     * @param aabb1\n     * @param aabb2\n     * @returns {boolean}\n     */\n    containsAABB3: function (aabb1, aabb2) {\n        const result = (\n            aabb1[0] <= aabb2[0] && aabb2[3] <= aabb1[3] &&\n            aabb1[1] <= aabb2[1] && aabb2[4] <= aabb1[4] &&\n            aabb1[2] <= aabb2[2] && aabb2[5] <= aabb1[5]);\n        return result;\n    },\n\n    /**\n     * Gets the diagonal size of an AABB3 given as minima and maxima.\n     *\n     * @private\n     */\n    getAABB3Diag: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return aabb => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            math.subVec3(max, min, tempVec3);\n\n            return Math.abs(math.lenVec3(tempVec3));\n        };\n    }))(),\n\n    /**\n     * Get a diagonal boundary size that is symmetrical about the given point.\n     *\n     * @private\n     */\n    getAABB3DiagPoint: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return (aabb, p) => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            const diagVec = math.subVec3(max, min, tempVec3);\n\n            const xneg = p[0] - aabb[0];\n            const xpos = aabb[3] - p[0];\n            const yneg = p[1] - aabb[1];\n            const ypos = aabb[4] - p[1];\n            const zneg = p[2] - aabb[2];\n            const zpos = aabb[5] - p[2];\n\n            diagVec[0] += (xneg > xpos) ? xneg : xpos;\n            diagVec[1] += (yneg > ypos) ? yneg : ypos;\n            diagVec[2] += (zneg > zpos) ? zneg : zpos;\n\n            return Math.abs(math.lenVec3(diagVec));\n        };\n    }))(),\n\n    /**\n     * Gets the center of an AABB.\n     *\n     * @private\n     */\n    getAABB3Center(aabb, dest) {\n        const r = dest || math.vec3();\n\n        r[0] = (aabb[0] + aabb[3]) / 2;\n        r[1] = (aabb[1] + aabb[4]) / 2;\n        r[2] = (aabb[2] + aabb[5]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Gets the center of a 2D AABB.\n     *\n     * @private\n     */\n    getAABB2Center(aabb, dest) {\n        const r = dest || math.vec2();\n\n        r[0] = (aabb[2] + aabb[0]) / 2;\n        r[1] = (aabb[3] + aabb[1]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.\n     * Creates new AABB if none supplied.\n     *\n     * @private\n     */\n    collapseAABB3(aabb = math.AABB3()) {\n        aabb[0] = math.MAX_DOUBLE;\n        aabb[1] = math.MAX_DOUBLE;\n        aabb[2] = math.MAX_DOUBLE;\n        aabb[3] = -math.MAX_DOUBLE;\n        aabb[4] = -math.MAX_DOUBLE;\n        aabb[5] = -math.MAX_DOUBLE;\n\n        return aabb;\n    },\n\n    /**\n     * Converts an axis-aligned 3D boundary into an oriented boundary consisting of\n     * an array of eight 3D positions, one for each corner of the boundary.\n     *\n     * @private\n     */\n    AABB3ToOBB3(aabb, obb = math.OBB3()) {\n        obb[0] = aabb[0];\n        obb[1] = aabb[1];\n        obb[2] = aabb[2];\n        obb[3] = 1;\n\n        obb[4] = aabb[3];\n        obb[5] = aabb[1];\n        obb[6] = aabb[2];\n        obb[7] = 1;\n\n        obb[8] = aabb[3];\n        obb[9] = aabb[4];\n        obb[10] = aabb[2];\n        obb[11] = 1;\n\n        obb[12] = aabb[0];\n        obb[13] = aabb[4];\n        obb[14] = aabb[2];\n        obb[15] = 1;\n\n        obb[16] = aabb[0];\n        obb[17] = aabb[1];\n        obb[18] = aabb[5];\n        obb[19] = 1;\n\n        obb[20] = aabb[3];\n        obb[21] = aabb[1];\n        obb[22] = aabb[5];\n        obb[23] = 1;\n\n        obb[24] = aabb[3];\n        obb[25] = aabb[4];\n        obb[26] = aabb[5];\n        obb[27] = 1;\n\n        obb[28] = aabb[0];\n        obb[29] = aabb[4];\n        obb[30] = aabb[5];\n        obb[31] = 1;\n\n        return obb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    positions3ToAABB3: ((() => {\n\n        const p = new FloatArrayType(3);\n\n        return (positions, aabb, positionsDecodeMatrix) => {\n            aabb = aabb || math.AABB3();\n\n            let xmin = math.MAX_DOUBLE;\n            let ymin = math.MAX_DOUBLE;\n            let zmin = math.MAX_DOUBLE;\n            let xmax = -math.MAX_DOUBLE;\n            let ymax = -math.MAX_DOUBLE;\n            let zmax = -math.MAX_DOUBLE;\n\n            let x;\n            let y;\n            let z;\n\n            for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                if (positionsDecodeMatrix) {\n\n                    p[0] = positions[i + 0];\n                    p[1] = positions[i + 1];\n                    p[2] = positions[i + 2];\n\n                    math.decompressPosition(p, positionsDecodeMatrix, p);\n\n                    x = p[0];\n                    y = p[1];\n                    z = p[2];\n\n                } else {\n                    x = positions[i + 0];\n                    y = positions[i + 1];\n                    z = positions[i + 2];\n                }\n\n                if (x < xmin) {\n                    xmin = x;\n                }\n\n                if (y < ymin) {\n                    ymin = y;\n                }\n\n                if (z < zmin) {\n                    zmin = z;\n                }\n\n                if (x > xmax) {\n                    xmax = x;\n                }\n\n                if (y > ymax) {\n                    ymax = y;\n                }\n\n                if (z > zmax) {\n                    zmax = z;\n                }\n            }\n\n            aabb[0] = xmin;\n            aabb[1] = ymin;\n            aabb[2] = zmin;\n            aabb[3] = xmax;\n            aabb[4] = ymax;\n            aabb[5] = zmax;\n\n            return aabb;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    OBB3ToAABB3(obb, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = -math.MAX_DOUBLE;\n        let ymax = -math.MAX_DOUBLE;\n        let zmax = -math.MAX_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = obb.length; i < len; i += 4) {\n\n            x = obb[i + 0];\n            y = obb[i + 1];\n            z = obb[i + 2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToAABB3(points, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = -math.MAX_DOUBLE;\n        let ymax = -math.MAX_DOUBLE;\n        let zmax = -math.MAX_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = points.length; i < len; i++) {\n\n            x = points[i][0];\n            y = points[i][1];\n            z = points[i][2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToSphere3: ((() => {\n\n        const tempVec3 = new FloatArrayType(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const numPoints = points.length;\n\n            for (i = 0; i < numPoints; i++) {\n                x += points[i][0];\n                y += points[i][1];\n                z += points[i][2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < numPoints; i++) {\n\n                dist = Math.abs(math.lenVec3(math.subVec3(points[i], sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D positions.\n     *\n     * @private\n     */\n    positions3ToSphere3: ((() => {\n\n        const tempVec3a = new FloatArrayType(3);\n        const tempVec3b = new FloatArrayType(3);\n\n        return (positions, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPositions = positions.length;\n            let radius = 0;\n\n            for (i = 0; i < lenPositions; i += 3) {\n                x += positions[i];\n                y += positions[i + 1];\n                z += positions[i + 2];\n            }\n\n            const numPositions = lenPositions / 3;\n\n            sphere[0] = x / numPositions;\n            sphere[1] = y / numPositions;\n            sphere[2] = z / numPositions;\n\n            let dist;\n\n            for (i = 0; i < lenPositions; i += 3) {\n\n                tempVec3a[0] = positions[i];\n                tempVec3a[1] = positions[i + 1];\n                tempVec3a[2] = positions[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(tempVec3a, sphere, tempVec3b)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    OBB3ToSphere3: ((() => {\n\n        const point = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPoints = points.length;\n            const numPoints = lenPoints / 4;\n\n            for (i = 0; i < lenPoints; i += 4) {\n                x += points[i + 0];\n                y += points[i + 1];\n                z += points[i + 2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < lenPoints; i += 4) {\n\n                point[0] = points[i + 0];\n                point[1] = points[i + 1];\n                point[2] = points[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(point, sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Gets the center of a bounding sphere.\n     *\n     * @private\n     */\n    getSphere3Center(sphere, dest = math.vec3()) {\n        dest[0] = sphere[0];\n        dest[1] = sphere[1];\n        dest[2] = sphere[2];\n\n        return dest;\n    },\n\n    /**\n     * Expands the first axis-aligned 3D boundary to enclose the second, if required.\n     *\n     * @private\n     */\n    expandAABB3(aabb1, aabb2) {\n\n        if (aabb1[0] > aabb2[0]) {\n            aabb1[0] = aabb2[0];\n        }\n\n        if (aabb1[1] > aabb2[1]) {\n            aabb1[1] = aabb2[1];\n        }\n\n        if (aabb1[2] > aabb2[2]) {\n            aabb1[2] = aabb2[2];\n        }\n\n        if (aabb1[3] < aabb2[3]) {\n            aabb1[3] = aabb2[3];\n        }\n\n        if (aabb1[4] < aabb2[4]) {\n            aabb1[4] = aabb2[4];\n        }\n\n        if (aabb1[5] < aabb2[5]) {\n            aabb1[5] = aabb2[5];\n        }\n\n        return aabb1;\n    },\n\n    /**\n     * Expands an axis-aligned 3D boundary to enclose the given point, if needed.\n     *\n     * @private\n     */\n    expandAABB3Point3(aabb, p) {\n\n        if (aabb[0] > p[0]) {\n            aabb[0] = p[0];\n        }\n\n        if (aabb[1] > p[1]) {\n            aabb[1] = p[1];\n        }\n\n        if (aabb[2] > p[2]) {\n            aabb[2] = p[2];\n        }\n\n        if (aabb[3] < p[0]) {\n            aabb[3] = p[0];\n        }\n\n        if (aabb[4] < p[1]) {\n            aabb[4] = p[1];\n        }\n\n        if (aabb[5] < p[2]) {\n            aabb[5] = p[2];\n        }\n\n        return aabb;\n    }\n};\n\nexport {math};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/lib/math.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 192,
    "kind": "variable",
    "name": "doublePrecision",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~doublePrecision",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 193,
    "kind": "variable",
    "name": "FloatArrayType",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~FloatArrayType",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 194,
    "kind": "variable",
    "name": "tempMat1",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~tempMat1",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 195,
    "kind": "variable",
    "name": "tempMat2",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~tempMat2",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 196,
    "kind": "variable",
    "name": "tempVec4",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~tempVec4",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 197,
    "kind": "variable",
    "name": "math",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~math",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/lib/math.js",
    "importStyle": "{math}",
    "description": "",
    "lineNumber": 13,
    "ignore": true,
    "type": {
      "types": [
        "{\"MIN_DOUBLE\": *, \"MAX_DOUBLE\": *, \"DEGTORAD\": number, \"RADTODEG\": number, \"vec2\": function, \"vec3\": function, \"vec4\": function, \"mat3\": function, \"mat3ToMat4\": function, \"mat4\": function, \"mat4ToMat3\": function, \"createUUID\": *, \"clamp\": function, \"fmod\": function, \"negateVec4\": function, \"addVec4\": function, \"addVec4Scalar\": function, \"addVec3\": function, \"addVec3Scalar\": function, \"subVec4\": function, \"subVec3\": function, \"subVec2\": function, \"subVec4Scalar\": function, \"subScalarVec4\": function, \"mulVec4\": function, \"mulVec4Scalar\": function, \"mulVec3Scalar\": function, \"mulVec2Scalar\": function, \"divVec3\": function, \"divVec4\": function, \"divScalarVec3\": function, \"divVec3Scalar\": function, \"divVec4Scalar\": function, \"divScalarVec4\": function, \"dotVec4\": function, \"cross3Vec4\": function, \"cross3Vec3\": function, \"sqLenVec4\": function, \"lenVec4\": function, \"dotVec3\": function, \"dotVec2\": function, \"sqLenVec3\": function, \"sqLenVec2\": function, \"lenVec3\": function, \"distVec3\": *, \"lenVec2\": function, \"distVec2\": *, \"rcpVec3\": function, \"normalizeVec4\": function, \"normalizeVec3\": function, \"normalizeVec2\": function, \"angleVec3\": function, \"vec3FromMat4Scale\": *, \"vecToArray\": *, \"xyzArrayToObject\": function, \"xyzObjectToArray\": function, \"dupMat4\": function, \"mat4To3\": function, \"m4s\": function, \"setMat4ToZeroes\": function, \"setMat4ToOnes\": function, \"diagonalMat4v\": function, \"diagonalMat4c\": function, \"diagonalMat4s\": function, \"identityMat4\": function, \"identityMat3\": function, \"isIdentityMat4\": function, \"negateMat4\": function, \"addMat4\": function, \"addMat4Scalar\": function, \"addScalarMat4\": function, \"subMat4\": function, \"subMat4Scalar\": function, \"subScalarMat4\": function, \"mulMat4\": function, \"mulMat3\": function, \"mulMat4Scalar\": function, \"mulMat4v4\": function, \"transposeMat4\": function, \"transposeMat3\": function, \"determinantMat4\": function, \"inverseMat4\": function, \"traceMat4\": function, \"translationMat4v\": function, \"translationMat3v\": function, \"translationMat4c\": *, \"translationMat4s\": function, \"translateMat4v\": function, \"OLDtranslateMat4c\": function, \"translateMat4c\": function, \"rotationMat4v\": function, \"rotationMat4c\": function, \"scalingMat4v\": function, \"scalingMat3v\": function, \"scalingMat4c\": *, \"scaleMat4c\": function, \"scaleMat4v\": function, \"scalingMat4s\": function, \"rotationTranslationMat4\": function, \"mat4ToEuler\": function, \"composeMat4\": function, \"decomposeMat4\": *, \"lookAtMat4v\": function, \"lookAtMat4c\": function, \"orthoMat4c\": function, \"frustumMat4v\": function, \"frustumMat4\": function, \"perspectiveMat4\": function, \"transformPoint3\": function, \"transformPoint4\": function, \"transformPoints3\": function, \"transformPositions3\": function, \"transformPositions4\": function, \"transformVec3\": function, \"transformVec4\": function, \"rotateVec3X\": function, \"rotateVec3Y\": function, \"rotateVec3Z\": function, \"projectVec4\": function, \"unprojectVec3\": *, \"lerpVec3\": function, \"flatten\": function, \"identityQuaternion\": function, \"eulerToQuaternion\": function, \"mat4ToQuaternion\": function, \"vec3PairToQuaternion\": function, \"angleAxisToQuaternion\": function, \"quaternionToEuler\": *, \"mulQuaternions\": function, \"vec3ApplyQuaternion\": function, \"quaternionToMat4\": function, \"quaternionToRotationMat4\": function, \"normalizeQuaternion\": function, \"conjugateQuaternion\": function, \"inverseQuaternion\": function, \"quaternionToAngleAxis\": function, \"AABB3\": function, \"AABB2\": function, \"OBB3\": function, \"OBB2\": function, \"Sphere3\": function, \"transformOBB3\": function, \"containsAABB3\": *, \"getAABB3Diag\": *, \"getAABB3DiagPoint\": *, \"getAABB3Center\": function, \"getAABB2Center\": function, \"collapseAABB3\": function, \"AABB3ToOBB3\": function, \"positions3ToAABB3\": *, \"OBB3ToAABB3\": function, \"points3ToAABB3\": function, \"points3ToSphere3\": *, \"positions3ToSphere3\": *, \"OBB3ToSphere3\": *, \"getSphere3Center\": function, \"expandAABB3\": function, \"expandAABB3Point3\": function}"
      ]
    }
  },
  {
    "__docId__": 198,
    "kind": "file",
    "name": "src/parsers/parseGLTFIntoXKTModel.js",
    "content": "import {utils} from \"../XKTModel/lib/utils.js\";\nimport {math} from \"../lib/math.js\";\n\n// HACK: Allows node.js to find atob()\nlet atob2;\nif (typeof atob === 'undefined') {\n    const atob = require('atob');\n    atob2 = atob;\n} else {\n    atob2 = atob;\n}\n\nconst WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n};\n\nconst WEBGL_TYPE_SIZES = {\n    'SCALAR': 1,\n    'VEC2': 2,\n    'VEC3': 3,\n    'VEC4': 4,\n    'MAT2': 4,\n    'MAT3': 9,\n    'MAT4': 16\n};\n\n/**\n * @desc Parses glTF JSON into an {@link XKTModel}.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then load a glTF model into it.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#parsers_glTF_Duplex)]\n *\n * ````javascript\n * utils.loadJSON(\"./models/gltf/duplex/scene.gltf\", async (json) => {\n *\n *     const xktModel = new XKTModel();\n *\n *     parseGLTFIntoXKTModel(json, xktModel);\n *\n *     xktModel.finalize();\n * });\n * ````\n *\n * @param {Object} gltf The glTF JSON.\n * @param {XKTModel} xktModel XKTModel to parse into\n * @param {function} getAttachment Callback through which to fetch attachments, if the glTF has them.\n */\nasync function parseGLTFIntoXKTModel(gltf, xktModel, getAttachment) {\n    const parsingCtx = {\n        gltf: gltf,\n        getAttachment: getAttachment || (() => {\n            throw new Error('You must define getAttachment() method to convert glTF with external resources')\n        }),\n        xktModel: xktModel,\n        geometryCreated: {},\n        nextGeometryId: 0,\n        nextMeshId: 0,\n        nextDefaultEntityId: 0\n    };\n    await parseBuffers(parsingCtx);\n    parseBufferViews(parsingCtx);\n    freeBuffers(parsingCtx);\n    parseMaterials(parsingCtx);\n    parseDefaultScene(parsingCtx);\n}\n\nasync function parseBuffers(parsingCtx) {  // Parses geometry buffers into temporary  \"_buffer\" Unit8Array properties on the glTF \"buffer\" elements\n    const buffers = parsingCtx.gltf.buffers;\n    if (buffers) {\n        await Promise.all(buffers.map(buffer => parseBuffer(parsingCtx, buffer)));\n    }\n}\n\nasync function parseBuffer(parsingCtx, bufferInfo) {\n    const uri = bufferInfo.uri;\n    if (!uri) {\n        throw new Error('gltf/handleBuffer missing uri in ' + JSON.stringify(bufferInfo));\n    }\n    bufferInfo._buffer = await parseArrayBuffer(parsingCtx, uri);\n}\n\nasync function parseArrayBuffer(parsingCtx, uri) {\n    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/; // Check for data: URI\n    const dataUriRegexResult = uri.match(dataUriRegex);\n    if (dataUriRegexResult) { // Safari can't handle data URIs through XMLHttpRequest\n        const isBase64 = !!dataUriRegexResult[2];\n        let data = dataUriRegexResult[3];\n        data = decodeURIComponent(data);\n        if (isBase64) {\n            data = atob2(data);\n        }\n        const buffer = new ArrayBuffer(data.length);\n        const view = new Uint8Array(buffer);\n        for (let i = 0; i < data.length; i++) {\n            view[i] = data.charCodeAt(i);\n        }\n        return buffer;\n    } else { // Uri is a path to a file\n        const arraybuffer = await parsingCtx.getAttachment(uri);\n        return arraybuffer;\n    }\n}\n\nfunction parseBufferViews(parsingCtx) { // Parses our temporary \"_buffer\" properties into \"_buffer\" properties on glTF \"bufferView\" elements\n    const bufferViewsInfo = parsingCtx.gltf.bufferViews;\n    if (bufferViewsInfo) {\n        for (let i = 0, len = bufferViewsInfo.length; i < len; i++) {\n            parseBufferView(parsingCtx, bufferViewsInfo[i]);\n        }\n    }\n}\n\nfunction parseBufferView(parsingCtx, bufferViewInfo) {\n    const buffer = parsingCtx.gltf.buffers[bufferViewInfo.buffer];\n    bufferViewInfo._typedArray = null;\n    const byteLength = bufferViewInfo.byteLength || 0;\n    const byteOffset = bufferViewInfo.byteOffset || 0;\n    bufferViewInfo._buffer = buffer._buffer.slice(byteOffset, byteOffset + byteLength);\n}\n\nfunction freeBuffers(parsingCtx) { // Deletes the \"_buffer\" properties from the glTF \"buffer\" elements, to save memory\n    const buffers = parsingCtx.gltf.buffers;\n    if (buffers) {\n        for (let i = 0, len = buffers.length; i < len; i++) {\n            buffers[i]._buffer = null;\n        }\n    }\n}\n\nfunction parseMaterials(parsingCtx) {\n    const materialsInfo = parsingCtx.gltf.materials;\n    if (materialsInfo) {\n        for (let i = 0, len = materialsInfo.length; i < len; i++) {\n            const materialInfo = materialsInfo[i];\n            const material = parseMaterial(parsingCtx, materialInfo);\n            materialInfo._materialData = material;\n        }\n    }\n}\n\nfunction parseMaterial(parsingCtx, materialInfo) { // Attempts to extract an RGBA color for a glTF material\n    const material = {\n        color: new Float32Array([1, 1, 1]),\n        opacity: 1.0,\n        metallic: 0,\n        roughness: 1\n    };\n    const extensions = materialInfo.extensions;\n    if (extensions) {\n        const specularPBR = extensions[\"KHR_materials_pbrSpecularGlossiness\"];\n        if (specularPBR) {\n            const diffuseFactor = specularPBR.diffuseFactor;\n            if (diffuseFactor !== null && diffuseFactor !== undefined) {\n                material.color[0] = diffuseFactor[0];\n                material.color[1] = diffuseFactor[1];\n                material.color[2] = diffuseFactor[2];\n            }\n        }\n        const common = extensions[\"KHR_materials_common\"];\n        if (common) {\n            const technique = common.technique;\n            const values = common.values || {};\n            const blinn = technique === \"BLINN\";\n            const phong = technique === \"PHONG\";\n            const lambert = technique === \"LAMBERT\";\n            const diffuse = values.diffuse;\n            if (diffuse && (blinn || phong || lambert)) {\n                if (!utils.isString(diffuse)) {\n                    material.color[0] = diffuse[0];\n                    material.color[1] = diffuse[1];\n                    material.color[2] = diffuse[2];\n                }\n            }\n            const transparency = values.transparency;\n            if (transparency !== null && transparency !== undefined) {\n                material.opacity = transparency;\n            }\n            const transparent = values.transparent;\n            if (transparent !== null && transparent !== undefined) {\n                material.opacity = transparent;\n            }\n        }\n    }\n    const metallicPBR = materialInfo.pbrMetallicRoughness;\n    if (metallicPBR) {\n        const baseColorFactor = metallicPBR.baseColorFactor;\n        if (baseColorFactor) {\n            material.color[0] = baseColorFactor[0];\n            material.color[1] = baseColorFactor[1];\n            material.color[2] = baseColorFactor[2];\n            material.opacity = baseColorFactor[3];\n        }\n        const metallicFactor = metallicPBR.metallicFactor;\n        if (metallicFactor !== null && metallicFactor !== undefined) {\n            material.metallic = metallicFactor;\n        }\n        const roughnessFactor = metallicPBR.roughnessFactor;\n        if (roughnessFactor !== null && roughnessFactor !== undefined) {\n            material.roughness = roughnessFactor;\n        }\n    }\n    return material;\n}\n\nfunction parseDefaultScene(parsingCtx) {\n    const scene = parsingCtx.gltf.scene || 0;\n    const defaultSceneInfo = parsingCtx.gltf.scenes[scene];\n    if (!defaultSceneInfo) {\n        throw new Error(\"glTF has no default scene\");\n    }\n    parseScene(parsingCtx, defaultSceneInfo);\n}\n\n\nfunction parseScene(parsingCtx, sceneInfo) {\n    const nodes = sceneInfo.nodes;\n    if (!nodes) {\n        return;\n    }\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        const glTFNode = parsingCtx.gltf.nodes[nodes[i]];\n        if (glTFNode) {\n            parseNode(parsingCtx, glTFNode, null);\n        }\n    }\n}\n\nlet count = 0;\n\nfunction parseNode(parsingCtx, glTFNode, matrix) {\n\n    const gltf = parsingCtx.gltf;\n    const xktModel = parsingCtx.xktModel;\n\n    let localMatrix;\n\n    if (glTFNode.matrix) {\n        localMatrix = glTFNode.matrix;\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, math.mat4());\n        } else {\n            matrix = localMatrix;\n        }\n    }\n\n    if (glTFNode.translation) {\n        localMatrix = math.translationMat4v(glTFNode.translation);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, localMatrix);\n        } else {\n            matrix = localMatrix;\n        }\n    }\n\n    if (glTFNode.rotation) {\n        localMatrix = math.quaternionToMat4(glTFNode.rotation);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, localMatrix);\n        } else {\n            matrix = localMatrix;\n        }\n    }\n\n    if (glTFNode.scale) {\n        localMatrix = math.scalingMat4v(glTFNode.scale);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, localMatrix);\n        } else {\n            matrix = localMatrix;\n        }\n    }\n\n    const gltfMeshId = glTFNode.mesh;\n\n    if (gltfMeshId !== undefined) {\n\n        const meshInfo = gltf.meshes[gltfMeshId];\n\n        if (meshInfo) {\n\n            const numPrimitivesInMesh = meshInfo.primitives.length;\n\n            if (numPrimitivesInMesh > 0) {\n\n                const xktMeshIds = [];\n\n                for (let i = 0; i < numPrimitivesInMesh; i++) {\n\n                    const primitiveInfo = meshInfo.primitives[i];\n                    const materialIndex = primitiveInfo.material;\n                    const materialInfo = (materialIndex !== null && materialIndex !== undefined) ? gltf.materials[materialIndex] : null;\n                    const color = materialInfo ? materialInfo._materialData.color : new Float32Array([1.0, 1.0, 1.0, 1.0]);\n                    const opacity = materialInfo ? materialInfo._materialData.opacity : 1.0;\n                    const metallic = materialInfo ? materialInfo._materialData.metallic : 0.0;\n                    const roughness = materialInfo ? materialInfo._materialData.roughness : 1.0;\n\n                    const xktGeometryId = createPrimitiveGeometryHash(primitiveInfo);\n\n                    if (!parsingCtx.geometryCreated[xktGeometryId]) {\n\n                        const geometryArrays = {};\n\n                        parsePrimitiveGeometry(parsingCtx, primitiveInfo, geometryArrays);\n\n                        const colors = geometryArrays.colors;\n\n                        let colorsCompressed;\n\n                        if (geometryArrays.colors) {\n                            colorsCompressed = [];\n                            for (let j = 0, lenj = colors.length; j < lenj; j += 4) {\n                                colorsCompressed.push(Math.floor(colors[j + 0] * 255));\n                                colorsCompressed.push(Math.floor(colors[j + 1] * 255));\n                                colorsCompressed.push(Math.floor(colors[j + 2] * 255));\n                            }\n                        }\n\n                        xktModel.createGeometry({\n                            geometryId: xktGeometryId,\n                            primitiveType: geometryArrays.primitive,\n                            positions: geometryArrays.positions,\n                            normals: geometryArrays.normals,\n                            colorsCompressed: colorsCompressed,\n                            indices: geometryArrays.indices\n                        });\n\n                        parsingCtx.geometryCreated[xktGeometryId] = true;\n                    }\n\n                    const xktMeshId = parsingCtx.nextMeshId++;\n\n                    xktModel.createMesh({\n                        meshId: xktMeshId,\n                        geometryId: xktGeometryId,\n                        matrix: matrix ? matrix.slice() : math.identityMat4(),\n                        color: color,\n                        opacity: opacity,\n                        metallic: metallic,\n                        roughness: roughness\n                    });\n\n                    xktMeshIds.push(xktMeshId);\n                }\n\n                const xktEntityId = glTFNode.name || (\"entity\" + parsingCtx.nextDefaultEntityId++);\n\n                xktModel.createEntity({\n                    entityId: xktEntityId,\n                    meshIds: xktMeshIds\n                });\n            }\n        }\n    }\n\n    if (glTFNode.children) {\n        const children = glTFNode.children;\n        for (let i = 0, len = children.length; i < len; i++) {\n            const childNodeIdx = children[i];\n            const childGLTFNode = gltf.nodes[childNodeIdx];\n            if (!childGLTFNode) {\n                console.warn('Node not found: ' + i);\n                continue;\n            }\n            parseNode(parsingCtx, childGLTFNode, matrix);\n        }\n    }\n}\n\nfunction createPrimitiveGeometryHash(primitiveInfo) {\n    const attributes = primitiveInfo.attributes;\n    if (!attributes) {\n        return \"empty\";\n    }\n    return [\n        primitiveInfo.mode,\n        (primitiveInfo.indices !== null && primitiveInfo.indices !== undefined) ? primitiveInfo.indices : \"-\",\n        (primitiveInfo.positions !== null && primitiveInfo.positions !== undefined) ? primitiveInfo.positions : \"-\",\n        (primitiveInfo.normals !== null && primitiveInfo.normals !== undefined) ? primitiveInfo.normals : \"-\",\n        (primitiveInfo.colors !== null && primitiveInfo.colors !== undefined) ? primitiveInfo.colors : \"-\"\n    ].join(\";\");\n}\n\nfunction parsePrimitiveGeometry(parsingCtx, primitiveInfo, geometryArrays) {\n    const attributes = primitiveInfo.attributes;\n    if (!attributes) {\n        return;\n    }\n    switch (primitiveInfo.mode) {\n        case 0: // POINTS\n            geometryArrays.primitive = \"points\";\n            break;\n        case 1: // LINES\n            geometryArrays.primitive = \"lines\";\n            break;\n        case 2: // LINE_LOOP\n            // TODO: convert\n            geometryArrays.primitive = \"lines\";\n            break;\n        case 3: // LINE_STRIP\n            // TODO: convert\n            geometryArrays.primitive = \"lines\";\n            break;\n        case 4: // TRIANGLES\n            geometryArrays.primitive = \"triangles\";\n            break;\n        case 5: // TRIANGLE_STRIP\n            // TODO: convert\n            geometryArrays.primitive = \"triangles\";\n            break;\n        case 6: // TRIANGLE_FAN\n            // TODO: convert\n            geometryArrays.primitive = \"triangles\";\n            break;\n    }\n    const accessors = parsingCtx.gltf.accessors;\n    const indicesIndex = primitiveInfo.indices;\n    if (indicesIndex !== null && indicesIndex !== undefined) {\n        const accessorInfo = accessors[indicesIndex];\n        geometryArrays.indices = parseAccessorTypedArray(parsingCtx, accessorInfo);\n    }\n    const positionsIndex = attributes.POSITION;\n    if (positionsIndex !== null && positionsIndex !== undefined) {\n        const accessorInfo = accessors[positionsIndex];\n        geometryArrays.positions = parseAccessorTypedArray(parsingCtx, accessorInfo);\n    }\n    const normalsIndex = attributes.NORMAL;\n    if (normalsIndex !== null && normalsIndex !== undefined) {\n        const accessorInfo = accessors[normalsIndex];\n        geometryArrays.normals = parseAccessorTypedArray(parsingCtx, accessorInfo);\n    }\n    const colorsIndex = attributes.COLOR_0;\n    if (colorsIndex !== null && colorsIndex !== undefined) {\n        const accessorInfo = accessors[colorsIndex];\n        geometryArrays.colors = parseAccessorTypedArray(parsingCtx, accessorInfo);\n    }\n}\n\nfunction parseAccessorTypedArray(parsingCtx, accessorInfo) {\n    const bufferView = parsingCtx.gltf.bufferViews[accessorInfo.bufferView];\n    const itemSize = WEBGL_TYPE_SIZES[accessorInfo.type];\n    const TypedArray = WEBGL_COMPONENT_TYPES[accessorInfo.componentType];\n    const elementBytes = TypedArray.BYTES_PER_ELEMENT; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n    const itemBytes = elementBytes * itemSize;\n    if (accessorInfo.byteStride && accessorInfo.byteStride !== itemBytes) { // The buffer is not interleaved if the stride is the item size in bytes.\n        throw new Error(\"interleaved buffer!\"); // TODO\n    } else {\n        return new TypedArray(bufferView._buffer, accessorInfo.byteOffset || 0, accessorInfo.count * itemSize);\n    }\n}\n\n\nexport {parseGLTFIntoXKTModel};\n",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 199,
    "kind": "variable",
    "name": "WEBGL_COMPONENT_TYPES",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~WEBGL_COMPONENT_TYPES",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "{\"5120\": *, \"5121\": *, \"5122\": *, \"5123\": *, \"5125\": *, \"5126\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 200,
    "kind": "variable",
    "name": "WEBGL_TYPE_SIZES",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~WEBGL_TYPE_SIZES",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "{\"SCALAR\": number, \"VEC2\": number, \"VEC3\": number, \"VEC4\": number, \"MAT2\": number, \"MAT3\": number, \"MAT4\": number}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 201,
    "kind": "function",
    "name": "parseBuffers",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseBuffers",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 202,
    "kind": "function",
    "name": "parseBuffer",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "bufferInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 203,
    "kind": "function",
    "name": "parseArrayBuffer",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseArrayBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "uri",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 204,
    "kind": "function",
    "name": "parseBufferViews",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseBufferViews",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 205,
    "kind": "function",
    "name": "parseBufferView",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseBufferView",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "bufferViewInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 206,
    "kind": "function",
    "name": "freeBuffers",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~freeBuffers",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 129,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 207,
    "kind": "function",
    "name": "parseMaterials",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseMaterials",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 138,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 208,
    "kind": "function",
    "name": "parseMaterial",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseMaterial",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 149,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "materialInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 209,
    "kind": "function",
    "name": "parseDefaultScene",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseDefaultScene",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 213,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 210,
    "kind": "function",
    "name": "parseScene",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseScene",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 223,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "sceneInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 211,
    "kind": "variable",
    "name": "count",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~count",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 236,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 212,
    "kind": "function",
    "name": "parseNode",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseNode",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 238,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "glTFNode",
        "types": [
          "*"
        ]
      },
      {
        "name": "matrix",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 213,
    "kind": "function",
    "name": "createPrimitiveGeometryHash",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~createPrimitiveGeometryHash",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 377,
    "undocument": true,
    "params": [
      {
        "name": "primitiveInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 214,
    "kind": "function",
    "name": "parsePrimitiveGeometry",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parsePrimitiveGeometry",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 391,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "primitiveInfo",
        "types": [
          "*"
        ]
      },
      {
        "name": "geometryArrays",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 215,
    "kind": "function",
    "name": "parseAccessorTypedArray",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseAccessorTypedArray",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 446,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "accessorInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 216,
    "kind": "function",
    "name": "parseGLTFIntoXKTModel",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseGLTFIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": "{parseGLTFIntoXKTModel}",
    "description": "Parses glTF JSON into an {@link XKTModel}.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then load a glTF model into it.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#parsers_glTF_Duplex)]\n\n````javascript\nutils.loadJSON(\"./models/gltf/duplex/scene.gltf\", async (json) => {\n\n    const xktModel = new XKTModel();\n\n    parseGLTFIntoXKTModel(json, xktModel);\n\n    xktModel.finalize();\n});\n````",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "gltf",
        "description": "The glTF JSON."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "xktModel",
        "description": "XKTModel to parse into"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "getAttachment",
        "description": "Callback through which to fetch attachments, if the glTF has them."
      }
    ],
    "return": null
  },
  {
    "__docId__": 217,
    "kind": "file",
    "name": "src/parsers/parseSTLIntoXKTModel.js",
    "content": "import {math} from \"../lib/math.js\";\n\n/**\n * @desc Parses STL file data into an {@link XKTModel}.\n *\n * @param {Object} data STL file data.\n * @param {XKTModel} model XKTModel to parse into.\n * @param {*} [options] Parsing options.\n * @private\n */\nasync function parseSTLIntoXKTModel(data, model, options) {\n    const binData = ensureBinary(data);\n    if (isBinary(binData)) {\n        parseBinary(binData, model, options);\n    } else {\n        parseASCII(ensureString(data), model, options);\n    }\n}\n\nfunction isBinary(data) {\n    const reader = new DataView(data);\n    const numFaces = reader.getUint32(80, true);\n    const faceSize = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8);\n    const numExpectedBytes = 80 + (32 / 8) + (numFaces * faceSize);\n    if (numExpectedBytes === reader.byteLength) {\n        return true;\n    }\n    const solid = [115, 111, 108, 105, 100];\n    for (var i = 0; i < 5; i++) {\n        if (solid[i] !== reader.getUint8(i, false)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction parseBinary(data, model, options) {\n    const reader = new DataView(data);\n    const faces = reader.getUint32(80, true);\n    let r;\n    let g;\n    let b;\n    let hasColors = false;\n    let colors;\n    let defaultR;\n    let defaultG;\n    let defaultB;\n    let lastR = null;\n    let lastG = null;\n    let lastB = null;\n    let newMesh = false;\n    let alpha;\n    for (let index = 0; index < 80 - 10; index++) {\n        if ((reader.getUint32(index, false) === 0x434F4C4F /*COLO*/) &&\n            (reader.getUint8(index + 4) === 0x52 /*'R'*/) &&\n            (reader.getUint8(index + 5) === 0x3D /*'='*/)) {\n            hasColors = true;\n            colors = [];\n            defaultR = reader.getUint8(index + 6) / 255;\n            defaultG = reader.getUint8(index + 7) / 255;\n            defaultB = reader.getUint8(index + 8) / 255;\n            alpha = reader.getUint8(index + 9) / 255;\n        }\n    }\n    let dataOffset = 84;\n    let faceLength = 12 * 4 + 2;\n    let positions = [];\n    let normals = [];\n    let splitMeshes = options.splitMeshes;\n    for (let face = 0; face < faces; face++) {\n        let start = dataOffset + face * faceLength;\n        let normalX = reader.getFloat32(start, true);\n        let normalY = reader.getFloat32(start + 4, true);\n        let normalZ = reader.getFloat32(start + 8, true);\n        if (hasColors) {\n            let packedColor = reader.getUint16(start + 48, true);\n            if ((packedColor & 0x8000) === 0) {\n                r = (packedColor & 0x1F) / 31;\n                g = ((packedColor >> 5) & 0x1F) / 31;\n                b = ((packedColor >> 10) & 0x1F) / 31;\n            } else {\n                r = defaultR;\n                g = defaultG;\n                b = defaultB;\n            }\n            if (splitMeshes && r !== lastR || g !== lastG || b !== lastB) {\n                if (lastR !== null) {\n                    newMesh = true;\n                }\n                lastR = r;\n                lastG = g;\n                lastB = b;\n            }\n        }\n        for (let i = 1; i <= 3; i++) {\n            let vertexstart = start + i * 12;\n            positions.push(reader.getFloat32(vertexstart, true));\n            positions.push(reader.getFloat32(vertexstart + 4, true));\n            positions.push(reader.getFloat32(vertexstart + 8, true));\n            normals.push(normalX, normalY, normalZ);\n            if (hasColors) {\n                colors.push(r, g, b, 1); // TODO: handle alpha\n            }\n        }\n        if (splitMeshes && newMesh) {\n            addMesh(model, positions, normals, colors, options);\n            positions = [];\n            normals = [];\n            colors = colors ? [] : null;\n            newMesh = false;\n        }\n    }\n    if (positions.length > 0) {\n        addMesh(model, positions, normals, colors, options);\n    }\n}\n\nfunction parseASCII(data, model, options) {\n    const faceRegex = /facet([\\s\\S]*?)endfacet/g;\n    let faceCounter = 0;\n    const floatRegex = /[\\s]+([+-]?(?:\\d+.\\d+|\\d+.|\\d+|.\\d+)(?:[eE][+-]?\\d+)?)/.source;\n    const vertexRegex = new RegExp('vertex' + floatRegex + floatRegex + floatRegex, 'g');\n    const normalRegex = new RegExp('normal' + floatRegex + floatRegex + floatRegex, 'g');\n    const positions = [];\n    const normals = [];\n    const colors = null;\n    let normalx;\n    let normaly;\n    let normalz;\n    let result;\n    let verticesPerFace;\n    let normalsPerFace;\n    let text;\n    while ((result = faceRegex.exec(data)) !== null) {\n        verticesPerFace = 0;\n        normalsPerFace = 0;\n        text = result[0];\n        while ((result = normalRegex.exec(text)) !== null) {\n            normalx = parseFloat(result[1]);\n            normaly = parseFloat(result[2]);\n            normalz = parseFloat(result[3]);\n            normalsPerFace++;\n        }\n        while ((result = vertexRegex.exec(text)) !== null) {\n            positions.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n            normals.push(normalx, normaly, normalz);\n            verticesPerFace++;\n        }\n        if (normalsPerFace !== 1) {\n            console.error(\"Error in normal of face \" + faceCounter);\n            return -1;\n        }\n        if (verticesPerFace !== 3) {\n            console.error(\"Error in positions of face \" + faceCounter);\n            return -1;\n        }\n        faceCounter++;\n    }\n    addMesh(model, positions, normals, colors, options);\n}\n\nlet nextGeometryId = 0;\n\nfunction addMesh(model, positions, normals, colors, options) {\n\n    const indices = new Int32Array(positions.length / 3);\n    for (let ni = 0, len = indices.length; ni < len; ni++) {\n        indices[ni] = ni;\n    }\n\n    normals = normals && normals.length > 0 ? normals : null;\n    colors = colors && colors.length > 0 ? colors : null;\n\n    if (options.smoothNormals) {\n        math.faceToVertexNormals(positions, normals, options);\n    }\n\n    const geometryId = nextGeometryId++;\n    const meshId = nextGeometryId++;\n    const entityId = nextGeometryId++;\n\n    model.createGeometry({\n        geometryId: geometryId,\n        primitive: \"triangles\",\n        positions: positions,\n        normals: normals,\n        colors: colors,\n        indices: indices\n    });\n\n    model.createMesh({\n        meshId: meshId,\n        geometryId: geometryId\n    });\n\n    model.createEntity({\n        entityId: entityId,\n        meshIds: [meshId]\n    });\n}\n\nfunction ensureString(buffer) {\n    if (typeof buffer !== 'string') {\n        return decodeText(new Uint8Array(buffer));\n    }\n    return buffer;\n}\n\nfunction ensureBinary(buffer) {\n    if (typeof buffer === 'string') {\n        const arrayBuffer = new Uint8Array(buffer.length);\n        for (let i = 0; i < buffer.length; i++) {\n            arrayBuffer[i] = buffer.charCodeAt(i) & 0xff; // implicitly assumes little-endian\n        }\n        return arrayBuffer.buffer || arrayBuffer;\n    } else {\n        return buffer;\n    }\n}\n\nfunction decodeText(array) {\n    if (typeof TextDecoder !== 'undefined') {\n        return new TextDecoder().decode(array);\n    }\n    let s = '';\n    for (let i = 0, il = array.length; i < il; i++) {\n        s += String.fromCharCode(array[i]); // Implicitly assumes little-endian.\n    }\n    return decodeURIComponent(escape(s));\n}\n\nexport {parseSTLIntoXKTModel};\n",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/src/parsers/parseSTLIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 218,
    "kind": "function",
    "name": "isBinary",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~isBinary",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 219,
    "kind": "function",
    "name": "parseBinary",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~parseBinary",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 220,
    "kind": "function",
    "name": "parseASCII",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~parseASCII",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 118,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 221,
    "kind": "variable",
    "name": "nextGeometryId",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~nextGeometryId",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 162,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 222,
    "kind": "function",
    "name": "addMesh",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~addMesh",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 164,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      },
      {
        "name": "colors",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 223,
    "kind": "function",
    "name": "ensureString",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~ensureString",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 202,
    "undocument": true,
    "params": [
      {
        "name": "buffer",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 224,
    "kind": "function",
    "name": "ensureBinary",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~ensureBinary",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 209,
    "undocument": true,
    "params": [
      {
        "name": "buffer",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 225,
    "kind": "function",
    "name": "decodeText",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~decodeText",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 221,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 226,
    "kind": "function",
    "name": "parseSTLIntoXKTModel",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~parseSTLIntoXKTModel",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": "{parseSTLIntoXKTModel}",
    "description": "Parses STL file data into an {@link XKTModel}.",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "STL file data."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "model",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Parsing options."
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "kind": "index",
    "content": "# xeokit-xkt-utils\n\n[![This project is using Percy.io for visual regression testing.](https://percy.io/static/images/percy-badge.svg)](https://percy.io/73524691/xeokit-xkt-utils)\n[![npm version](https://badge.fury.io/js/%40xeokit%2Fxeokit-xkt-utils.svg)](https://badge.fury.io/js/%40xeokit%2Fxeokit-xkt-utils)\n\nA JavaScript toolkit for creating [````XKT````](https://github.com/xeokit/xeokit-xkt-utils/blob/master/XKT_V7.md) model files\nfor loading into [xeokit](http://xeokit.io).\n\n````XKT```` is xeokit's native geometry file format, which allows us to rapidly load complex, double-precision models over the\nWeb and into a xeokit viewer. Using this toolkit in either browser or node, we can convert glTF into ````XKT````, and can even generate ````XKT````\nfiles programmatically.\n\nThis toolkit is currently used within the [xeokit-gltf-to-xkt](https://github.com/xeokit/xeokit-gltf-to-xkt) tool to\nconvert glTF to ````XKT````.\n\n[![Spatial partitioning](https://xeokit.github.io/xeokit-xkt-utils/images/geometryGeneration.png)](https://xeokit.github.io/xeokit-xkt-utils/tests/#generate_buildGeometries)\n\n## Contents\n\n- [Links](#links)\n- [Features](#features)\n- [JavaScript API](#javascript-api)\n    + [XKTModel](#xktmodel)\n    + [Building an XKTModel](#building-an-xktmodel)\n    + [Serializing the XKTModel to an ArrayBuffer](#serializing-the-xktmodel-to-an-arraybuffer)\n    + [Validating the ArrayBuffer](#validating-the-arraybuffer)\n    + [Loading the ArrayBuffer into a Viewer](#loading-the-arraybuffer-into-a-viewer)\n    + [Loading glTF into an XKTModel](#loading-gltf-into-an-xktmodel)\n- [Building](#building)\n\n## Links\n\n* [npm](https://www.npmjs.com/package/@xeokit/xeokit-xkt-utils)\n* [API Documentation](https://xeokit.github.io/xeokit-xkt-utils/docs)\n* [Source Code](https://github.com/xeokit/xeokit-xkt-utils)\n* [Demos](https://xeokit.github.io/xeokit-xkt-utils/tests)\n* [Automated Tests](https://percy.io/73524691/xeokit-xkt-utils)\n\n## Features\n\n* A JavaScript document model that represents an XKT file\n* Parse glTF into the document model\n* Programmatically generate geometry within the document model\n* Serialize the document model to an array buffer\n* Save the array buffer as an XKT file\n\n## JavaScript API\n\n#### XKTModel\n\nAt the center of ````xeokit-xkt-utils```` is\nthe  [**````XKTModel````**](https://xeokit.github.io/xeokit-xkt-utils/docs/class/src/XKTModel/XKTModel.js~XKTModel.html)\nclass, which represents an ````XKT```` model.\n\n````XKTModel```` provides builder methods, with which we can programmatically populate it with 3D objects.\n\n````xeokit-xkt-utils```` also provides these utility functions for loading, serializing and\nvalidating ````XKTModels````:\n\n* [**````parseGLTFIntoXKTModel````**](https://xeokit.github.io/xeokit-xkt-utils/docs/function/index.html#static-function-parseGLTFIntoXKTModel)\n  loads glTF JSON into an ````XKTModel````.\n* [**````writeXKTModelToArrayBuffer````**](https://xeokit.github.io/xeokit-xkt-utils/docs/function/index.html#static-function-writeXKTModelToArrayBuffer)\n  serializes an ````XKTModel```` to an ````ArrayBuffer````.\n* [**````validateXKTArrayBuffer````**](https://xeokit.github.io/xeokit-xkt-utils/docs/function/index.html#static-function-validateXKTArrayBuffer)\n  validates an ````ArrayBuffer```` against the ````XKTModel```` it was serialized from.\n\n#### Building an XKTModel\n\nTo demonstrate the API, let's\nuse [````XKTModel````](https://xeokit.github.io/xeokit-xkt-utils/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) 's\nbuilder methods to programmatically build a model that resembles the screenshot below. Then we'll serialize\nthe ````XKTModel```` to an\n````ArrayBuffer````, which we'll finally load that into a\nxeokit [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html)\nusing [````XKTLoaderPlugin````](https://xeokit.github.io/xeokit-sdk/docs/class/src/plugins/XKTLoaderPlugin/XKTLoaderPlugin.js~XKTLoaderPlugin.html)\n.\n\nWe'll code this example to run in the browser, using the ES module\nin [xeokit-xkt-utils.es.js](./dist/xeokit-xkt-utils.es.js). We could also code it to run on node, using the CommonJS\nmodule in [xeokit-xkt-utils.cjs.js](./dist/xeokit-xkt-utils.cjs.js).\n\n[![XKTModel Example](http://xeokit.io/img/docs/PerformanceModel/PerformanceModel.png)](https://xeokit.github.io/xeokit-xkt-utils/tests/#generate_instancing_triangles)\n\n[[Run this example](https://xeokit.github.io/xeokit-xkt-utils/tests/#generate_instancing_triangles)]\n\n````javascript\n\nimport {XKTModel, writeXKTModelToArrayBuffer, validateXKTArrayBuffer} from \"./dist/xeokit-xkt-utils.es.js\";\n\n// Or in node:\n// const {XKTModel, parseGLTFIntoXKTModel, writeXKTModelToArrayBuffer} = require(\"./xeokit-xkt-utils.cjs.js\");\n\nconst xktModel = new XKTModel();\n\n// Create an XKTGeometry that defines a box shape, as a triangle mesh \n\nxktModel.createGeometry({\n    geometryId: \"boxGeometry\",\n    primitiveType: \"triangles\", // Also \"lines\" and \"points\"\n    positions: [\n        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1,\n        -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1,\n        -1, -1, -1, -1, -1, 1, -1, 1, 1, -1\n    ],\n    normals: [ // Only for \"triangles\"\n        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,\n        -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0,\n        -1, 0, 0, -1\n    ],\n    indices: [\n        0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19,\n        20, 21, 22, 20, 22, 23\n    ]\n});\n\n// Create five XKTMeshes, which represent the table top and legs.\n// Each XKTMesh has its own color, position, orientation and size, \n// and uses the XKTGeometry to define its shape.  \n// An XKTGeometry can be used by multiple XKTMeshes.\n\nxktModel.createMesh({\n    meshId: \"redLegMesh\",\n    geometryId: \"boxGeometry\",\n    position: [-4, -6, -4],\n    scale: [1, 3, 1],\n    rotation: [0, 0, 0],\n    color: [1, 0, 0],\n    opacity: 1\n});\n\nxktModel.createMesh({\n    meshId: \"greenLegMesh\",\n    geometryId: \"boxGeometry\",\n    position: [4, -6, -4],\n    scale: [1, 3, 1],\n    rotation: [0, 0, 0],\n    color: [0, 1, 0],\n    opacity: 1\n});\n\nxktModel.createMesh({\n    meshId: \"blueLegMesh\",\n    geometryId: \"boxGeometry\",\n    position: [4, -6, 4],\n    scale: [1, 3, 1],\n    rotation: [0, 0, 0],\n    color: [0, 0, 1],\n    opacity: 1\n});\n\nxktModel.createMesh({\n    meshId: \"yellowLegMesh\",\n    geometryId: \"boxGeometry\",\n    position: [-4, -6, 4],\n    scale: [1, 3, 1],\n    rotation: [0, 0, 0],\n    color: [1, 1, 0],\n    opacity: 1\n});\n\nxktModel.createMesh({\n    meshId: \"pinkTopMesh\",\n    geometryId: \"boxGeometry\",\n    position: [0, -3, 0],\n    scale: [6, 0.5, 6],\n    rotation: [0, 0, 0],\n    color: [1, 0, 1],\n    opacity: 1\n});\n\n// Create five XKTEntities, which represent abstract, named objects in the model. \n// Each XKTEntity has an XKTMesh.\n// An XKTEntity can have multiple XKTMeshes. \n// An XKTMesh can only belong to one XKTEntity.\n\nxktModel.createEntity({\n    entityId: \"redLeg\",\n    meshIds: [\"redLegMesh\"]\n});\n\nxktModel.createEntity({\n    entityId: \"greenLeg\",\n    meshIds: [\"greenLegMesh\"]\n});\n\nxktModel.createEntity({\n    entityId: \"blueLeg\",\n    meshIds: [\"blueLegMesh\"]\n});\n\nxktModel.createEntity({\n    entityId: \"yellowLeg\",\n    meshIds: [\"yellowLegMesh\"]\n});\n\nxktModel.createEntity({\n    entityId: \"pinkTop\",\n    meshIds: [\"pinkTopMesh\"]\n});\n````\n\nOnce we've built\nour [````XKTModel````](https://xeokit.github.io/xeokit-xkt-utils/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) we\nneed to finalize it. Then it's ready to use.\n\n````javascript\nxktModel.finalize();\n````\n\n#### Serializing the XKTModel to an ArrayBuffer\n\nNext, we'll\nuse  [````writeXKTModelToArrayBuffer````](https://xeokit.github.io/xeokit-xkt-utils/docs/function/index.html#static-function-writeXKTModelToArrayBuffer)\nto serialize\nour [````XKTModel````](https://xeokit.github.io/xeokit-xkt-utils/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) to\nan ````ArrayBuffer````.\n\n````javascript\nconst xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel);\n````\n\n#### Validating the ArrayBuffer\n\nNow we'll\nuse [````validateXKTArrayBuffer````](https://xeokit.github.io/xeokit-xkt-utils/docs/function/index.html#static-function-validateXKTArrayBuffer)\nto validate the ````ArrayBuffer```` against\nour [````XKTModel````](https://xeokit.github.io/xeokit-xkt-utils/docs/class/src/XKTModel/XKTModel.js~XKTModel.html). If\nthis function finds any errors, it will log them to the console and return ````false````. Otherwise, it will\nreturn ````true````, to indicate that the ````ArrayBuffer```` is correct.\n\n````javascript\nconst xktArrayBufferValid = validateXKTArrayBuffer(xktArrayBuffer, xktModel);\n\nif (!xktArrayBufferValid) {\n    console.error(\"XKT array buffer is invalid!\");\n}\n````\n\n#### Loading the ArrayBuffer into a Viewer\n\nLet's now create a [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html),\nthen load the ````ArrayBuffer```` into it using\nan [````XKTLoaderPlugin````](https://xeokit.github.io/xeokit-sdk/docs/class/src/plugins/XKTLoaderPlugin/XKTLoaderPlugin.js~XKTLoaderPlugin.html)\n.\n\n````javascript\nconst viewer = new Viewer({\n    canvasId: \"myCanvas\"\n});\n\nconst xktLoader = new XKTLoaderPlugin(viewer);\n\nconst model = xktLoader.load({\n    id: \"myModel\",\n    xkt: xktArrayBuffer\n});\n````\n\nNote that the ````XKTLoaderPlugin```` could also load our ````ArrayBuffer```` from a URL.\n\nFinally, let's fit the whole model in view.\n\n````javascript\nviewer.cameraFlight.flyTo(model);\n````\n\n#### Loading glTF into an XKTModel\n\nLet's\nuse [````parseGLTFIntoXKTModel````](https://xeokit.github.io/xeokit-xkt-utils/docs/function/index.html#static-function-parseGLTFIntoXKTModel)\nto import glTF into\nan [````XKTModel````](https://xeokit.github.io/xeokit-xkt-utils/docs/class/src/XKTModel/XKTModel.js~XKTModel.html).\n\nWe'll also use the classes and functions introduced in the previous examples to serialize\nthe [````XKTModel````](https://xeokit.github.io/xeokit-xkt-utils/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) to\nan ````ArrayBuffer````, then validate the ````ArrayBuffer```` and load it into\na [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html).\n\n````javascript\nconst viewer = new Viewer({\n    canvasId: \"myCanvas\"\n});\n\nconst xktLoader = new XKTLoaderPlugin(viewer);\n\nutils.loadJSON(\"./models/gltf/MAP/MAP.gltf\", (json) => {\n\n        const xktModel = new XKTModel();\n\n        parseGLTFIntoXKTModel(json, xktModel).then(() => {\n\n            const xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel);\n\n            const xktArrayBufferValid = validateXKTArrayBuffer(xktArrayBuffer, xktModel);\n\n            xktLoader.load({\n                id: \"myModel\",\n                xkt: xktArrayBuffer\n            });\n\n            viewer.cameraFlight.flyTo(viewer.scene);\n        });\n    },\n    (errMsg) => {\n    });\n````\n\n#### Loading STL into an XKTModel\n\nLet's\nuse [````parseSTLIntoXKTModel````](https://xeokit.github.io/xeokit-xkt-utils/docs/function/index.html#static-function-parseSTLIntoXKTModel)\nto import STL into\nan [````XKTModel````](https://xeokit.github.io/xeokit-xkt-utils/docs/class/src/XKTModel/XKTModel.js~XKTModel.html).\n\nAs before, we'll also use the classes and functions introduced in the previous examples to serialize\nthe [````XKTModel````](https://xeokit.github.io/xeokit-xkt-utils/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) to\nan ````ArrayBuffer````, then validate the ````ArrayBuffer```` and load it into\na [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html).\n\n````javascript\nconst viewer = new Viewer({\n    canvasId: \"myCanvas\"\n});\n\nconst xktLoader = new XKTLoaderPlugin(viewer);\n\nutils.loadJSON(\"./models/stl/binary/spurGear.stl\", (json) => {\n\n        const xktModel = new XKTModel();\n\n        parseSTLIntoXKTModel(json, xktModel).then(() => {\n\n            const xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel);\n\n            const xktArrayBufferValid = validateXKTArrayBuffer(xktArrayBuffer, xktModel);\n\n            xktLoader.load({\n                id: \"myModel\",\n                xkt: xktArrayBuffer\n            });\n\n            viewer.cameraFlight.flyTo(viewer.scene);\n        });\n    },\n    (errMsg) => {\n    });\n````\n\n## Building\n\nBuilding the binaries in [````./dist````](https://xeokit.github.io/xeokit-xkt-utils/dist):\n\n````bash\nnpm update\nnpm run build\n````\n\nThis will build:\n\n* [./dist/xeokit-xkt-utils.cjs.js](./dist/xeokit-xkt-utils.cjs.js) - CommonJS module\n* [./dist/xeokit-xkt-utils.es.js](./dist/xeokit-xkt-utils.es.js) - ES module\n\nBuilding the JavaScript API documentation in [````./docs````](https://xeokit.github.io/xeokit-xkt-utils/docs):\n\n````bash\nnpm run docs\n````",
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"@xeokit/xeokit-xkt-utils\",\n  \"version\": \"1.0.0\",\n  \"description\": \"JavaScript utilities to create .XKT files\",\n  \"main\": \"index.js\",\n  \"directories\": {},\n  \"scripts\": {\n    \"build\": \" rollup -c\",\n    \"test\": \"percy exec -- node snapshots.js\",\n    \"docs\": \"./node_modules/.bin/esdoc\",\n    \"publish\": \"npm publish --access public\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/xeokit/xeokit-xkt-utils.git\"\n  },\n  \"keywords\": [\n    \"xeolabs\",\n    \"xeokit\",\n    \"bim\",\n    \"opensource\",\n    \"ifc\",\n    \"webgl\",\n    \"xkt\",\n    \"gltf\"\n  ],\n  \"author\": \"Lindsay Kay\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/xeokit/xeokit-xkt-utils/issues\"\n  },\n  \"homepage\": \"https://github.com/xeokit/xeokit-xkt-utils#readme\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"@percy/script\": \"^1.1.0\",\n    \"@rollup/plugin-commonjs\": \"^15.1.0\",\n    \"autoprefixer\": \"^9.8.5\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"http-server\": \"^0.12.3\",\n    \"mocha\": \"^8.1.3\",\n    \"rollup\": \"^1.32.1\",\n    \"rollup-plugin-minify-es\": \"^1.1.1\",\n    \"rollup-plugin-node-resolve\": \"^5.2.0\"\n  },\n  \"files\": [\n    \"/dist\",\n    \"src\"\n  ]\n}\n",
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-utils-april/xeokit-xkt-utils/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]