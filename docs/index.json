[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/XKTModel/KDNode.js",
    "content": "/**\n * A kd-Tree node, used internally by {@link XKTModel}.\n *\n * @private\n */\nclass KDNode {\n\n    /**\n     * Create a KDNode with an axis-aligned 3D World-space boundary.\n     */\n    constructor(aabb) {\n\n        /**\n         * The axis-aligned 3D World-space boundary of this KDNode.\n         *\n         * @type {Float32Array}\n         */\n        this.aabb = aabb;\n\n        /**\n         * The {@link XKTEntity}s within this KDNode.\n         */\n        this.entities = null;\n\n        /**\n         * The left child KDNode.\n         */\n        this.left = null;\n\n        /**\n         * The right child KDNode.\n         */\n        this.right = null;\n    }\n}\n\nexport {KDNode};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-tools/src/XKTModel/KDNode.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "KDNode",
    "memberof": "src/XKTModel/KDNode.js",
    "static": true,
    "longname": "src/XKTModel/KDNode.js~KDNode",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/KDNode.js",
    "importStyle": "{KDNode}",
    "description": "A kd-Tree node, used internally by {@link XKTModel}.",
    "lineNumber": 6,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#constructor",
    "access": "public",
    "description": "Create a KDNode with an axis-aligned 3D World-space boundary.",
    "lineNumber": 11
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "aabb",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#aabb",
    "access": "public",
    "description": "The axis-aligned 3D World-space boundary of this KDNode.",
    "lineNumber": 18,
    "type": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "entities",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#entities",
    "access": "public",
    "description": "The {@link XKTEntity}s within this KDNode.",
    "lineNumber": 23,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "left",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#left",
    "access": "public",
    "description": "The left child KDNode.",
    "lineNumber": 28,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "right",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#right",
    "access": "public",
    "description": "The right child KDNode.",
    "lineNumber": 33,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "file",
    "name": "src/XKTModel/MockXKTModel.js",
    "content": "import {math} from \"./lib/math.js\";\nimport {geometryCompression} from \"./lib/geometryCompression.js\";\nimport {buildEdgeIndices} from \"./lib/buildEdgeIndices.js\";\n\nconst tempVec4a = math.vec4([0, 0, 0, 1]);\nconst tempVec4b = math.vec4([0, 0, 0, 1]);\nconst tempMat4 = math.mat4();\nconst tempMat4b = math.mat4();\n\n/**\n * A mock {@link XKTModel} that creates {@link Mesh}es and {@link Geometry}s to visualize the output of {@link loadGLTFIntoXKTModel}.\n *\n * @private\n */\nclass MockXKTModel {\n\n    /**\n     *\n     * @param cfg\n     */\n    constructor(cfg={}) {\n\n        if (!cfg.handlePrimitive) {\n            throw \"Expected config: handlePrimitive\";\n        }\n\n        if (!cfg.handleEntity) {\n            throw \"Expected config: handleEntity\";\n        }\n\n        this._handlePrimitive = cfg.handlePrimitive;\n        this._handleEntity = cfg.handleEntity;\n\n        this.primitives = {};\n    }\n\n    createPrimitive(params) {\n\n        const primitiveId = params.primitiveId;\n        const primitiveType = params.primitiveType;\n        const reused = params.reused;\n        const primitiveModelingMatrix = params.primitiveModelingMatrix ? params.primitiveModelingMatrix.slice : math.identityMat4();\n        const color = params.color;\n        const opacity = params.opacity;\n        const positions = params.positions.slice();\n        const normals = params.normals.slice();\n        const indices = params.indices;\n\n        const positions2 = positions.slice();\n\n        const edgeIndices = buildEdgeIndices(positions, indices, null, 10);\n\n        if (!reused) {\n\n            // Bake single-use primitive's positions into World-space\n\n            for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                tempVec4a[0] = positions[i + 0];\n                tempVec4a[1] = positions[i + 1];\n                tempVec4a[2] = positions[i + 2];\n\n                math.transformPoint4(primitiveModelingMatrix, tempVec4a, tempVec4b);\n\n                positions2[i + 0] = tempVec4b[0];\n                positions2[i + 1] = tempVec4b[1];\n                positions2[i + 2] = tempVec4b[2];\n            }\n        }\n\n        const modelNormalMatrix = math.inverseMat4(math.transposeMat4(primitiveModelingMatrix, tempMat4b), tempMat4);\n        const normalsOctEncoded = new Int8Array(normals.length);\n\n        geometryCompression.transformAndOctEncodeNormals(modelNormalMatrix, normals, normals.length, normalsOctEncoded, 0);\n\n        const primitive = new VBOGeometry(this.scene, {\n            id: primitiveId,\n            primitive: \"triangles\",\n            positions: positions2,\n            normals: normals,\n            indices: indices,\n            edgeIndices: edgeIndices\n        });\n\n        this.primitives[primitiveId] = primitive;\n    }\n\n    createEntity(params) {\n\n        const entityId = params.entityId;\n        const entityModelingMatrix = params.entityModelingMatrix ? params.entityModelingMatrix.slice() : math.identityMat4();\n        const primitiveIds = params.primitiveIds;\n\n        for (let primitiveIdIdx = 0, primitiveIdLen = primitiveIds.length; primitiveIdIdx < primitiveIdLen; primitiveIdIdx++) {\n\n            const primitiveId = primitiveIds[primitiveIdIdx];\n            const primitive = this.primitives[primitiveId];\n\n            if (!primitive) {\n                console.error(\"primitive not found: \" + primitiveId);\n                continue;\n            }\n\n            new Mesh(this.scene, {\n                id: entityId,\n                geometry: primitive,\n                matrix: entityModelingMatrix,\n                edges: true\n            });\n        }\n    }\n\n    finalize() {\n    }\n}\n\nexport {MockXKTModel};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-tools/src/XKTModel/MockXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 56,
    "kind": "variable",
    "name": "tempVec4a",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~tempVec4a",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/MockXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 57,
    "kind": "variable",
    "name": "tempVec4b",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~tempVec4b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/MockXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 58,
    "kind": "variable",
    "name": "tempMat4",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~tempMat4",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/MockXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 59,
    "kind": "variable",
    "name": "tempMat4b",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~tempMat4b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/MockXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 60,
    "kind": "class",
    "name": "MockXKTModel",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/MockXKTModel.js",
    "importStyle": "{MockXKTModel}",
    "description": "A mock {@link XKTModel} that creates {@link Mesh}es and {@link Geometry}s to visualize the output of {@link loadGLTFIntoXKTModel}.",
    "lineNumber": 15,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 61,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "_handlePrimitive",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#_handlePrimitive",
    "access": "private",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "_handleEntity",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#_handleEntity",
    "access": "private",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "member",
    "name": "primitives",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#primitives",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "method",
    "name": "createPrimitive",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#createPrimitive",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "createEntity",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#createEntity",
    "access": "public",
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "finalize",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#finalize",
    "access": "public",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 68,
    "kind": "file",
    "name": "src/XKTModel/XKTEntity.js",
    "content": "import {math} from \"./lib/math.js\";\n\n/**\n * An object within an {@link XKTModel}.\n *\n * * Created by {@link XKTModel#createEntity}\n * * Stored in {@link XKTModel#entities} and {@link XKTModel#entitiesList}\n * * Has one or more {@link XKTPrimitiveInstance}s, each having an {@link XKTPrimitive}\n * * May either share all of its ````XKTPrimitives````s with other ````XKTEntity````s, or exclusively own all of its ````XKTPrimitive````s\n *\n * @class XKTEntity\n */\nclass XKTEntity {\n\n    /**\n     * @private\n     * @param entityId\n     * @param matrix\n     * @param primitiveInstances\n     */\n    constructor(entityId, matrix, primitiveInstances) {\n\n        /**\n         * Unique ID of this ````XKTEntity```` in {@link XKTModel#entities}.\n         *\n         * For a BIM model, this will be an IFC product ID.\n         *\n         * @type {String}\n         */\n        this.entityId = entityId;\n\n        /**\n         * Index of this ````XKTEntity```` in {@link XKTModel#entitiesList}.\n         *\n         * Set by {@link XKTModel#finalize}.\n         *\n         * @type {Number}\n         */\n        this.entityIndex = 0;\n\n        /**\n         * The 4x4 modeling transform matrix.\n         *\n         * Transform is relative to the center of the {@link XKTTile} that contains this Entity.\n         *\n         * When the ````XKTEntity```` shares its {@link XKTPrimitive}s with other ````XKTEntity````s, this matrix is used to transform the\n         * shared Primitives into World-space for this Entity. When this Entity does not share its ````XKTPrimitive````s,\n         * then this matrix is ignored.\n         *\n         * @type {Number[]}\n         */\n        this.matrix = matrix;\n\n        /**\n         * A list of {@link XKTPrimitiveInstance}s that indicate which {@link XKTPrimitive}s are used by this Entity.\n         *\n         * @type {XKTPrimitiveInstance[]}\n         */\n        this.primitiveInstances = primitiveInstances;\n\n        /**\n         * World-space axis-aligned bounding box (AABB) that encloses the {@link XKTPrimitive#positions} of\n         * the {@link XKTPrimitive}s that are used by this ````XKTEntity````.\n         *\n         * Set by {@link XKTModel#finalize}.\n         *\n         * @type {Float32Array}\n         */\n        this.aabb = math.AABB3();\n\n        /**\n         * Indicates if this ````XKTEntity```` shares {@link XKTPrimitive}s with other {@link XKTEntity}'s.\n         *\n         * Set by {@link XKTModel#finalize}.\n         *\n         * Note that when an ````XKTEntity```` shares ````XKTPrimitives````, it shares **all** of its ````XKTPrimitives````. An ````XKTEntity````\n         * never shares only some of its ````XKTPrimitives```` - it always shares either the whole set or none at all.\n         *\n         * @type {Boolean}\n         */\n        this.hasReusedPrimitives = false;\n    }\n}\n\nexport {XKTEntity};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-tools/src/XKTModel/XKTEntity.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 69,
    "kind": "class",
    "name": "XKTEntity",
    "memberof": "src/XKTModel/XKTEntity.js",
    "static": true,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTEntity.js",
    "importStyle": "{XKTEntity}",
    "description": "An object within an {@link XKTModel}.\n\n* Created by {@link XKTModel#createEntity}\n* Stored in {@link XKTModel#entities} and {@link XKTModel#entitiesList}\n* Has one or more {@link XKTPrimitiveInstance}s, each having an {@link XKTPrimitive}\n* May either share all of its ````XKTPrimitives````s with other ````XKTEntity````s, or exclusively own all of its ````XKTPrimitive````s",
    "lineNumber": 13,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTEntity"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 70,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "entityId",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "primitiveInstances",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 71,
    "kind": "member",
    "name": "entityId",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#entityId",
    "access": "public",
    "description": "Unique ID of this ````XKTEntity```` in {@link XKTModel#entities}.\n\nFor a BIM model, this will be an IFC product ID.",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 72,
    "kind": "member",
    "name": "entityIndex",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#entityIndex",
    "access": "public",
    "description": "Index of this ````XKTEntity```` in {@link XKTModel#entitiesList}.\n\nSet by {@link XKTModel#finalize}.",
    "lineNumber": 39,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 73,
    "kind": "member",
    "name": "matrix",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#matrix",
    "access": "public",
    "description": "The 4x4 modeling transform matrix.\n\nTransform is relative to the center of the {@link XKTTile} that contains this Entity.\n\nWhen the ````XKTEntity```` shares its {@link XKTPrimitive}s with other ````XKTEntity````s, this matrix is used to transform the\nshared Primitives into World-space for this Entity. When this Entity does not share its ````XKTPrimitive````s,\nthen this matrix is ignored.",
    "lineNumber": 52,
    "type": {
      "nullable": null,
      "types": [
        "Number[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 74,
    "kind": "member",
    "name": "primitiveInstances",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#primitiveInstances",
    "access": "public",
    "description": "A list of {@link XKTPrimitiveInstance}s that indicate which {@link XKTPrimitive}s are used by this Entity.",
    "lineNumber": 59,
    "type": {
      "nullable": null,
      "types": [
        "XKTPrimitiveInstance[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 75,
    "kind": "member",
    "name": "aabb",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#aabb",
    "access": "public",
    "description": "World-space axis-aligned bounding box (AABB) that encloses the {@link XKTPrimitive#positions} of\nthe {@link XKTPrimitive}s that are used by this ````XKTEntity````.\n\nSet by {@link XKTModel#finalize}.",
    "lineNumber": 69,
    "type": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 76,
    "kind": "member",
    "name": "hasReusedPrimitives",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#hasReusedPrimitives",
    "access": "public",
    "description": "Indicates if this ````XKTEntity```` shares {@link XKTPrimitive}s with other {@link XKTEntity}'s.\n\nSet by {@link XKTModel#finalize}.\n\nNote that when an ````XKTEntity```` shares ````XKTPrimitives````, it shares **all** of its ````XKTPrimitives````. An ````XKTEntity````\nnever shares only some of its ````XKTPrimitives```` - it always shares either the whole set or none at all.",
    "lineNumber": 81,
    "type": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 77,
    "kind": "file",
    "name": "src/XKTModel/XKTModel.js",
    "content": "import {math} from \"./lib/math.js\";\nimport {geometryCompression} from \"./lib/geometryCompression.js\";\nimport {buildEdgeIndices} from \"./lib/buildEdgeIndices.js\";\nimport {XKTPrimitiveInstance} from './XKTPrimitiveInstance.js';\nimport {XKTPrimitive} from './XKTPrimitive.js';\nimport {XKTEntity} from './XKTEntity.js';\nimport {XKTTile} from './XKTTile.js';\nimport {KDNode} from \"./KDNode.js\";\n\nconst tempVec4a = math.vec4([0, 0, 0, 1]);\nconst tempVec4b = math.vec4([0, 0, 0, 1]);\nconst tempMat4 = math.mat4();\nconst tempMat4b = math.mat4();\n\nconst MIN_TILE_DIAG = 10000;\n\nconst kdTreeDimLength = new Float32Array(3);\n\n/**\n * A document model that represents the contents of an .XKT V6 file.\n *\n * * An XKTModel contains {@link XKTTile}s, which spatially subdivide the model into regions.\n * * Each {@link XKTTile} contains {@link XKTEntity}s, which represent the objects within its region.\n * * Each {@link XKTEntity} has {@link XKTPrimitiveInstance}s, which indicate the {@link XKTPrimitive}s that comprise the {@link XKTEntity}.\n * * Import glTF into an XKTModel using {@link loadGLTFIntoXKTModel}\n * * Build an XKTModel programmatically using {@link XKTModel#createPrimitive} and {@link XKTModel#createEntity}\n * * Serialize an XKTModel to an ArrayBuffer using {@link writeXKTModelToArrayBuffer}\n *\n * ## Usage\n *\n * See [main docs page](/docs/#javascript-api) for usage examples.\n *\n * @class XKTModel\n */\nclass XKTModel {\n\n    /**\n     * Constructs a new XKTModel.\n     *\n     * @param {*} cfg Configuration\n     */\n    constructor(cfg = {}) {\n\n        /**\n         * The positions of all shared {@link XKTPrimitive}s are de-quantized using this singular\n         * de-quantization matrix.\n         *\n         * This de-quantization matrix is which is generated from the collective boundary of the\n         * positions of all shared {@link XKTPrimitive}s.\n         *\n         * @type {Float32Array}\n         */\n        this.reusedPrimitivesDecodeMatrix = new Float32Array(16);\n\n        /**\n         * {@link XKTPrimitive}s within this XKTModel, each mapped to {@link XKTPrimitive#primitiveId}.\n         *\n         * Created by {@link XKTModel#createPrimitive}.\n         *\n         * @type {{Number:XKTPrimitive}}\n         */\n        this.primitives = {};\n\n        /**\n         * {@link XKTPrimitive}s within this XKTModel, in the order they were created.\n         *\n         * Created by {@link XKTModel#createPrimitive}.\n         *\n         * @type {XKTPrimitive[]}\n         */\n        this.primitivesList = [];\n\n        /**\n         * {@link XKTPrimitiveInstance}s within this XKTModel, in the order they were created.\n         *\n         * Created by {@link XKTModel#createEntity}.\n         *\n         * @type {XKTPrimitiveInstance[]}\n         */\n        this.primitiveInstancesList = [];\n\n        /**\n         * {@link XKTEntity}s within this XKTModel, each mapped to {@link XKTEntity#entityId}.\n         *\n         * Created by {@link XKTModel#createEntity}.\n         *\n         * @type {{String:XKTEntity}}\n         */\n        this.entities = {};\n\n        /**\n         * {@link XKTEntity}s within this XKTModel.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTEntity[]}\n         */\n        this.entitiesList = [];\n\n        /**\n         * {@link XKTTile}s within this Model.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTTile[]}\n         */\n        this.tilesList = [];\n\n        /**\n         * Indicates if this XKTModel has been finalized.\n         *\n         * Set ````true```` by {@link XKTModel#finalize}.\n         *\n         * @type {boolean}\n         */\n        this.finalized = false;\n    }\n\n    /**\n     * Creates an {@link XKTPrimitive} within this XKTModel.\n     *\n     * Logs error and does nothing if this XKTModel has been (see {@link XKTModel#finalized}).\n     *\n     * @param {*} params Method parameters.\n     * @param {Number} params.primitiveId Unique ID for the {@link XKTPrimitive}.\n     * @param {String} params.primitiveType The type of {@link XKTPrimitive}: \"triangles\", \"lines\" or \"points\"\n     * @param {Float32Array} [params.matrix] Modeling matrix for the {@link XKTPrimitive}. Overrides ````position````, ````scale```` and ````rotation```` parameters.\n     * @param {Number[]} [params.position=[0,0,0]] Position of the {@link XKTPrimitive}. Overridden by the ````matrix```` parameter.\n     * @param {Number[]} [params.scale=[1,1,1]] Scale of the {@link XKTPrimitive}. Overridden by the ````matrix```` parameter.\n     * @param {Number[]} [params.rotation=[0,0,0]] Rotation of the {@link XKTPrimitive} as Euler angles given in degrees, for each of the X, Y and Z axis. Overridden by the ````matrix```` parameter.\n     * @param {Uint8Array} params.color RGB color for the {@link XKTPrimitive}, with each color component in range [0..1].\n     * @param {Number} params.opacity Opacity factor for the {@link XKTPrimitive}, in range [0..1].\n     * @param {Float64Array} params.positions Floating-point Local-space vertex positions for the {@link XKTPrimitive}.\n     * @param {Number[]} params.normals Floating-point vertex normals for the {@link XKTPrimitive}.\n     * @param {Uint32Array} params.indices Triangle mesh indices for the {@link XKTPrimitive}.\n     * @returns {XKTPrimitive} The new {@link XKTPrimitive}.\n     */\n    createPrimitive(params) {\n\n        if (!params) {\n            throw \"Parameters missing: params\";\n        }\n\n        if (params.primitiveId === null || params.primitiveId === undefined) {\n            throw \"Parameter missing: params.primitiveId\";\n        }\n\n        if (!params.primitiveType) {\n            throw \"Parameter missing: params.primitiveType\";\n        }\n\n        if (!params.color) {\n            throw \"Parameter missing: params.color\";\n        }\n\n        if (params.opacity === null || params.opacity === undefined) {\n            throw \"Parameter missing: params.opacity\";\n        }\n\n        if (!params.positions) {\n            throw \"Parameter missing: params.positions\";\n        }\n\n        if (!params.normals) {\n            throw \"Parameter missing: params.normals\";\n        }\n\n        if (!params.indices) {\n            throw \"Parameter missing: params.indices\";\n        }\n\n        if (this.finalized) {\n            console.error(\"XKTModel has been finalized, can't add more primitives\");\n            return;\n        }\n\n        const primitiveId = params.primitiveId;\n        const primitiveType = params.primitiveType;\n        let matrix = params.matrix;\n        const position = params.position;\n        const scale = params.scale;\n        const rotation = params.rotation;\n        const color = params.color;\n        const opacity = params.opacity;\n        const positions = params.positions.slice(); // May modify in #finalize\n        const normals = params.normals.slice(); // Will modify\n        const indices = params.indices;\n        const edgeIndices = buildEdgeIndices(positions, indices, null, 10);\n\n        if (!matrix) {\n            if (position || scale || rotation) {\n                matrix = math.identityMat4();\n                const quaternion = math.eulerToQuaternion(rotation || [0, 0, 0], \"XYZ\", math.identityQuaternion());\n                math.composeMat4(position || [0, 0, 0], quaternion, scale || [1, 1, 1], matrix)\n            }\n        }\n\n        matrix = matrix || math.identityMat4();\n\n        if (matrix && (!math.isIdentityMat4(matrix))) { // Bake positions into World-space\n            for (let i = 0, len = positions.length; i < len; i += 3) {\n                tempVec4a[0] = positions[i + 0];\n                tempVec4a[1] = positions[i + 1];\n                tempVec4a[2] = positions[i + 2];\n                math.transformPoint4(matrix, tempVec4a, tempVec4b);\n                positions[i + 0] = tempVec4b[0];\n                positions[i + 1] = tempVec4b[1];\n                positions[i + 2] = tempVec4b[2];\n            }\n        }\n\n        // TODO: Oct-encode normals, in World-space if not reused, otherwise in Model-space?\n\n        const modelNormalMatrix = math.inverseMat4(math.transposeMat4(matrix, tempMat4b), tempMat4);\n        const normalsOctEncoded = new Int8Array(normals.length);\n\n        geometryCompression.transformAndOctEncodeNormals(modelNormalMatrix, normals, normals.length, normalsOctEncoded, 0);\n\n        const primitiveIndex = this.primitivesList.length;\n\n        const primitive = new XKTPrimitive(primitiveId, primitiveType, primitiveIndex, color, opacity, positions, normalsOctEncoded, indices, edgeIndices);\n\n        this.primitives[primitiveId] = primitive;\n        this.primitivesList.push(primitive);\n\n        return primitive;\n    }\n\n    /**\n     * Creates an {@link XKTEntity} within this XKTModel.\n     *\n     * Logs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).\n     *\n     * @param {*} params Method parameters.\n     * @param {String} params.entityId Unique ID for the {@link XKTEntity}.\n     * @param {Float32Array} [params.matrix] Modeling matrix for the {@link XKTEntity}. Overrides ````position````, ````scale```` and ````rotation```` parameters.\n     * @param {Number[]} [params.position=[0,0,0]] Position of the {@link XKTEntity}. Overridden by the ````matrix```` parameter.\n     * @param {Number[]} [params.scale=[1,1,1]] Scale of the {@link XKTEntity}. Overridden by the ````matrix```` parameter.\n     * @param {Number[]} [params.rotation=[0,0,0]] Rotation of the {@link XKTEntity} as Euler angles given in degrees, for each of the X, Y and Z axis. Overridden by the ````matrix```` parameter.\n\n     * @param {String[]} params.primitiveIds IDs of {@link XKTPrimitive}s used by the {@link XKTEntity}.\n     * @returns {XKTEntity} The new {@link XKTEntity}.\n     */\n    createEntity(params) {\n\n        if (!params) {\n            throw \"Parameters missing: params\";\n        }\n\n        if (params.entityId === null || params.entityId === undefined) {\n            throw \"Parameter missing: params.entityId\";\n        }\n\n        if (!params.primitiveIds) {\n            throw \"Parameter missing: params.primitiveIds\";\n        }\n\n        if (this.finalized) {\n            console.error(\"XKTModel has been finalized, can't add more entities\");\n            return;\n        }\n\n        const entityId = params.entityId;\n        let matrix = params.matrix;\n        const position = params.position;\n        const scale = params.scale;\n        const rotation = params.rotation;\n        const primitiveIds = params.primitiveIds;\n        const primitiveInstances = [];\n\n        if (!matrix) {\n            if (position || scale || rotation) {\n                matrix = math.identityMat4();\n                const quaternion = math.eulerToQuaternion(rotation || [0, 0, 0], \"XYZ\", math.identityQuaternion());\n                math.composeMat4(position || [0, 0, 0], quaternion, scale || [1, 1, 1], matrix)\n            } else {\n                matrix = math.identityMat4();\n            }\n        }\n\n        for (let primitiveIdIdx = 0, primitiveIdLen = primitiveIds.length; primitiveIdIdx < primitiveIdLen; primitiveIdIdx++) {\n\n            const primitiveId = primitiveIds[primitiveIdIdx];\n            const primitive = this.primitives[primitiveId];\n\n            if (!primitive) {\n                console.error(\"Primitive not found: \" + primitiveId);\n                continue;\n            }\n\n            primitive.numInstances++;\n\n            const primitiveInstanceIndex = this.primitiveInstancesList.length;\n            const primitiveInstance = new XKTPrimitiveInstance(primitiveInstanceIndex, primitive);\n\n            primitiveInstances.push(primitiveInstance);\n\n            this.primitiveInstancesList.push(primitiveInstance);\n        }\n\n        const entity = new XKTEntity(entityId, matrix, primitiveInstances);\n\n        for (let i = 0, len = primitiveInstances.length; i < len; i++) {\n            const primitiveInstance = primitiveInstances[i];\n            primitiveInstance.entity = entity;\n        }\n\n        this.entities[entityId] = entity;\n\n        return entity;\n    }\n\n    /**\n     * Finalizes this XKTModel.\n     *\n     * After finalizing, we may then serialize the model to an array buffer using {@link writeXKTModelToArrayBuffer}.\n     *\n     * Logs error and does nothing if this XKTModel has already been finalized.\n     *\n     * Internally, this method:\n     *\n     * * sets each {@link XKTEntity}'s {@link XKTEntity#hasReusedPrimitives} true if it shares its {@link XKTPrimitive}s with other {@link XKTEntity}s,\n     * * creates each {@link XKTEntity}'s {@link XKTEntity#aabb},\n     * * creates {@link XKTTile}s in {@link XKTModel#tilesList}, and\n     * * sets {@link XKTModel#finalized} ````true````.\n     */\n    finalize() {\n\n        if (this.finalized) {\n            console.log(\"XKTModel already finalized\");\n            return;\n        }\n\n        this._flagEntitiesThatReusePrimitives();\n\n        this._createEntityAABBs();\n\n        const rootKDNode = this._createKDTree();\n\n        this._createTilesFromKDTree(rootKDNode);\n\n        this._createReusedPrimitivesDecodeMatrix();\n\n        this.finalized = true;\n    }\n\n    _flagEntitiesThatReusePrimitives() {\n\n        for (let entityId in this.entities) {\n            if (this.entities.hasOwnProperty(entityId)) {\n\n                const entity = this.entities[entityId];\n                const primitiveInstances = entity.primitiveInstances;\n\n                for (let j = 0, lenj = primitiveInstances.length; j < lenj; j++) {\n\n                    const primitiveInstance = primitiveInstances[j];\n                    const primitive = primitiveInstance.primitive;\n\n                    if (primitive.numInstances > 1) {\n                        entity.hasReusedPrimitives = true;\n                    }\n                }\n            }\n        }\n    }\n\n    _createEntityAABBs() {\n\n        for (let entityId in this.entities) {\n            if (this.entities.hasOwnProperty(entityId)) {\n\n                const entity = this.entities[entityId];\n                const primitiveInstances = entity.primitiveInstances;\n\n                math.collapseAABB3(entity.aabb);\n\n                for (let j = 0, lenj = primitiveInstances.length; j < lenj; j++) {\n\n                    const primitiveInstance = primitiveInstances[j];\n                    const primitive = primitiveInstance.primitive;\n\n                    if (primitive.numInstances > 1) {\n\n                        const positions = primitive.positions;\n                        for (let i = 0, len = positions.length; i < len; i += 3) {\n                            tempVec4a[0] = positions[i + 0];\n                            tempVec4a[1] = positions[i + 1];\n                            tempVec4a[2] = positions[i + 2];\n                            math.transformPoint4(entity.matrix, tempVec4a, tempVec4b);\n                            math.expandAABB3Point3(entity.aabb, tempVec4b);\n                        }\n\n                    } else {\n\n                        const positions = primitive.positions;\n                        for (let i = 0, len = positions.length; i < len; i += 3) {\n                            tempVec4a[0] = positions[i + 0];\n                            tempVec4a[1] = positions[i + 1];\n                            tempVec4a[2] = positions[i + 2];\n                            math.expandAABB3Point3(entity.aabb, tempVec4a);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    _createKDTree() {\n\n        const aabb = math.collapseAABB3();\n\n        for (let entityId in this.entities) {\n            if (this.entities.hasOwnProperty(entityId)) {\n                const entity = this.entities[entityId];\n                math.expandAABB3(aabb, entity.aabb);\n            }\n        }\n\n        const rootKDNode = new KDNode(aabb);\n\n        for (let entityId in this.entities) {\n            if (this.entities.hasOwnProperty(entityId)) {\n                const entity = this.entities[entityId];\n                this._insertEntityIntoKDTree(rootKDNode, entity);\n            }\n        }\n\n        return rootKDNode;\n    }\n\n    _insertEntityIntoKDTree(kdNode, entity) {\n\n        const nodeAABB = kdNode.aabb;\n        const entityAABB = entity.aabb;\n\n        const nodeAABBDiag = math.getAABB3Diag(nodeAABB);\n\n        if (nodeAABBDiag < MIN_TILE_DIAG) {\n            kdNode.entities = kdNode.entities || [];\n            kdNode.entities.push(entity);\n            math.expandAABB3(nodeAABB, entityAABB);\n            return;\n        }\n\n        if (kdNode.left) {\n            if (math.containsAABB3(kdNode.left.aabb, entityAABB)) {\n                this._insertEntityIntoKDTree(kdNode.left, entity);\n                return;\n            }\n        }\n\n        if (kdNode.right) {\n            if (math.containsAABB3(kdNode.right.aabb, entityAABB)) {\n                this._insertEntityIntoKDTree(kdNode.right, entity);\n                return;\n            }\n        }\n\n        kdTreeDimLength[0] = nodeAABB[3] - nodeAABB[0];\n        kdTreeDimLength[1] = nodeAABB[4] - nodeAABB[1];\n        kdTreeDimLength[2] = nodeAABB[5] - nodeAABB[2];\n\n        let dim = 0;\n\n        if (kdTreeDimLength[1] > kdTreeDimLength[dim]) {\n            dim = 1;\n        }\n\n        if (kdTreeDimLength[2] > kdTreeDimLength[dim]) {\n            dim = 2;\n        }\n\n        if (!kdNode.left) {\n            const aabbLeft = nodeAABB.slice();\n            aabbLeft[dim + 3] = ((nodeAABB[dim] + nodeAABB[dim + 3]) / 2.0);\n            kdNode.left = new KDNode(aabbLeft);\n            if (math.containsAABB3(aabbLeft, entityAABB)) {\n                this._insertEntityIntoKDTree(kdNode.left, entity);\n                return;\n            }\n        }\n\n        if (!kdNode.right) {\n            const aabbRight = nodeAABB.slice();\n            aabbRight[dim] = ((nodeAABB[dim] + nodeAABB[dim + 3]) / 2.0);\n            kdNode.right = new KDNode(aabbRight);\n            if (math.containsAABB3(aabbRight, entityAABB)) {\n                this._insertEntityIntoKDTree(kdNode.right, entity);\n                return;\n            }\n        }\n\n        kdNode.entities = kdNode.entities || [];\n        kdNode.entities.push(entity);\n\n        math.expandAABB3(nodeAABB, entityAABB);\n    }\n\n    _createTilesFromKDTree(rootKDNode) {\n        this._createTilesFromKDNode(rootKDNode);\n    }\n\n    _createTilesFromKDNode(kdNode) {\n        if (kdNode.entities && kdNode.entities.length > 0) {\n            this._createTileFromEntities(kdNode.entities);\n        }\n        if (kdNode.left) {\n            this._createTilesFromKDNode(kdNode.left);\n        }\n        if (kdNode.right) {\n            this._createTilesFromKDNode(kdNode.right);\n        }\n    }\n\n    /**\n     * Creates a tile from the given entities.\n     *\n     * For each single-use {@link XKTPrimitive}, this method centers {@link XKTPrimitive#positions} to make them relative to the\n     * tile's center, then quantizes the positions to unsigned 16-bit integers, relative to the tile's boundary.\n     *\n     * @param entities\n     */\n    _createTileFromEntities(entities) {\n\n        let numBatchingEntities = 0; // TEST\n\n        const tileAABB = math.AABB3(); // A tighter World-space AABB around the entities\n        math.collapseAABB3(tileAABB);\n\n        for (let i = 0; i < entities.length; i++) {\n            const entity = entities [i];\n            math.expandAABB3(tileAABB, entity.aabb);\n        }\n\n        const tileCenter = math.getAABB3Center(tileAABB);\n        const tileCenterNeg = math.mulVec3Scalar(tileCenter, -1, math.vec3());\n\n        const rtcAABB = math.AABB3(); // AABB centered at the RTC origin\n\n        rtcAABB[0] = tileAABB[0] - tileCenter[0];\n        rtcAABB[1] = tileAABB[1] - tileCenter[1];\n        rtcAABB[2] = tileAABB[2] - tileCenter[2];\n        rtcAABB[3] = tileAABB[3] - tileCenter[0];\n        rtcAABB[4] = tileAABB[4] - tileCenter[1];\n        rtcAABB[5] = tileAABB[5] - tileCenter[2];\n\n        for (let i = 0; i < entities.length; i++) {\n\n            const entity = entities [i];\n\n            const primitiveInstances = entity.primitiveInstances;\n\n            if (entity.hasReusedPrimitives) {\n\n                // Post-multiply a translation to the entity's modeling matrix\n                // to center the entity's primitive instances to the tile RTC center\n\n                math.translateMat4v(tileCenterNeg, entity.matrix);\n\n            } else {\n\n                for (let j = 0, lenj = primitiveInstances.length; j < lenj; j++) {\n\n                    const primitiveInstance = primitiveInstances[j];\n                    const primitive = primitiveInstance.primitive;\n\n                    if (!primitive.reused) {\n\n                        const positions = primitive.positions;\n\n                        // Center positions relative to their tile's World-space center\n\n                        for (let k = 0, lenk = positions.length; k < lenk; k += 3) {\n\n                            positions[k + 0] -= tileCenter[0];\n                            positions[k + 1] -= tileCenter[1];\n                            positions[k + 2] -= tileCenter[2];\n                        }\n\n                        // Quantize positions relative to tile's RTC-space boundary\n\n                        geometryCompression.quantizePositions(positions, positions.length, rtcAABB, primitive.positionsQuantized);\n\n                        numBatchingEntities++;\n\n                    } else {\n\n\n                    }\n                }\n            }\n\n            entity.entityIndex = this.entitiesList.length;\n\n            this.entitiesList.push(entity);\n        }\n\n        const tile = new XKTTile(tileAABB, entities);\n\n        this.tilesList.push(tile);\n    }\n\n    _createReusedPrimitivesDecodeMatrix() {\n\n        const tempVec3a = math.vec3();\n        const reusedPrimitivesAABB = math.collapseAABB3(math.AABB3());\n        let countReusedPrimitives = 0;\n\n        for (let primitiveIndex = 0, numPrimitives = this.primitivesList.length; primitiveIndex < numPrimitives; primitiveIndex++) {\n\n            const primitive = this.primitivesList [primitiveIndex];\n\n            if (primitive.reused) {\n\n                const positions = primitive.positions;\n\n                for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                    tempVec3a[0] = positions[i];\n                    tempVec3a[1] = positions[i + 1];\n                    tempVec3a[2] = positions[i + 2];\n\n                    math.expandAABB3Point3(reusedPrimitivesAABB, tempVec3a);\n                }\n\n                countReusedPrimitives++;\n            }\n        }\n\n        if (countReusedPrimitives > 0) {\n            geometryCompression.createPositionsDecodeMatrix(reusedPrimitivesAABB, this.reusedPrimitivesDecodeMatrix);\n\n        } else {\n            math.identityMat4(this.reusedPrimitivesDecodeMatrix); // No need for this matrix, but we'll be tidy and set it to identity\n        }\n    }\n}\n\nexport {XKTModel};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-tools/src/XKTModel/XKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 78,
    "kind": "variable",
    "name": "tempVec4a",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~tempVec4a",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 79,
    "kind": "variable",
    "name": "tempVec4b",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~tempVec4b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 80,
    "kind": "variable",
    "name": "tempMat4",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~tempMat4",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 81,
    "kind": "variable",
    "name": "tempMat4b",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~tempMat4b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 82,
    "kind": "variable",
    "name": "MIN_TILE_DIAG",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~MIN_TILE_DIAG",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 83,
    "kind": "variable",
    "name": "kdTreeDimLength",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~kdTreeDimLength",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 84,
    "kind": "class",
    "name": "XKTModel",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~XKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTModel.js",
    "importStyle": "{XKTModel}",
    "description": "A document model that represents the contents of an .XKT V6 file.\n\n* An XKTModel contains {@link XKTTile}s, which spatially subdivide the model into regions.\n* Each {@link XKTTile} contains {@link XKTEntity}s, which represent the objects within its region.\n* Each {@link XKTEntity} has {@link XKTPrimitiveInstance}s, which indicate the {@link XKTPrimitive}s that comprise the {@link XKTEntity}.\n* Import glTF into an XKTModel using {@link loadGLTFIntoXKTModel}\n* Build an XKTModel programmatically using {@link XKTModel#createPrimitive} and {@link XKTModel#createEntity}\n* Serialize an XKTModel to an ArrayBuffer using {@link writeXKTModelToArrayBuffer}\n\n## Usage\n\nSee [main docs page](/docs/#javascript-api) for usage examples.",
    "lineNumber": 35,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTModel"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 85,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#constructor",
    "access": "public",
    "description": "Constructs a new XKTModel.",
    "lineNumber": 42,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg",
        "description": "Configuration"
      }
    ]
  },
  {
    "__docId__": 86,
    "kind": "member",
    "name": "reusedPrimitivesDecodeMatrix",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#reusedPrimitivesDecodeMatrix",
    "access": "public",
    "description": "The positions of all shared {@link XKTPrimitive}s are de-quantized using this singular\nde-quantization matrix.\n\nThis de-quantization matrix is which is generated from the collective boundary of the\npositions of all shared {@link XKTPrimitive}s.",
    "lineNumber": 53,
    "type": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 87,
    "kind": "member",
    "name": "primitives",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#primitives",
    "access": "public",
    "description": "{@link XKTPrimitive}s within this XKTModel, each mapped to {@link XKTPrimitive#primitiveId}.\n\nCreated by {@link XKTModel#createPrimitive}.",
    "lineNumber": 62,
    "type": {
      "nullable": null,
      "types": [
        "{Number:XKTPrimitive}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 88,
    "kind": "member",
    "name": "primitivesList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#primitivesList",
    "access": "public",
    "description": "{@link XKTPrimitive}s within this XKTModel, in the order they were created.\n\nCreated by {@link XKTModel#createPrimitive}.",
    "lineNumber": 71,
    "type": {
      "nullable": null,
      "types": [
        "XKTPrimitive[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 89,
    "kind": "member",
    "name": "primitiveInstancesList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#primitiveInstancesList",
    "access": "public",
    "description": "{@link XKTPrimitiveInstance}s within this XKTModel, in the order they were created.\n\nCreated by {@link XKTModel#createEntity}.",
    "lineNumber": 80,
    "type": {
      "nullable": null,
      "types": [
        "XKTPrimitiveInstance[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 90,
    "kind": "member",
    "name": "entities",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#entities",
    "access": "public",
    "description": "{@link XKTEntity}s within this XKTModel, each mapped to {@link XKTEntity#entityId}.\n\nCreated by {@link XKTModel#createEntity}.",
    "lineNumber": 89,
    "type": {
      "nullable": null,
      "types": [
        "{String:XKTEntity}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 91,
    "kind": "member",
    "name": "entitiesList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#entitiesList",
    "access": "public",
    "description": "{@link XKTEntity}s within this XKTModel.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 98,
    "type": {
      "nullable": null,
      "types": [
        "XKTEntity[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 92,
    "kind": "member",
    "name": "tilesList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#tilesList",
    "access": "public",
    "description": "{@link XKTTile}s within this Model.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 107,
    "type": {
      "nullable": null,
      "types": [
        "XKTTile[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 93,
    "kind": "member",
    "name": "finalized",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#finalized",
    "access": "public",
    "description": "Indicates if this XKTModel has been finalized.\n\nSet ````true```` by {@link XKTModel#finalize}.",
    "lineNumber": 116,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 94,
    "kind": "method",
    "name": "createPrimitive",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createPrimitive",
    "access": "public",
    "description": "Creates an {@link XKTPrimitive} within this XKTModel.\n\nLogs error and does nothing if this XKTModel has been (see {@link XKTModel#finalized}).",
    "lineNumber": 138,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{XKTPrimitive} The new {@link XKTPrimitive}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Method parameters."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "params.primitiveId",
        "description": "Unique ID for the {@link XKTPrimitive}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "params.primitiveType",
        "description": "The type of {@link XKTPrimitive}: \"triangles\", \"lines\" or \"points\""
      },
      {
        "nullable": null,
        "types": [
          "Float32Array"
        ],
        "spread": false,
        "optional": true,
        "name": "params.matrix",
        "description": "Modeling matrix for the {@link XKTPrimitive}. Overrides ````position````, ````scale```` and ````rotation```` parameters."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[0,0,0]",
        "defaultRaw": [
          0,
          0,
          0
        ],
        "name": "params.position",
        "description": "Position of the {@link XKTPrimitive}. Overridden by the ````matrix```` parameter."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[1,1,1]",
        "defaultRaw": [
          1,
          1,
          1
        ],
        "name": "params.scale",
        "description": "Scale of the {@link XKTPrimitive}. Overridden by the ````matrix```` parameter."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[0,0,0]",
        "defaultRaw": [
          0,
          0,
          0
        ],
        "name": "params.rotation",
        "description": "Rotation of the {@link XKTPrimitive} as Euler angles given in degrees, for each of the X, Y and Z axis. Overridden by the ````matrix```` parameter."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.color",
        "description": "RGB color for the {@link XKTPrimitive}, with each color component in range [0..1]."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "params.opacity",
        "description": "Opacity factor for the {@link XKTPrimitive}, in range [0..1]."
      },
      {
        "nullable": null,
        "types": [
          "Float64Array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.positions",
        "description": "Floating-point Local-space vertex positions for the {@link XKTPrimitive}."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "params.normals",
        "description": "Floating-point vertex normals for the {@link XKTPrimitive}."
      },
      {
        "nullable": null,
        "types": [
          "Uint32Array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.indices",
        "description": "Triangle mesh indices for the {@link XKTPrimitive}."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "XKTPrimitive"
      ],
      "spread": false,
      "description": "The new {@link XKTPrimitive}."
    }
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "createEntity",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createEntity",
    "access": "public",
    "description": "Creates an {@link XKTEntity} within this XKTModel.\n\nLogs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).",
    "lineNumber": 244,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{XKTEntity} The new {@link XKTEntity}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Method parameters."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "params.entityId",
        "description": "Unique ID for the {@link XKTEntity}."
      },
      {
        "nullable": null,
        "types": [
          "Float32Array"
        ],
        "spread": false,
        "optional": true,
        "name": "params.matrix",
        "description": "Modeling matrix for the {@link XKTEntity}. Overrides ````position````, ````scale```` and ````rotation```` parameters."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[0,0,0]",
        "defaultRaw": [
          0,
          0,
          0
        ],
        "name": "params.position",
        "description": "Position of the {@link XKTEntity}. Overridden by the ````matrix```` parameter."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[1,1,1]",
        "defaultRaw": [
          1,
          1,
          1
        ],
        "name": "params.scale",
        "description": "Scale of the {@link XKTEntity}. Overridden by the ````matrix```` parameter."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[0,0,0]",
        "defaultRaw": [
          0,
          0,
          0
        ],
        "name": "params.rotation",
        "description": "Rotation of the {@link XKTEntity} as Euler angles given in degrees, for each of the X, Y and Z axis. Overridden by the ````matrix```` parameter."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": false,
        "name": "params.primitiveIds",
        "description": "IDs of {@link XKTPrimitive}s used by the {@link XKTEntity}."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "XKTEntity"
      ],
      "spread": false,
      "description": "The new {@link XKTEntity}."
    }
  },
  {
    "__docId__": 96,
    "kind": "method",
    "name": "finalize",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#finalize",
    "access": "public",
    "description": "Finalizes this XKTModel.\n\nAfter finalizing, we may then serialize the model to an array buffer using {@link writeXKTModelToArrayBuffer}.\n\nLogs error and does nothing if this XKTModel has already been finalized.\n\nInternally, this method:\n\n* sets each {@link XKTEntity}'s {@link XKTEntity#hasReusedPrimitives} true if it shares its {@link XKTPrimitive}s with other {@link XKTEntity}s,\n* creates each {@link XKTEntity}'s {@link XKTEntity#aabb},\n* creates {@link XKTTile}s in {@link XKTModel#tilesList}, and\n* sets {@link XKTModel#finalized} ````true````.",
    "lineNumber": 327,
    "params": [],
    "return": null
  },
  {
    "__docId__": 98,
    "kind": "method",
    "name": "_flagEntitiesThatReusePrimitives",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_flagEntitiesThatReusePrimitives",
    "access": "private",
    "description": null,
    "lineNumber": 347,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 99,
    "kind": "method",
    "name": "_createEntityAABBs",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createEntityAABBs",
    "access": "private",
    "description": null,
    "lineNumber": 368,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 100,
    "kind": "method",
    "name": "_createKDTree",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createKDTree",
    "access": "private",
    "description": null,
    "lineNumber": 409,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "method",
    "name": "_insertEntityIntoKDTree",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_insertEntityIntoKDTree",
    "access": "private",
    "description": null,
    "lineNumber": 432,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "kdNode",
        "types": [
          "*"
        ]
      },
      {
        "name": "entity",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 102,
    "kind": "method",
    "name": "_createTilesFromKDTree",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createTilesFromKDTree",
    "access": "private",
    "description": null,
    "lineNumber": 500,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "rootKDNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 103,
    "kind": "method",
    "name": "_createTilesFromKDNode",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createTilesFromKDNode",
    "access": "private",
    "description": null,
    "lineNumber": 504,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "kdNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 104,
    "kind": "method",
    "name": "_createTileFromEntities",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createTileFromEntities",
    "access": "private",
    "description": "Creates a tile from the given entities.\n\nFor each single-use {@link XKTPrimitive}, this method centers {@link XKTPrimitive#positions} to make them relative to the\ntile's center, then quantizes the positions to unsigned 16-bit integers, relative to the tile's boundary.",
    "lineNumber": 524,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "entities",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "_createReusedPrimitivesDecodeMatrix",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createReusedPrimitivesDecodeMatrix",
    "access": "private",
    "description": null,
    "lineNumber": 604,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 106,
    "kind": "file",
    "name": "src/XKTModel/XKTPrimitive.js",
    "content": "/**\n * An element of reusable geometry within an {@link XKTModel}.\n *\n * * Created by {@link XKTModel#createPrimitive}\n * * Stored in {@link XKTModel#primitives} and {@link XKTModel#primitivesList}\n * * Referenced by {@link XKTPrimitiveInstance}s, which belong to {@link XKTEntity}s\n *\n * @class XKTPrimitive\n */\nclass XKTPrimitive {\n\n    /**\n     * @private\n     * @param {Number} primitiveId Unique ID of the primitive in {@link XKTModel#primitives}.\n     * @param {String} primitiveType Type of this primitive - \"triangles\" so far.\n     * @param {Number} primitiveIndex Index of this XKTPrimitive in {@link XKTModel#primitivesList}.\n     * @param {Uint8Array} color RGB color of this XKTPrimitive.\n     * @param {Number} opacity Opacity of this XKTPrimitive.\n     * @param {Float64Array} positions Non-quantized 3D vertex positions.\n     * @param {Int8Array} normalsOctEncoded Oct-encoded vertex normals.\n     * @param {Uint32Array} indices Indices to organize the vertex positions and normals into triangles.\n     * @param {Uint32Array} edgeIndices Indices to organize the vertex positions into edges.\n     */\n    constructor(primitiveId, primitiveType, primitiveIndex, color, opacity, positions, normalsOctEncoded, indices, edgeIndices) {\n\n        /**\n         * Unique ID of this XKTPrimitive in {@link XKTModel#primitives}.\n         *\n         * @type {Number}\n         */\n        this.primitiveId = primitiveId;\n\n        /**\n         * The type of primitive - \"triangles\" | \"points\" | \"lines\".\n         *\n         * @type {String}\n         */\n        this.primitiveType = primitiveType;\n\n        /**\n         * Index of this XKTPrimitive in {@link XKTModel#primitivesList}.\n         *\n         * @type {Number}\n         */\n        this.primitiveIndex = primitiveIndex;\n\n        /**\n         * RGB color of this XKTPrimitive.\n         *\n         * @type {Uint8Array}\n         */\n        this.color = color;\n\n        /**\n         * Opacity of this XKTPrimitive.\n         *\n         * @type {Number}\n         */\n        this.opacity = opacity;\n\n        /**\n         * The number of {@link XKTPrimitiveInstance}s that reference this XKTPrimitive.\n         *\n         * @type {Number}\n         */\n        this.numInstances = 0;\n\n        /**\n         * Non-quantized 3D vertex positions.\n         *\n         * @type {Float64Array}\n         */\n        this.positions = positions;\n\n        /**\n         * Quantized vertex positions.\n         *\n         * This array is later created from {@link XKTPrimitive#positions} by {@link XKTModel#finalize}.\n         *\n         * @type {Uint16Array}\n         */\n        this.positionsQuantized = new Uint16Array(positions.length);\n\n        /**\n         * Oct-encoded vertex normals.\n         *\n         * @type {Int8Array}\n         */\n        this.normalsOctEncoded = normalsOctEncoded;\n\n        /**\n         * Indices that organize the vertex positions and normals as triangles.\n         *\n         * @type {Uint32Array}\n         */\n        this.indices = indices;\n\n        /**\n         * Indices that organize the vertex positions as edges.\n         *\n         * @type {Uint32Array}\n         */\n        this.edgeIndices = edgeIndices;\n    }\n\n    /**\n     * Convenience property that is ````true```` when {@link XKTPrimitive#numInstances} is greater that one.\n     * @returns {boolean}\n     */\n    get reused() {\n        return (this.numInstances > 1);\n    }\n}\n\nexport {XKTPrimitive};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-tools/src/XKTModel/XKTPrimitive.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 107,
    "kind": "class",
    "name": "XKTPrimitive",
    "memberof": "src/XKTModel/XKTPrimitive.js",
    "static": true,
    "longname": "src/XKTModel/XKTPrimitive.js~XKTPrimitive",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTPrimitive.js",
    "importStyle": "{XKTPrimitive}",
    "description": "An element of reusable geometry within an {@link XKTModel}.\n\n* Created by {@link XKTModel#createPrimitive}\n* Stored in {@link XKTModel#primitives} and {@link XKTModel#primitivesList}\n* Referenced by {@link XKTPrimitiveInstance}s, which belong to {@link XKTEntity}s",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTPrimitive"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 108,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTPrimitive.js~XKTPrimitive",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTPrimitive.js~XKTPrimitive#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 24,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "primitiveId",
        "description": "Unique ID of the primitive in {@link XKTModel#primitives}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "primitiveType",
        "description": "Type of this primitive - \"triangles\" so far."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "primitiveIndex",
        "description": "Index of this XKTPrimitive in {@link XKTModel#primitivesList}."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "color",
        "description": "RGB color of this XKTPrimitive."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "opacity",
        "description": "Opacity of this XKTPrimitive."
      },
      {
        "nullable": null,
        "types": [
          "Float64Array"
        ],
        "spread": false,
        "optional": false,
        "name": "positions",
        "description": "Non-quantized 3D vertex positions."
      },
      {
        "nullable": null,
        "types": [
          "Int8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "normalsOctEncoded",
        "description": "Oct-encoded vertex normals."
      },
      {
        "nullable": null,
        "types": [
          "Uint32Array"
        ],
        "spread": false,
        "optional": false,
        "name": "indices",
        "description": "Indices to organize the vertex positions and normals into triangles."
      },
      {
        "nullable": null,
        "types": [
          "Uint32Array"
        ],
        "spread": false,
        "optional": false,
        "name": "edgeIndices",
        "description": "Indices to organize the vertex positions into edges."
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 109,
    "kind": "member",
    "name": "primitiveId",
    "memberof": "src/XKTModel/XKTPrimitive.js~XKTPrimitive",
    "static": false,
    "longname": "src/XKTModel/XKTPrimitive.js~XKTPrimitive#primitiveId",
    "access": "public",
    "description": "Unique ID of this XKTPrimitive in {@link XKTModel#primitives}.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 110,
    "kind": "member",
    "name": "primitiveType",
    "memberof": "src/XKTModel/XKTPrimitive.js~XKTPrimitive",
    "static": false,
    "longname": "src/XKTModel/XKTPrimitive.js~XKTPrimitive#primitiveType",
    "access": "public",
    "description": "The type of primitive - \"triangles\" | \"points\" | \"lines\".",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 111,
    "kind": "member",
    "name": "primitiveIndex",
    "memberof": "src/XKTModel/XKTPrimitive.js~XKTPrimitive",
    "static": false,
    "longname": "src/XKTModel/XKTPrimitive.js~XKTPrimitive#primitiveIndex",
    "access": "public",
    "description": "Index of this XKTPrimitive in {@link XKTModel#primitivesList}.",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 112,
    "kind": "member",
    "name": "color",
    "memberof": "src/XKTModel/XKTPrimitive.js~XKTPrimitive",
    "static": false,
    "longname": "src/XKTModel/XKTPrimitive.js~XKTPrimitive#color",
    "access": "public",
    "description": "RGB color of this XKTPrimitive.",
    "lineNumber": 52,
    "type": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 113,
    "kind": "member",
    "name": "opacity",
    "memberof": "src/XKTModel/XKTPrimitive.js~XKTPrimitive",
    "static": false,
    "longname": "src/XKTModel/XKTPrimitive.js~XKTPrimitive#opacity",
    "access": "public",
    "description": "Opacity of this XKTPrimitive.",
    "lineNumber": 59,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 114,
    "kind": "member",
    "name": "numInstances",
    "memberof": "src/XKTModel/XKTPrimitive.js~XKTPrimitive",
    "static": false,
    "longname": "src/XKTModel/XKTPrimitive.js~XKTPrimitive#numInstances",
    "access": "public",
    "description": "The number of {@link XKTPrimitiveInstance}s that reference this XKTPrimitive.",
    "lineNumber": 66,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 115,
    "kind": "member",
    "name": "positions",
    "memberof": "src/XKTModel/XKTPrimitive.js~XKTPrimitive",
    "static": false,
    "longname": "src/XKTModel/XKTPrimitive.js~XKTPrimitive#positions",
    "access": "public",
    "description": "Non-quantized 3D vertex positions.",
    "lineNumber": 73,
    "type": {
      "nullable": null,
      "types": [
        "Float64Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 116,
    "kind": "member",
    "name": "positionsQuantized",
    "memberof": "src/XKTModel/XKTPrimitive.js~XKTPrimitive",
    "static": false,
    "longname": "src/XKTModel/XKTPrimitive.js~XKTPrimitive#positionsQuantized",
    "access": "public",
    "description": "Quantized vertex positions.\n\nThis array is later created from {@link XKTPrimitive#positions} by {@link XKTModel#finalize}.",
    "lineNumber": 82,
    "type": {
      "nullable": null,
      "types": [
        "Uint16Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 117,
    "kind": "member",
    "name": "normalsOctEncoded",
    "memberof": "src/XKTModel/XKTPrimitive.js~XKTPrimitive",
    "static": false,
    "longname": "src/XKTModel/XKTPrimitive.js~XKTPrimitive#normalsOctEncoded",
    "access": "public",
    "description": "Oct-encoded vertex normals.",
    "lineNumber": 89,
    "type": {
      "nullable": null,
      "types": [
        "Int8Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 118,
    "kind": "member",
    "name": "indices",
    "memberof": "src/XKTModel/XKTPrimitive.js~XKTPrimitive",
    "static": false,
    "longname": "src/XKTModel/XKTPrimitive.js~XKTPrimitive#indices",
    "access": "public",
    "description": "Indices that organize the vertex positions and normals as triangles.",
    "lineNumber": 96,
    "type": {
      "nullable": null,
      "types": [
        "Uint32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 119,
    "kind": "member",
    "name": "edgeIndices",
    "memberof": "src/XKTModel/XKTPrimitive.js~XKTPrimitive",
    "static": false,
    "longname": "src/XKTModel/XKTPrimitive.js~XKTPrimitive#edgeIndices",
    "access": "public",
    "description": "Indices that organize the vertex positions as edges.",
    "lineNumber": 103,
    "type": {
      "nullable": null,
      "types": [
        "Uint32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 120,
    "kind": "get",
    "name": "reused",
    "memberof": "src/XKTModel/XKTPrimitive.js~XKTPrimitive",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTPrimitive.js~XKTPrimitive#reused",
    "access": "public",
    "description": "Convenience property that is ````true```` when {@link XKTPrimitive#numInstances} is greater that one.",
    "lineNumber": 110,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 121,
    "kind": "file",
    "name": "src/XKTModel/XKTPrimitiveInstance.js",
    "content": "/**\n * A usage of a {@link XKTPrimitive} by an {@link XKTEntity}.\n *\n * * Created by {@link XKTModel#createEntity}\n * * Stored in {@link XKTEntity#primitiveInstances} and {@link XKTModel#primitiveInstancesList}\n *\n * @class XKTPrimitiveInstance\n */\nclass XKTPrimitiveInstance {\n\n    /**\n     * @private\n     * @param primitiveInstanceIndex\n     * @param primitive\n     */\n    constructor(primitiveInstanceIndex, primitive) {\n\n        /**\n         * Index of this PrimitiveInstance in {@link XKTModel#primitiveInstancesList};\n         *\n         * @type {Number}\n         */\n        this.primitiveInstanceIndex = primitiveInstanceIndex;\n\n        /**\n         * The instanced {@link XKTPrimitive}.\n         *\n         * @type {XKTPrimitive}\n         */\n        this.primitive = primitive;\n\n        /**\n         * The owner {@link XKTEntity}.\n         *\n         * @type {XKTEntity}\n         */\n        this.entity = null; // Set after instantiation, when the Entity is known\n    }\n}\n\nexport {XKTPrimitiveInstance};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-tools/src/XKTModel/XKTPrimitiveInstance.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 122,
    "kind": "class",
    "name": "XKTPrimitiveInstance",
    "memberof": "src/XKTModel/XKTPrimitiveInstance.js",
    "static": true,
    "longname": "src/XKTModel/XKTPrimitiveInstance.js~XKTPrimitiveInstance",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTPrimitiveInstance.js",
    "importStyle": "{XKTPrimitiveInstance}",
    "description": "A usage of a {@link XKTPrimitive} by an {@link XKTEntity}.\n\n* Created by {@link XKTModel#createEntity}\n* Stored in {@link XKTEntity#primitiveInstances} and {@link XKTModel#primitiveInstancesList}",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTPrimitiveInstance"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 123,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTPrimitiveInstance.js~XKTPrimitiveInstance",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTPrimitiveInstance.js~XKTPrimitiveInstance#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "primitiveInstanceIndex",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "primitive",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 124,
    "kind": "member",
    "name": "primitiveInstanceIndex",
    "memberof": "src/XKTModel/XKTPrimitiveInstance.js~XKTPrimitiveInstance",
    "static": false,
    "longname": "src/XKTModel/XKTPrimitiveInstance.js~XKTPrimitiveInstance#primitiveInstanceIndex",
    "access": "public",
    "description": "Index of this PrimitiveInstance in {@link XKTModel#primitiveInstancesList};",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 125,
    "kind": "member",
    "name": "primitive",
    "memberof": "src/XKTModel/XKTPrimitiveInstance.js~XKTPrimitiveInstance",
    "static": false,
    "longname": "src/XKTModel/XKTPrimitiveInstance.js~XKTPrimitiveInstance#primitive",
    "access": "public",
    "description": "The instanced {@link XKTPrimitive}.",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "XKTPrimitive"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 126,
    "kind": "member",
    "name": "entity",
    "memberof": "src/XKTModel/XKTPrimitiveInstance.js~XKTPrimitiveInstance",
    "static": false,
    "longname": "src/XKTModel/XKTPrimitiveInstance.js~XKTPrimitiveInstance#entity",
    "access": "public",
    "description": "The owner {@link XKTEntity}.",
    "lineNumber": 37,
    "type": {
      "nullable": null,
      "types": [
        "XKTEntity"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 127,
    "kind": "file",
    "name": "src/XKTModel/XKTTile.js",
    "content": "/**\n * @desc A box-shaped 3D region within an {@link XKTModel} that contains {@link XKTEntity}s.\n *\n * * Created by {@link XKTModel#finalize}\n * * Stored in {@link XKTModel#tilesList}\n *\n * @class XKTTile\n */\nclass XKTTile {\n\n    /**\n     * Creates a new XKTTile.\n     *\n     * @private\n     * @param aabb\n     * @param entities\n     */\n    constructor(aabb, entities) {\n\n        /**\n         * Axis-aligned World-space bounding box that encloses the {@link XKTEntity}'s within this Tile.\n         *\n         * @type {Float64Array}\n         */\n        this.aabb = aabb;\n\n        /**\n         * The {@link XKTEntity}'s within this XKTTile.\n         *\n         * @type {XKTEntity[]}\n         */\n        this.entities = entities;\n    }\n}\n\nexport {XKTTile};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-tools/src/XKTModel/XKTTile.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 128,
    "kind": "class",
    "name": "XKTTile",
    "memberof": "src/XKTModel/XKTTile.js",
    "static": true,
    "longname": "src/XKTModel/XKTTile.js~XKTTile",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/XKTTile.js",
    "importStyle": "{XKTTile}",
    "description": "A box-shaped 3D region within an {@link XKTModel} that contains {@link XKTEntity}s.\n\n* Created by {@link XKTModel#finalize}\n* Stored in {@link XKTModel#tilesList}",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTTile"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 129,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTTile.js~XKTTile",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTTile.js~XKTTile#constructor",
    "access": "private",
    "description": "Creates a new XKTTile.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "aabb",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "entities",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 130,
    "kind": "member",
    "name": "aabb",
    "memberof": "src/XKTModel/XKTTile.js~XKTTile",
    "static": false,
    "longname": "src/XKTModel/XKTTile.js~XKTTile#aabb",
    "access": "public",
    "description": "Axis-aligned World-space bounding box that encloses the {@link XKTEntity}'s within this Tile.",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "Float64Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 131,
    "kind": "member",
    "name": "entities",
    "memberof": "src/XKTModel/XKTTile.js~XKTTile",
    "static": false,
    "longname": "src/XKTModel/XKTTile.js~XKTTile#entities",
    "access": "public",
    "description": "The {@link XKTEntity}'s within this XKTTile.",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "XKTEntity[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 132,
    "kind": "file",
    "name": "src/XKTModel/lib/buildEdgeIndices.js",
    "content": "//const math = require('./math');\n\nimport {math} from \"../lib/math.js\";\n\n/**\n * @private\n */\nconst buildEdgeIndices = (function () {\n\n    const uniquePositions = [];\n    const indicesLookup = [];\n    const indicesReverseLookup = [];\n    const weldedIndices = [];\n\n// TODO: Optimize with caching, but need to cater to both compressed and uncompressed positions\n\n    const faces = [];\n    let numFaces = 0;\n    const compa = new Uint16Array(3);\n    const compb = new Uint16Array(3);\n    const compc = new Uint16Array(3);\n    const a = math.vec3();\n    const b = math.vec3();\n    const c = math.vec3();\n    const cb = math.vec3();\n    const ab = math.vec3();\n    const cross = math.vec3();\n    const normal = math.vec3();\n\n    function weldVertices(positions, indices) {\n        const positionsMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n        let vx;\n        let vy;\n        let vz;\n        let key;\n        const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n        const precision = Math.pow(10, precisionPoints);\n        let i;\n        let len;\n        let lenUniquePositions = 0;\n        for (i = 0, len = positions.length; i < len; i += 3) {\n            vx = positions[i];\n            vy = positions[i + 1];\n            vz = positions[i + 2];\n            key = Math.round(vx * precision) + '_' + Math.round(vy * precision) + '_' + Math.round(vz * precision);\n            if (positionsMap[key] === undefined) {\n                positionsMap[key] = lenUniquePositions / 3;\n                uniquePositions[lenUniquePositions++] = vx;\n                uniquePositions[lenUniquePositions++] = vy;\n                uniquePositions[lenUniquePositions++] = vz;\n            }\n            indicesLookup[i / 3] = positionsMap[key];\n        }\n        for (i = 0, len = indices.length; i < len; i++) {\n            weldedIndices[i] = indicesLookup[indices[i]];\n            indicesReverseLookup[weldedIndices[i]] = indices[i];\n        }\n    }\n\n    function buildFaces(numIndices, positionsDecodeMatrix) {\n        numFaces = 0;\n        for (let i = 0, len = numIndices; i < len; i += 3) {\n            const ia = ((weldedIndices[i]) * 3);\n            const ib = ((weldedIndices[i + 1]) * 3);\n            const ic = ((weldedIndices[i + 2]) * 3);\n            if (positionsDecodeMatrix) {\n                compa[0] = uniquePositions[ia];\n                compa[1] = uniquePositions[ia + 1];\n                compa[2] = uniquePositions[ia + 2];\n                compb[0] = uniquePositions[ib];\n                compb[1] = uniquePositions[ib + 1];\n                compb[2] = uniquePositions[ib + 2];\n                compc[0] = uniquePositions[ic];\n                compc[1] = uniquePositions[ic + 1];\n                compc[2] = uniquePositions[ic + 2];\n                // Decode\n                math.decompressPosition(compa, positionsDecodeMatrix, a);\n                math.decompressPosition(compb, positionsDecodeMatrix, b);\n                math.decompressPosition(compc, positionsDecodeMatrix, c);\n            } else {\n                a[0] = uniquePositions[ia];\n                a[1] = uniquePositions[ia + 1];\n                a[2] = uniquePositions[ia + 2];\n                b[0] = uniquePositions[ib];\n                b[1] = uniquePositions[ib + 1];\n                b[2] = uniquePositions[ib + 2];\n                c[0] = uniquePositions[ic];\n                c[1] = uniquePositions[ic + 1];\n                c[2] = uniquePositions[ic + 2];\n            }\n            math.subVec3(c, b, cb);\n            math.subVec3(a, b, ab);\n            math.cross3Vec3(cb, ab, cross);\n            math.normalizeVec3(cross, normal);\n            const face = faces[numFaces] || (faces[numFaces] = {normal: math.vec3()});\n            face.normal[0] = normal[0];\n            face.normal[1] = normal[1];\n            face.normal[2] = normal[2];\n            numFaces++;\n        }\n    }\n\n    return function (positions, indices, positionsDecodeMatrix, edgeThreshold) {\n        weldVertices(positions, indices);\n        buildFaces(indices.length, positionsDecodeMatrix);\n        const edgeIndices = [];\n        const thresholdDot = Math.cos(math.DEGTORAD * edgeThreshold);\n        const edges = {};\n        let edge1;\n        let edge2;\n        let index1;\n        let index2;\n        let key;\n        let largeIndex = false;\n        let edge;\n        let normal1;\n        let normal2;\n        let dot;\n        let ia;\n        let ib;\n        for (let i = 0, len = indices.length; i < len; i += 3) {\n            const faceIndex = i / 3;\n            for (let j = 0; j < 3; j++) {\n                edge1 = weldedIndices[i + j];\n                edge2 = weldedIndices[i + ((j + 1) % 3)];\n                index1 = Math.min(edge1, edge2);\n                index2 = Math.max(edge1, edge2);\n                key = index1 + ',' + index2;\n                if (edges[key] === undefined) {\n                    edges[key] = {\n                        index1: index1,\n                        index2: index2,\n                        face1: faceIndex,\n                        face2: undefined,\n                    };\n                } else {\n                    edges[key].face2 = faceIndex;\n                }\n            }\n        }\n        for (key in edges) {\n            edge = edges[key];\n            // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\n            if (edge.face2 !== undefined) {\n                normal1 = faces[edge.face1].normal;\n                normal2 = faces[edge.face2].normal;\n                dot = math.dotVec3(normal1, normal2);\n                if (dot > thresholdDot) {\n                    continue;\n                }\n            }\n            ia = indicesReverseLookup[edge.index1];\n            ib = indicesReverseLookup[edge.index2];\n            if (!largeIndex && ia > 65535 || ib > 65535) {\n                largeIndex = true;\n            }\n            edgeIndices.push(ia);\n            edgeIndices.push(ib);\n        }\n        return (largeIndex) ? new Uint32Array(edgeIndices) : new Uint16Array(edgeIndices);\n    };\n})();\n\n\nexport {buildEdgeIndices};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-tools/src/XKTModel/lib/buildEdgeIndices.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 133,
    "kind": "variable",
    "name": "buildEdgeIndices",
    "memberof": "src/XKTModel/lib/buildEdgeIndices.js",
    "static": true,
    "longname": "src/XKTModel/lib/buildEdgeIndices.js~buildEdgeIndices",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/buildEdgeIndices.js",
    "importStyle": "{buildEdgeIndices}",
    "description": "",
    "lineNumber": 8,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "file",
    "name": "src/XKTModel/lib/geometryCompression.js",
    "content": "import {math} from \"./math.js\";\n\nvar quantizePositions = function (positions, lenPositions, aabb, quantizedPositions) {\n    const xmin = aabb[0];\n    const ymin = aabb[1];\n    const zmin = aabb[2];\n    const xwid = aabb[3] - xmin;\n    const ywid = aabb[4] - ymin;\n    const zwid = aabb[5] - zmin;\n    const maxInt = 65535;\n    const xMultiplier = maxInt / xwid;\n    const yMultiplier = maxInt / ywid;\n    const zMultiplier = maxInt / zwid;\n    let i;\n    for (i = 0; i < lenPositions; i += 3) {\n        quantizedPositions[i + 0] = Math.floor((positions[i + 0] - xmin) * xMultiplier);\n        quantizedPositions[i + 1] = Math.floor((positions[i + 1] - ymin) * yMultiplier);\n        quantizedPositions[i + 2] = Math.floor((positions[i + 2] - zmin) * zMultiplier);\n    }\n};\n\nvar createPositionsDecodeMatrix = (function () {\n    const translate = math.mat4();\n    const scale = math.mat4();\n    return function (aabb, positionsDecodeMatrix) {\n        positionsDecodeMatrix = positionsDecodeMatrix || math.mat4();\n        const xmin = aabb[0];\n        const ymin = aabb[1];\n        const zmin = aabb[2];\n        const xwid = aabb[3] - xmin;\n        const ywid = aabb[4] - ymin;\n        const zwid = aabb[5] - zmin;\n        const maxInt = 65535;\n        math.identityMat4(translate);\n        math.translationMat4v(aabb, translate);\n        math.identityMat4(scale);\n        math.scalingMat4v([xwid / maxInt, ywid / maxInt, zwid / maxInt], scale);\n        math.mulMat4(translate, scale, positionsDecodeMatrix);\n        return positionsDecodeMatrix;\n    };\n})();\n\nfunction transformAndOctEncodeNormals(modelNormalMatrix, normals, lenNormals, compressedNormals, lenCompressedNormals) {\n    // http://jcgt.org/published/0003/02/01/\n    let oct, dec, best, currentCos, bestCos;\n    let i, ei;\n    let localNormal = new Float32Array([0, 0, 0, 0]);\n    let worldNormal = new Float32Array([0, 0, 0, 0]);\n    for (i = 0; i < lenNormals; i += 3) {\n        localNormal[0] = normals[i];\n        localNormal[1] = normals[i + 1];\n        localNormal[2] = normals[i + 2];\n\n        math.transformVec3(modelNormalMatrix, localNormal, worldNormal);\n        math.normalizeVec3(worldNormal, worldNormal);\n\n        // Test various combinations of ceil and floor to minimize rounding errors\n        best = oct = octEncodeVec3(worldNormal, 0, \"floor\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = bestCos = dot(worldNormal, 0, dec);\n        oct = octEncodeVec3(worldNormal, 0, \"ceil\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, 0, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(worldNormal, 0, \"floor\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, 0, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(worldNormal, 0, \"ceil\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, 0, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        compressedNormals[lenCompressedNormals + i + 0] = best[0];\n        compressedNormals[lenCompressedNormals + i + 1] = best[1];\n        compressedNormals[lenCompressedNormals + i + 2] = 0.0; // Unused\n    }\n    lenCompressedNormals += lenNormals;\n    return lenCompressedNormals;\n}\n\nfunction octEncodeNormals(normals, lenNormals, compressedNormals, lenCompressedNormals) { // http://jcgt.org/published/0003/02/01/\n    let oct, dec, best, currentCos, bestCos;\n    for (let i = 0; i < lenNormals; i += 3) {\n        // Test various combinations of ceil and floor to minimize rounding errors\n        best = oct = octEncodeVec3(normals, i, \"floor\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = bestCos = dot(normals, i, dec);\n        oct = octEncodeVec3(normals, i, \"ceil\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(normals, i, \"floor\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(normals, i, \"ceil\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        compressedNormals[lenCompressedNormals + i + 0] = best[0];\n        compressedNormals[lenCompressedNormals + i + 1] = best[1];\n        compressedNormals[lenCompressedNormals + i + 2] = 0.0; // Unused\n    }\n    lenCompressedNormals += lenNormals;\n    return lenCompressedNormals;\n}\n\n/**\n * @private\n */\nfunction octEncodeVec3(array, i, xfunc, yfunc) { // Oct-encode single normal vector in 2 bytes\n    let x = array[i] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    let y = array[i + 1] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    if (array[i + 2] < 0) {\n        let tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        let tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        x = tempx;\n        y = tempy;\n    }\n    return new Int8Array([\n        Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)),\n        Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))\n    ]);\n}\n\n/**\n * Decode an oct-encoded normal\n */\nfunction octDecodeVec2(oct) {\n    let x = oct[0];\n    let y = oct[1];\n    x /= x < 0 ? 127 : 128;\n    y /= y < 0 ? 127 : 128;\n    const z = 1 - Math.abs(x) - Math.abs(y);\n    if (z < 0) {\n        x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n    }\n    const length = Math.sqrt(x * x + y * y + z * z);\n    return [\n        x / length,\n        y / length,\n        z / length\n    ];\n}\n\n/**\n * Dot product of a normal in an array against a candidate decoding\n * @private\n */\nfunction dot(array, i, vec3) {\n    return array[i] * vec3[0] + array[i + 1] * vec3[1] + array[i + 2] * vec3[2];\n}\n\n/**\n * @private\n */\nconst geometryCompression = {\n    quantizePositions,\n    createPositionsDecodeMatrix,\n    transformAndOctEncodeNormals,\n    octEncodeNormals,\n};\n\nexport {geometryCompression}",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-tools/src/XKTModel/lib/geometryCompression.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 135,
    "kind": "function",
    "name": "quantizePositions",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~quantizePositions",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenPositions",
        "types": [
          "*"
        ]
      },
      {
        "name": "aabb",
        "types": [
          "*"
        ]
      },
      {
        "name": "quantizedPositions",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 136,
    "kind": "variable",
    "name": "createPositionsDecodeMatrix",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~createPositionsDecodeMatrix",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 137,
    "kind": "function",
    "name": "transformAndOctEncodeNormals",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~transformAndOctEncodeNormals",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "params": [
      {
        "name": "modelNormalMatrix",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenNormals",
        "types": [
          "*"
        ]
      },
      {
        "name": "compressedNormals",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenCompressedNormals",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 138,
    "kind": "function",
    "name": "octEncodeNormals",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~octEncodeNormals",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "params": [
      {
        "name": "normals",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenNormals",
        "types": [
          "*"
        ]
      },
      {
        "name": "compressedNormals",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenCompressedNormals",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 139,
    "kind": "function",
    "name": "octEncodeVec3",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~octEncodeVec3",
    "access": "private",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 129,
    "ignore": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      },
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "xfunc",
        "types": [
          "*"
        ]
      },
      {
        "name": "yfunc",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "function",
    "name": "octDecodeVec2",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~octDecodeVec2",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": "Decode an oct-encoded normal",
    "lineNumber": 147,
    "params": [
      {
        "name": "oct",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 141,
    "kind": "function",
    "name": "dot",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~dot",
    "access": "private",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": "Dot product of a normal in an array against a candidate decoding",
    "lineNumber": 169,
    "ignore": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      },
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "vec3",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "variable",
    "name": "geometryCompression",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~geometryCompression",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/geometryCompression.js",
    "importStyle": "{geometryCompression}",
    "description": "",
    "lineNumber": 176,
    "ignore": true,
    "type": {
      "types": [
        "{\"quantizePositions\": *, \"createPositionsDecodeMatrix\": *, \"transformAndOctEncodeNormals\": *, \"octEncodeNormals\": *}"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "file",
    "name": "src/XKTModel/lib/math.js",
    "content": "// Some temporary vars to help avoid garbage collection\n\nconst doublePrecision = true;\nconst FloatArrayType = doublePrecision ? Float64Array : Float32Array;\n\nconst tempMat1 = new FloatArrayType(16);\nconst tempMat2 = new FloatArrayType(16);\nconst tempVec4 = new FloatArrayType(4);\n\n/**\n * @private\n */\nconst math = {\n\n    MAX_DOUBLE: Number.MAX_VALUE,\n    MIN_DOUBLE: Number.MIN_VALUE,\n\n    /**\n     * The number of radiians in a degree (0.0174532925).\n     * @property DEGTORAD\n     * @type {Number}\n     */\n    DEGTORAD: 0.0174532925,\n\n    /**\n     * The number of degrees in a radian.\n     * @property RADTODEG\n     * @type {Number}\n     */\n    RADTODEG: 57.295779513,\n\n    /**\n     * Returns a new, uninitialized two-element vector.\n     * @method vec2\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec2(values) {\n        return new FloatArrayType(values || 2);\n    },\n\n    /**\n     * Returns a new, uninitialized three-element vector.\n     * @method vec3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec3(values) {\n        return new FloatArrayType(values || 3);\n    },\n\n    /**\n     * Returns a new, uninitialized four-element vector.\n     * @method vec4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec4(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3x3 matrix.\n     * @method mat3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat3(values) {\n        return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Converts a 3x3 matrix to 4x4\n     * @method mat3ToMat4\n     * @param mat3 3x3 matrix.\n     * @param mat4 4x4 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat3ToMat4(mat3, mat4 = new FloatArrayType(16)) {\n        mat4[0] = mat3[0];\n        mat4[1] = mat3[1];\n        mat4[2] = mat3[2];\n        mat4[3] = 0;\n        mat4[4] = mat3[3];\n        mat4[5] = mat3[4];\n        mat4[6] = mat3[5];\n        mat4[7] = 0;\n        mat4[8] = mat3[6];\n        mat4[9] = mat3[7];\n        mat4[10] = mat3[8];\n        mat4[11] = 0;\n        mat4[12] = 0;\n        mat4[13] = 0;\n        mat4[14] = 0;\n        mat4[15] = 1;\n        return mat4;\n    },\n\n    /**\n     * Returns a new, uninitialized 4x4 matrix.\n     * @method mat4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat4(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /**\n     * Converts a 4x4 matrix to 3x3\n     * @method mat4ToMat3\n     * @param mat4 4x4 matrix.\n     * @param mat3 3x3 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat4ToMat3(mat4, mat3) { // TODO\n        //return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Returns a new UUID.\n     * @method createUUID\n     * @static\n     * @return string The new UUID\n     */\n    createUUID: ((() => {\n        const self = {};\n        const lut = [];\n        for (let i = 0; i < 256; i++) {\n            lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n        }\n        return () => {\n            const d0 = Math.random() * 0xffffffff | 0;\n            const d1 = Math.random() * 0xffffffff | 0;\n            const d2 = Math.random() * 0xffffffff | 0;\n            const d3 = Math.random() * 0xffffffff | 0;\n            return `${lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff]}-${lut[d1 & 0xff]}${lut[d1 >> 8 & 0xff]}-${lut[d1 >> 16 & 0x0f | 0x40]}${lut[d1 >> 24 & 0xff]}-${lut[d2 & 0x3f | 0x80]}${lut[d2 >> 8 & 0xff]}-${lut[d2 >> 16 & 0xff]}${lut[d2 >> 24 & 0xff]}${lut[d3 & 0xff]}${lut[d3 >> 8 & 0xff]}${lut[d3 >> 16 & 0xff]}${lut[d3 >> 24 & 0xff]}`;\n        };\n    }))(),\n\n    /**\n     * Clamps a value to the given range.\n     * @param {Number} value Value to clamp.\n     * @param {Number} min Lower bound.\n     * @param {Number} max Upper bound.\n     * @returns {Number} Clamped result.\n     */\n    clamp(value, min, max) {\n        return Math.max(min, Math.min(max, value));\n    },\n\n    /**\n     * Floating-point modulus\n     * @method fmod\n     * @static\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {*}\n     */\n    fmod(a, b) {\n        if (a < b) {\n            console.error(\"math.fmod : Attempting to find modulus within negative range - would be infinite loop - ignoring\");\n            return a;\n        }\n        while (b <= a) {\n            a -= b;\n        }\n        return a;\n    },\n\n    /**\n     * Negates a four-element vector.\n     * @method negateVec4\n     * @static\n     * @param {Array(Number)} v Vector to negate\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    negateVec4(v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = -v[0];\n        dest[1] = -v[1];\n        dest[2] = -v[2];\n        dest[3] = -v[3];\n        return dest;\n    },\n\n    /**\n     * Adds one four-element vector to another.\n     * @method addVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        dest[3] = u[3] + v[3];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a four-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        dest[3] = v[3] + s;\n        return dest;\n    },\n\n    /**\n     * Adds one three-element vector to another.\n     * @method addVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a three-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        return dest;\n    },\n\n    /**\n     * Subtracts one four-element vector from another.\n     * @method subVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        dest[3] = u[3] - v[3];\n        return dest;\n    },\n\n    /**\n     * Subtracts one three-element vector from another.\n     * @method subVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        return dest;\n    },\n\n    /**\n     * Subtracts one two-element vector from another.\n     * @method subVec2\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec2(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        return dest;\n    },\n\n    /**\n     * Subtracts a scalar value from each element of a four-element vector.\n     * @method subVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] - s;\n        dest[1] = v[1] - s;\n        dest[2] = v[2] - s;\n        dest[3] = v[3] - s;\n        return dest;\n    },\n\n    /**\n     * Sets each element of a 4-element vector to a scalar value minus the value of that element.\n     * @method subScalarVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subScalarVec4(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s - v[0];\n        dest[1] = s - v[1];\n        dest[2] = s - v[2];\n        dest[3] = s - v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies one three-element vector by another.\n     * @method mulVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    mulVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] * v[0];\n        dest[1] = u[1] * v[1];\n        dest[2] = u[2] * v[2];\n        dest[3] = u[3] * v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a four-element vector by a scalar.\n     * @method mulVec34calar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        dest[3] = v[3] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a three-element vector by a scalar.\n     * @method mulVec3Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a two-element vector by a scalar.\n     * @method mulVec2Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec2Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        return dest;\n    },\n\n    /**\n     * Divides one three-element vector by another.\n     * @method divVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides one four-element vector by another.\n     * @method divVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        dest[3] = u[3] / v[3];\n        return dest;\n    },\n\n    /**\n     * Divides a scalar by a three-element vector, returning a new vector.\n     * @method divScalarVec3\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec3(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides a three-element vector by a scalar.\n     * @method divVec3Scalar\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        return dest;\n    },\n\n    /**\n     * Divides a four-element vector by a scalar.\n     * @method divVec4Scalar\n     * @static\n     * @param v vec4\n     * @param s scalar\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        dest[3] = v[3] / s;\n        return dest;\n    },\n\n\n    /**\n     * Divides a scalar by a four-element vector, returning a new vector.\n     * @method divScalarVec4\n     * @static\n     * @param s scalar\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec4(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        dest[3] = s / v[3];\n        return dest;\n    },\n\n    /**\n     * Returns the dot product of two four-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec4(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3]);\n    },\n\n    /**\n     * Returns the cross product of two four-element vectors.\n     * @method cross3Vec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec4(u, v) {\n        const u0 = u[0];\n        const u1 = u[1];\n        const u2 = u[2];\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        return [\n            u1 * v2 - u2 * v1,\n            u2 * v0 - u0 * v2,\n            u0 * v1 - u1 * v0,\n            0.0];\n    },\n\n    /**\n     * Returns the cross product of two three-element vectors.\n     * @method cross3Vec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        const x = u[0];\n        const y = u[1];\n        const z = u[2];\n        const x2 = v[0];\n        const y2 = v[1];\n        const z2 = v[2];\n        dest[0] = y * z2 - z * y2;\n        dest[1] = z * x2 - x * z2;\n        dest[2] = x * y2 - y * x2;\n        return dest;\n    },\n\n\n    sqLenVec4(v) { // TODO\n        return math.dotVec4(v, v);\n    },\n\n    /**\n     * Returns the length of a four-element vector.\n     * @method lenVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec4(v) {\n        return Math.sqrt(math.sqLenVec4(v));\n    },\n\n    /**\n     * Returns the dot product of two three-element vectors.\n     * @method dotVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec3(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2]);\n    },\n\n    /**\n     * Returns the dot product of two two-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec2(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]);\n    },\n\n\n    sqLenVec3(v) {\n        return math.dotVec3(v, v);\n    },\n\n\n    sqLenVec2(v) {\n        return math.dotVec2(v, v);\n    },\n\n    /**\n     * Returns the length of a three-element vector.\n     * @method lenVec3\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec3(v) {\n        return Math.sqrt(math.sqLenVec3(v));\n    },\n\n    distVec3: ((() => {\n        const vec = new FloatArrayType(3);\n        return (v, w) => math.lenVec3(math.subVec3(v, w, vec));\n    }))(),\n\n    /**\n     * Returns the length of a two-element vector.\n     * @method lenVec2\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec2(v) {\n        return Math.sqrt(math.sqLenVec2(v));\n    },\n\n    distVec2: ((() => {\n        const vec = new FloatArrayType(2);\n        return (v, w) => math.lenVec2(math.subVec2(v, w, vec));\n    }))(),\n\n    /**\n     * @method rcpVec3\n     * @static\n     * @param v vec3\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    rcpVec3(v, dest) {\n        return math.divScalarVec3(1.0, v, dest);\n    },\n\n    /**\n     * Normalizes a four-element vector\n     * @method normalizeVec4\n     * @static\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    normalizeVec4(v, dest) {\n        const f = 1.0 / math.lenVec4(v);\n        return math.mulVec4Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a three-element vector\n     * @method normalizeVec4\n     * @static\n     */\n    normalizeVec3(v, dest) {\n        const f = 1.0 / math.lenVec3(v);\n        return math.mulVec3Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a two-element vector\n     * @method normalizeVec2\n     * @static\n     */\n    normalizeVec2(v, dest) {\n        const f = 1.0 / math.lenVec2(v);\n        return math.mulVec2Scalar(v, f, dest);\n    },\n\n    /**\n     * Gets the angle between two vectors\n     * @method angleVec3\n     * @param v\n     * @param w\n     * @returns {number}\n     */\n    angleVec3(v, w) {\n        let theta = math.dotVec3(v, w) / (Math.sqrt(math.sqLenVec3(v) * math.sqLenVec3(w)));\n        theta = theta < -1 ? -1 : (theta > 1 ? 1 : theta);  // Clamp to handle numerical problems\n        return Math.acos(theta);\n    },\n\n    /**\n     * Creates a three-element vector from the rotation part of a sixteen-element matrix.\n     * @param m\n     * @param dest\n     */\n    vec3FromMat4Scale: ((() => {\n\n        const tempVec3 = new FloatArrayType(3);\n\n        return (m, dest) => {\n\n            tempVec3[0] = m[0];\n            tempVec3[1] = m[1];\n            tempVec3[2] = m[2];\n\n            dest[0] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[4];\n            tempVec3[1] = m[5];\n            tempVec3[2] = m[6];\n\n            dest[1] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[8];\n            tempVec3[1] = m[9];\n            tempVec3[2] = m[10];\n\n            dest[2] = math.lenVec3(tempVec3);\n\n            return dest;\n        };\n    }))(),\n\n    /**\n     * Converts an n-element vector to a JSON-serializable\n     * array with values rounded to two decimal places.\n     */\n    vecToArray: ((() => {\n        function trunc(v) {\n            return Math.round(v * 100000) / 100000\n        }\n\n        return v => {\n            v = Array.prototype.slice.call(v);\n            for (let i = 0, len = v.length; i < len; i++) {\n                v[i] = trunc(v[i]);\n            }\n            return v;\n        };\n    }))(),\n\n    /**\n     * Converts a 3-element vector from an array to an object of the form ````{x:999, y:999, z:999}````.\n     * @param arr\n     * @returns {{x: *, y: *, z: *}}\n     */\n    xyzArrayToObject(arr) {\n        return {\"x\": arr[0], \"y\": arr[1], \"z\": arr[2]};\n    },\n\n    /**\n     * Converts a 3-element vector object of the form ````{x:999, y:999, z:999}```` to an array.\n     * @param xyz\n     * @param  [arry]\n     * @returns {*[]}\n     */\n    xyzObjectToArray(xyz, arry) {\n        arry = arry || new FloatArrayType(3);\n        arry[0] = xyz.x;\n        arry[1] = xyz.y;\n        arry[2] = xyz.z;\n        return arry;\n    },\n\n    /**\n     * Duplicates a 4x4 identity matrix.\n     * @method dupMat4\n     * @static\n     */\n    dupMat4(m) {\n        return m.slice(0, 16);\n    },\n\n    /**\n     * Extracts a 3x3 matrix from a 4x4 matrix.\n     * @method mat4To3\n     * @static\n     */\n    mat4To3(m) {\n        return [\n            m[0], m[1], m[2],\n            m[4], m[5], m[6],\n            m[8], m[9], m[10]\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to the given scalar value.\n     * @method m4s\n     * @static\n     */\n    m4s(s) {\n        return [\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to zero.\n     * @method setMat4ToZeroes\n     * @static\n     */\n    setMat4ToZeroes() {\n        return math.m4s(0.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    setMat4ToOnes() {\n        return math.m4s(1.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    diagonalMat4v(v) {\n        return new FloatArrayType([\n            v[0], 0.0, 0.0, 0.0,\n            0.0, v[1], 0.0, 0.0,\n            0.0, 0.0, v[2], 0.0,\n            0.0, 0.0, 0.0, v[3]\n        ]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given vector.\n     * @method diagonalMat4c\n     * @static\n     */\n    diagonalMat4c(x, y, z, w) {\n        return math.diagonalMat4v([x, y, z, w]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given scalar.\n     * @method diagonalMat4s\n     * @static\n     */\n    diagonalMat4s(s) {\n        return math.diagonalMat4c(s, s, s, s);\n    },\n\n    /**\n     * Returns a 4x4 identity matrix.\n     * @method identityMat4\n     * @static\n     */\n    identityMat4(mat = new FloatArrayType(16)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n        mat[3] = 0.0;\n\n        mat[4] = 0.0;\n        mat[5] = 1.0;\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n\n        mat[8] = 0.0;\n        mat[9] = 0.0;\n        mat[10] = 1.0;\n        mat[11] = 0.0;\n\n        mat[12] = 0.0;\n        mat[13] = 0.0;\n        mat[14] = 0.0;\n        mat[15] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Returns a 3x3 identity matrix.\n     * @method identityMat3\n     * @static\n     */\n    identityMat3(mat = new FloatArrayType(9)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n\n        mat[3] = 0.0;\n        mat[4] = 1.0;\n        mat[5] = 0.0;\n\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n        mat[8] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Tests if the given 4x4 matrix is the identity matrix.\n     * @method isIdentityMat4\n     * @static\n     */\n    isIdentityMat4(m) {\n        if (m[0] !== 1.0 || m[1] !== 0.0 || m[2] !== 0.0 || m[3] !== 0.0 ||\n            m[4] !== 0.0 || m[5] !== 1.0 || m[6] !== 0.0 || m[7] !== 0.0 ||\n            m[8] !== 0.0 || m[9] !== 0.0 || m[10] !== 1.0 || m[11] !== 0.0 ||\n            m[12] !== 0.0 || m[13] !== 0.0 || m[14] !== 0.0 || m[15] !== 1.0) {\n            return false;\n        }\n        return true;\n    },\n\n    /**\n     * Negates the given 4x4 matrix.\n     * @method negateMat4\n     * @static\n     */\n    negateMat4(m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = -m[0];\n        dest[1] = -m[1];\n        dest[2] = -m[2];\n        dest[3] = -m[3];\n        dest[4] = -m[4];\n        dest[5] = -m[5];\n        dest[6] = -m[6];\n        dest[7] = -m[7];\n        dest[8] = -m[8];\n        dest[9] = -m[9];\n        dest[10] = -m[10];\n        dest[11] = -m[11];\n        dest[12] = -m[12];\n        dest[13] = -m[13];\n        dest[14] = -m[14];\n        dest[15] = -m[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given 4x4 matrices together.\n     * @method addMat4\n     * @static\n     */\n    addMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] + b[0];\n        dest[1] = a[1] + b[1];\n        dest[2] = a[2] + b[2];\n        dest[3] = a[3] + b[3];\n        dest[4] = a[4] + b[4];\n        dest[5] = a[5] + b[5];\n        dest[6] = a[6] + b[6];\n        dest[7] = a[7] + b[7];\n        dest[8] = a[8] + b[8];\n        dest[9] = a[9] + b[9];\n        dest[10] = a[10] + b[10];\n        dest[11] = a[11] + b[11];\n        dest[12] = a[12] + b[12];\n        dest[13] = a[13] + b[13];\n        dest[14] = a[14] + b[14];\n        dest[15] = a[15] + b[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addMat4Scalar\n     * @static\n     */\n    addMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] + s;\n        dest[1] = m[1] + s;\n        dest[2] = m[2] + s;\n        dest[3] = m[3] + s;\n        dest[4] = m[4] + s;\n        dest[5] = m[5] + s;\n        dest[6] = m[6] + s;\n        dest[7] = m[7] + s;\n        dest[8] = m[8] + s;\n        dest[9] = m[9] + s;\n        dest[10] = m[10] + s;\n        dest[11] = m[11] + s;\n        dest[12] = m[12] + s;\n        dest[13] = m[13] + s;\n        dest[14] = m[14] + s;\n        dest[15] = m[15] + s;\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addScalarMat4\n     * @static\n     */\n    addScalarMat4(s, m, dest) {\n        return math.addMat4Scalar(m, s, dest);\n    },\n\n    /**\n     * Subtracts the second 4x4 matrix from the first.\n     * @method subMat4\n     * @static\n     */\n    subMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] - b[0];\n        dest[1] = a[1] - b[1];\n        dest[2] = a[2] - b[2];\n        dest[3] = a[3] - b[3];\n        dest[4] = a[4] - b[4];\n        dest[5] = a[5] - b[5];\n        dest[6] = a[6] - b[6];\n        dest[7] = a[7] - b[7];\n        dest[8] = a[8] - b[8];\n        dest[9] = a[9] - b[9];\n        dest[10] = a[10] - b[10];\n        dest[11] = a[11] - b[11];\n        dest[12] = a[12] - b[12];\n        dest[13] = a[13] - b[13];\n        dest[14] = a[14] - b[14];\n        dest[15] = a[15] - b[15];\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subMat4Scalar\n     * @static\n     */\n    subMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] - s;\n        dest[1] = m[1] - s;\n        dest[2] = m[2] - s;\n        dest[3] = m[3] - s;\n        dest[4] = m[4] - s;\n        dest[5] = m[5] - s;\n        dest[6] = m[6] - s;\n        dest[7] = m[7] - s;\n        dest[8] = m[8] - s;\n        dest[9] = m[9] - s;\n        dest[10] = m[10] - s;\n        dest[11] = m[11] - s;\n        dest[12] = m[12] - s;\n        dest[13] = m[13] - s;\n        dest[14] = m[14] - s;\n        dest[15] = m[15] - s;\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subScalarMat4\n     * @static\n     */\n    subScalarMat4(s, m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = s - m[0];\n        dest[1] = s - m[1];\n        dest[2] = s - m[2];\n        dest[3] = s - m[3];\n        dest[4] = s - m[4];\n        dest[5] = s - m[5];\n        dest[6] = s - m[6];\n        dest[7] = s - m[7];\n        dest[8] = s - m[8];\n        dest[9] = s - m[9];\n        dest[10] = s - m[10];\n        dest[11] = s - m[11];\n        dest[12] = s - m[12];\n        dest[13] = s - m[13];\n        dest[14] = s - m[14];\n        dest[15] = s - m[15];\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 4x4 matrix by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = a[0];\n\n        const a01 = a[1];\n        const a02 = a[2];\n        const a03 = a[3];\n        const a10 = a[4];\n        const a11 = a[5];\n        const a12 = a[6];\n        const a13 = a[7];\n        const a20 = a[8];\n        const a21 = a[9];\n        const a22 = a[10];\n        const a23 = a[11];\n        const a30 = a[12];\n        const a31 = a[13];\n        const a32 = a[14];\n        const a33 = a[15];\n        const b00 = b[0];\n        const b01 = b[1];\n        const b02 = b[2];\n        const b03 = b[3];\n        const b10 = b[4];\n        const b11 = b[5];\n        const b12 = b[6];\n        const b13 = b[7];\n        const b20 = b[8];\n        const b21 = b[9];\n        const b22 = b[10];\n        const b23 = b[11];\n        const b30 = b[12];\n        const b31 = b[13];\n        const b32 = b[14];\n        const b33 = b[15];\n\n        dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;\n        dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;\n        dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;\n        dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;\n        dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;\n        dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;\n        dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;\n        dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;\n        dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;\n        dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;\n        dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;\n        dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;\n        dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;\n        dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;\n        dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;\n        dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 3x3 matrices by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat3(a, b, dest) {\n        if (!dest) {\n            dest = new FloatArrayType(9);\n        }\n\n        const a11 = a[0];\n        const a12 = a[3];\n        const a13 = a[6];\n        const a21 = a[1];\n        const a22 = a[4];\n        const a23 = a[7];\n        const a31 = a[2];\n        const a32 = a[5];\n        const a33 = a[8];\n        const b11 = b[0];\n        const b12 = b[3];\n        const b13 = b[6];\n        const b21 = b[1];\n        const b22 = b[4];\n        const b23 = b[7];\n        const b31 = b[2];\n        const b32 = b[5];\n        const b33 = b[8];\n\n        dest[0] = a11 * b11 + a12 * b21 + a13 * b31;\n        dest[3] = a11 * b12 + a12 * b22 + a13 * b32;\n        dest[6] = a11 * b13 + a12 * b23 + a13 * b33;\n\n        dest[1] = a21 * b11 + a22 * b21 + a23 * b31;\n        dest[4] = a21 * b12 + a22 * b22 + a23 * b32;\n        dest[7] = a21 * b13 + a22 * b23 + a23 * b33;\n\n        dest[2] = a31 * b11 + a32 * b21 + a33 * b31;\n        dest[5] = a31 * b12 + a32 * b22 + a33 * b32;\n        dest[8] = a31 * b13 + a32 * b23 + a33 * b33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of the given 4x4 matrix by the given scalar.\n     * @method mulMat4Scalar\n     * @static\n     */\n    mulMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] * s;\n        dest[1] = m[1] * s;\n        dest[2] = m[2] * s;\n        dest[3] = m[3] * s;\n        dest[4] = m[4] * s;\n        dest[5] = m[5] * s;\n        dest[6] = m[6] * s;\n        dest[7] = m[7] * s;\n        dest[8] = m[8] * s;\n        dest[9] = m[9] * s;\n        dest[10] = m[10] * s;\n        dest[11] = m[11] * s;\n        dest[12] = m[12] * s;\n        dest[13] = m[13] * s;\n        dest[14] = m[14] * s;\n        dest[15] = m[15] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies the given 4x4 matrix by the given four-element vector.\n     * @method mulMat4v4\n     * @static\n     */\n    mulMat4v4(m, v, dest = math.vec4()) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Transposes the given 4x4 matrix.\n     * @method transposeMat4\n     * @static\n     */\n    transposeMat4(mat, dest) {\n        // If we are transposing ourselves we can skip a few steps but have to cache some values\n        const m4 = mat[4];\n\n        const m14 = mat[14];\n        const m8 = mat[8];\n        const m13 = mat[13];\n        const m12 = mat[12];\n        const m9 = mat[9];\n        if (!dest || mat === dest) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a03 = mat[3];\n            const a12 = mat[6];\n            const a13 = mat[7];\n            const a23 = mat[11];\n            mat[1] = m4;\n            mat[2] = m8;\n            mat[3] = m12;\n            mat[4] = a01;\n            mat[6] = m9;\n            mat[7] = m13;\n            mat[8] = a02;\n            mat[9] = a12;\n            mat[11] = m14;\n            mat[12] = a03;\n            mat[13] = a13;\n            mat[14] = a23;\n            return mat;\n        }\n        dest[0] = mat[0];\n        dest[1] = m4;\n        dest[2] = m8;\n        dest[3] = m12;\n        dest[4] = mat[1];\n        dest[5] = mat[5];\n        dest[6] = m9;\n        dest[7] = m13;\n        dest[8] = mat[2];\n        dest[9] = mat[6];\n        dest[10] = mat[10];\n        dest[11] = m14;\n        dest[12] = mat[3];\n        dest[13] = mat[7];\n        dest[14] = mat[11];\n        dest[15] = mat[15];\n        return dest;\n    },\n\n    /**\n     * Transposes the given 3x3 matrix.\n     *\n     * @method transposeMat3\n     * @static\n     */\n    transposeMat3(mat, dest) {\n        if (dest === mat) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a12 = mat[5];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = a01;\n            dest[5] = mat[7];\n            dest[6] = a02;\n            dest[7] = a12;\n        } else {\n            dest[0] = mat[0];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = mat[1];\n            dest[4] = mat[4];\n            dest[5] = mat[7];\n            dest[6] = mat[2];\n            dest[7] = mat[5];\n            dest[8] = mat[8];\n        }\n        return dest;\n    },\n\n    /**\n     * Returns the determinant of the given 4x4 matrix.\n     * @method determinantMat4\n     * @static\n     */\n    determinantMat4(mat) {\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +\n            a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +\n            a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +\n            a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +\n            a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +\n            a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;\n    },\n\n    /**\n     * Returns the inverse of the given 4x4 matrix.\n     * @method inverseMat4\n     * @static\n     */\n    inverseMat4(mat, dest) {\n        if (!dest) {\n            dest = mat;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        const b00 = a00 * a11 - a01 * a10;\n        const b01 = a00 * a12 - a02 * a10;\n        const b02 = a00 * a13 - a03 * a10;\n        const b03 = a01 * a12 - a02 * a11;\n        const b04 = a01 * a13 - a03 * a11;\n        const b05 = a02 * a13 - a03 * a12;\n        const b06 = a20 * a31 - a21 * a30;\n        const b07 = a20 * a32 - a22 * a30;\n        const b08 = a20 * a33 - a23 * a30;\n        const b09 = a21 * a32 - a22 * a31;\n        const b10 = a21 * a33 - a23 * a31;\n        const b11 = a22 * a33 - a23 * a32;\n\n        // Calculate the determinant (inlined to avoid double-caching)\n        const invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);\n\n        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;\n        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;\n        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;\n        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;\n        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;\n        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;\n        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;\n        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;\n        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;\n        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;\n        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;\n        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;\n        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;\n        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;\n        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;\n        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;\n\n        return dest;\n    },\n\n    /**\n     * Returns the trace of the given 4x4 matrix.\n     * @method traceMat4\n     * @static\n     */\n    traceMat4(m) {\n        return (m[0] + m[5] + m[10] + m[15]);\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4\n     * @static\n     */\n    translationMat4v(v, dest) {\n        const m = dest || math.identityMat4();\n        m[12] = v[0];\n        m[13] = v[1];\n        m[14] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 translation matrix.\n     * @method translationMat3\n     * @static\n     */\n    translationMat3v(v, dest) {\n        const m = dest || math.identityMat3();\n        m[6] = v[0];\n        m[7] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4c\n     * @static\n     */\n    translationMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.translationMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4s\n     * @static\n     */\n    translationMat4s(s, dest) {\n        return math.translationMat4c(s, s, s, dest);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param v\n     * @param m\n     */\n    translateMat4v(xyz, m) {\n        return math.translateMat4c(xyz[0], xyz[1], xyz[2], m);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    OLDtranslateMat4c(x, y, z, m) {\n\n        const m12 = m[12];\n        m[0] += m12 * x;\n        m[4] += m12 * y;\n        m[8] += m12 * z;\n\n        const m13 = m[13];\n        m[1] += m13 * x;\n        m[5] += m13 * y;\n        m[9] += m13 * z;\n\n        const m14 = m[14];\n        m[2] += m14 * x;\n        m[6] += m14 * y;\n        m[10] += m14 * z;\n\n        const m15 = m[15];\n        m[3] += m15 * x;\n        m[7] += m15 * y;\n        m[11] += m15 * z;\n\n        return m;\n    },\n\n    translateMat4c(x, y, z, m) {\n\n        const m3 = m[3];\n        m[0] += m3 * x;\n        m[1] += m3 * y;\n        m[2] += m3 * z;\n\n        const m7 = m[7];\n        m[4] += m7 * x;\n        m[5] += m7 * y;\n        m[6] += m7 * z;\n\n        const m11 = m[11];\n        m[8] += m11 * x;\n        m[9] += m11 * y;\n        m[10] += m11 * z;\n\n        const m15 = m[15];\n        m[12] += m15 * x;\n        m[13] += m15 * y;\n        m[14] += m15 * z;\n\n        return m;\n    },\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4v\n     * @static\n     */\n    rotationMat4v(anglerad, axis, m) {\n        const ax = math.normalizeVec4([axis[0], axis[1], axis[2], 0.0], []);\n        const s = Math.sin(anglerad);\n        const c = Math.cos(anglerad);\n        const q = 1.0 - c;\n\n        const x = ax[0];\n        const y = ax[1];\n        const z = ax[2];\n\n        let xy;\n        let yz;\n        let zx;\n        let xs;\n        let ys;\n        let zs;\n\n        //xx = x * x; used once\n        //yy = y * y; used once\n        //zz = z * z; used once\n        xy = x * y;\n        yz = y * z;\n        zx = z * x;\n        xs = x * s;\n        ys = y * s;\n        zs = z * s;\n\n        m = m || math.mat4();\n\n        m[0] = (q * x * x) + c;\n        m[1] = (q * xy) + zs;\n        m[2] = (q * zx) - ys;\n        m[3] = 0.0;\n\n        m[4] = (q * xy) - zs;\n        m[5] = (q * y * y) + c;\n        m[6] = (q * yz) + xs;\n        m[7] = 0.0;\n\n        m[8] = (q * zx) + ys;\n        m[9] = (q * yz) - xs;\n        m[10] = (q * z * z) + c;\n        m[11] = 0.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = 0.0;\n        m[15] = 1.0;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4c\n     * @static\n     */\n    rotationMat4c(anglerad, x, y, z, mat) {\n        return math.rotationMat4v(anglerad, [x, y, z], mat);\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4v\n     * @static\n     */\n    scalingMat4v(v, m = math.identityMat4()) {\n        m[0] = v[0];\n        m[5] = v[1];\n        m[10] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 scale matrix.\n     * @method scalingMat3v\n     * @static\n     */\n    scalingMat3v(v, m = math.identityMat3()) {\n        m[0] = v[0];\n        m[4] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4c\n     * @static\n     */\n    scalingMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.scalingMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    scaleMat4c(x, y, z, m) {\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n        return m;\n    },\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param xyz\n     * @param m\n     */\n    scaleMat4v(xyz, m) {\n\n        const x = xyz[0];\n        const y = xyz[1];\n        const z = xyz[2];\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4s\n     * @static\n     */\n    scalingMat4s(s) {\n        return math.scalingMat4c(s, s, s);\n    },\n\n    /**\n     * Creates a matrix from a quaternion rotation and vector translation\n     *\n     * @param {Number[]} q Rotation quaternion\n     * @param {Number[]} v Translation vector\n     * @param {Number[]} dest Destination matrix\n     * @returns {Number[]} dest\n     */\n    rotationTranslationMat4(q, v, dest = math.mat4()) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        dest[0] = 1 - (yy + zz);\n        dest[1] = xy + wz;\n        dest[2] = xz - wy;\n        dest[3] = 0;\n        dest[4] = xy - wz;\n        dest[5] = 1 - (xx + zz);\n        dest[6] = yz + wx;\n        dest[7] = 0;\n        dest[8] = xz + wy;\n        dest[9] = yz - wx;\n        dest[10] = 1 - (xx + yy);\n        dest[11] = 0;\n        dest[12] = v[0];\n        dest[13] = v[1];\n        dest[14] = v[2];\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Gets Euler angles from a 4x4 matrix.\n     *\n     * @param {Number[]} mat The 4x4 matrix.\n     * @param {String} order Desired Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination Euler angles, created by default.\n     * @returns {Number[]} The Euler angles.\n     */\n    mat4ToEuler(mat, order, dest = math.vec4()) {\n        const clamp = math.clamp;\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = mat[0];\n\n        const m12 = mat[4];\n        const m13 = mat[8];\n        const m21 = mat[1];\n        const m22 = mat[5];\n        const m23 = mat[9];\n        const m31 = mat[2];\n        const m32 = mat[6];\n        const m33 = mat[10];\n\n        if (order === 'XYZ') {\n\n            dest[1] = Math.asin(clamp(m13, -1, 1));\n\n            if (Math.abs(m13) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[2] = Math.atan2(-m12, m11);\n            } else {\n                dest[0] = Math.atan2(m32, m22);\n                dest[2] = 0;\n\n            }\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = Math.asin(-clamp(m23, -1, 1));\n\n            if (Math.abs(m23) < 0.99999) {\n                dest[1] = Math.atan2(m13, m33);\n                dest[2] = Math.atan2(m21, m22);\n            } else {\n                dest[1] = Math.atan2(-m31, m11);\n                dest[2] = 0;\n            }\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = Math.asin(clamp(m32, -1, 1));\n\n            if (Math.abs(m32) < 0.99999) {\n                dest[1] = Math.atan2(-m31, m33);\n                dest[2] = Math.atan2(-m12, m22);\n            } else {\n                dest[1] = 0;\n                dest[2] = Math.atan2(m21, m11);\n            }\n\n        } else if (order === 'ZYX') {\n\n            dest[1] = Math.asin(-clamp(m31, -1, 1));\n\n            if (Math.abs(m31) < 0.99999) {\n                dest[0] = Math.atan2(m32, m33);\n                dest[2] = Math.atan2(m21, m11);\n            } else {\n                dest[0] = 0;\n                dest[2] = Math.atan2(-m12, m22);\n            }\n\n        } else if (order === 'YZX') {\n\n            dest[2] = Math.asin(clamp(m21, -1, 1));\n\n            if (Math.abs(m21) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m22);\n                dest[1] = Math.atan2(-m31, m11);\n            } else {\n                dest[0] = 0;\n                dest[1] = Math.atan2(m13, m33);\n            }\n\n        } else if (order === 'XZY') {\n\n            dest[2] = Math.asin(-clamp(m12, -1, 1));\n\n            if (Math.abs(m12) < 0.99999) {\n                dest[0] = Math.atan2(m32, m22);\n                dest[1] = Math.atan2(m13, m11);\n            } else {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[1] = 0;\n            }\n        }\n\n        return dest;\n    },\n\n    composeMat4(position, quaternion, scale, mat = math.mat4()) {\n        math.quaternionToRotationMat4(quaternion, mat);\n        math.scaleMat4v(scale, mat);\n        math.translateMat4v(position, mat);\n\n        return mat;\n    },\n\n    decomposeMat4: (() => {\n\n        const vec = new FloatArrayType(3);\n        const matrix = new FloatArrayType(16);\n\n        return function decompose(mat, position, quaternion, scale) {\n\n            vec[0] = mat[0];\n            vec[1] = mat[1];\n            vec[2] = mat[2];\n\n            let sx = math.lenVec3(vec);\n\n            vec[0] = mat[4];\n            vec[1] = mat[5];\n            vec[2] = mat[6];\n\n            const sy = math.lenVec3(vec);\n\n            vec[8] = mat[8];\n            vec[9] = mat[9];\n            vec[10] = mat[10];\n\n            const sz = math.lenVec3(vec);\n\n            // if determine is negative, we need to invert one scale\n            const det = math.determinantMat4(mat);\n\n            if (det < 0) {\n                sx = -sx;\n            }\n\n            position[0] = mat[12];\n            position[1] = mat[13];\n            position[2] = mat[14];\n\n            // scale the rotation part\n            matrix.set(mat);\n\n            const invSX = 1 / sx;\n            const invSY = 1 / sy;\n            const invSZ = 1 / sz;\n\n            matrix[0] *= invSX;\n            matrix[1] *= invSX;\n            matrix[2] *= invSX;\n\n            matrix[4] *= invSY;\n            matrix[5] *= invSY;\n            matrix[6] *= invSY;\n\n            matrix[8] *= invSZ;\n            matrix[9] *= invSZ;\n            matrix[10] *= invSZ;\n\n            math.mat4ToQuaternion(matrix, quaternion);\n\n            scale[0] = sx;\n            scale[1] = sy;\n            scale[2] = sz;\n\n            return this;\n\n        };\n\n    })(),\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4v\n     * @param pos vec3 position of the viewer\n     * @param target vec3 point the viewer is looking at\n     * @param up vec3 pointing \"up\"\n     * @param dest mat4 Optional, mat4 matrix will be written into\n     *\n     * @return {mat4} dest if specified, a new mat4 otherwise\n     */\n    lookAtMat4v(pos, target, up, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n\n        const posx = pos[0];\n        const posy = pos[1];\n        const posz = pos[2];\n        const upx = up[0];\n        const upy = up[1];\n        const upz = up[2];\n        const targetx = target[0];\n        const targety = target[1];\n        const targetz = target[2];\n\n        if (posx === targetx && posy === targety && posz === targetz) {\n            return math.identityMat4();\n        }\n\n        let z0;\n        let z1;\n        let z2;\n        let x0;\n        let x1;\n        let x2;\n        let y0;\n        let y1;\n        let y2;\n        let len;\n\n        //vec3.direction(eye, center, z);\n        z0 = posx - targetx;\n        z1 = posy - targety;\n        z2 = posz - targetz;\n\n        // normalize (no check needed for 0 because of early return)\n        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n\n        //vec3.normalize(vec3.cross(up, z, x));\n        x0 = upy * z2 - upz * z1;\n        x1 = upz * z0 - upx * z2;\n        x2 = upx * z1 - upy * z0;\n        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n        if (!len) {\n            x0 = 0;\n            x1 = 0;\n            x2 = 0;\n        } else {\n            len = 1 / len;\n            x0 *= len;\n            x1 *= len;\n            x2 *= len;\n        }\n\n        //vec3.normalize(vec3.cross(z, x, y));\n        y0 = z1 * x2 - z2 * x1;\n        y1 = z2 * x0 - z0 * x2;\n        y2 = z0 * x1 - z1 * x0;\n\n        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n        if (!len) {\n            y0 = 0;\n            y1 = 0;\n            y2 = 0;\n        } else {\n            len = 1 / len;\n            y0 *= len;\n            y1 *= len;\n            y2 *= len;\n        }\n\n        dest[0] = x0;\n        dest[1] = y0;\n        dest[2] = z0;\n        dest[3] = 0;\n        dest[4] = x1;\n        dest[5] = y1;\n        dest[6] = z1;\n        dest[7] = 0;\n        dest[8] = x2;\n        dest[9] = y2;\n        dest[10] = z2;\n        dest[11] = 0;\n        dest[12] = -(x0 * posx + x1 * posy + x2 * posz);\n        dest[13] = -(y0 * posx + y1 * posy + y2 * posz);\n        dest[14] = -(z0 * posx + z1 * posy + z2 * posz);\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4c\n     * @static\n     */\n    lookAtMat4c(posx, posy, posz, targetx, targety, targetz, upx, upy, upz) {\n        return math.lookAtMat4v([posx, posy, posz], [targetx, targety, targetz], [upx, upy, upz], []);\n    },\n\n    /**\n     * Returns a 4x4 orthographic projection matrix.\n     * @method orthoMat4c\n     * @static\n     */\n    orthoMat4c(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n\n        dest[0] = 2.0 / rl;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 0.0;\n\n        dest[4] = 0.0;\n        dest[5] = 2.0 / tb;\n        dest[6] = 0.0;\n        dest[7] = 0.0;\n\n        dest[8] = 0.0;\n        dest[9] = 0.0;\n        dest[10] = -2.0 / fn;\n        dest[11] = 0.0;\n\n        dest[12] = -(left + right) / rl;\n        dest[13] = -(top + bottom) / tb;\n        dest[14] = -(far + near) / fn;\n        dest[15] = 1.0;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4v(fmin, fmax, m) {\n        if (!m) {\n            m = math.mat4();\n        }\n\n        const fmin4 = [fmin[0], fmin[1], fmin[2], 0.0];\n        const fmax4 = [fmax[0], fmax[1], fmax[2], 0.0];\n\n        math.addVec4(fmax4, fmin4, tempMat1);\n        math.subVec4(fmax4, fmin4, tempMat2);\n\n        const t = 2.0 * fmin4[2];\n\n        const tempMat20 = tempMat2[0];\n        const tempMat21 = tempMat2[1];\n        const tempMat22 = tempMat2[2];\n\n        m[0] = t / tempMat20;\n        m[1] = 0.0;\n        m[2] = 0.0;\n        m[3] = 0.0;\n\n        m[4] = 0.0;\n        m[5] = t / tempMat21;\n        m[6] = 0.0;\n        m[7] = 0.0;\n\n        m[8] = tempMat1[0] / tempMat20;\n        m[9] = tempMat1[1] / tempMat21;\n        m[10] = -tempMat1[2] / tempMat22;\n        m[11] = -1.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = -t * fmax4[2] / tempMat22;\n        m[15] = 0.0;\n\n        return m;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n        dest[0] = (near * 2) / rl;\n        dest[1] = 0;\n        dest[2] = 0;\n        dest[3] = 0;\n        dest[4] = 0;\n        dest[5] = (near * 2) / tb;\n        dest[6] = 0;\n        dest[7] = 0;\n        dest[8] = (right + left) / rl;\n        dest[9] = (top + bottom) / tb;\n        dest[10] = -(far + near) / fn;\n        dest[11] = -1;\n        dest[12] = 0;\n        dest[13] = 0;\n        dest[14] = -(far * near * 2) / fn;\n        dest[15] = 0;\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method perspectiveMat4v\n     * @static\n     */\n    perspectiveMat4(fovyrad, aspectratio, znear, zfar, m) {\n        const pmin = [];\n        const pmax = [];\n\n        pmin[2] = znear;\n        pmax[2] = zfar;\n\n        pmax[1] = pmin[2] * Math.tan(fovyrad / 2.0);\n        pmin[1] = -pmax[1];\n\n        pmax[0] = pmax[1] * aspectratio;\n        pmin[0] = -pmax[0];\n\n        return math.frustumMat4v(pmin, pmax, m);\n    },\n\n    /**\n     * Transforms a three-element position by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint3(m, p, dest = math.vec3()) {\n\n        const x = p[0];\n        const y = p[1];\n        const z = p[2];\n\n        dest[0] = (m[0] * x) + (m[4] * y) + (m[8] * z) + m[12];\n        dest[1] = (m[1] * x) + (m[5] * y) + (m[9] * z) + m[13];\n        dest[2] = (m[2] * x) + (m[6] * y) + (m[10] * z) + m[14];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a homogeneous coordinate by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint4(m, v, dest = math.vec4()) {\n        dest[0] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3];\n        dest[1] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3];\n        dest[2] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3];\n        dest[3] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3];\n\n        return dest;\n    },\n\n\n    /**\n     * Transforms an array of three-element positions by a 4x4 matrix.\n     * @method transformPoints3\n     * @static\n     */\n    transformPoints3(m, points, points2) {\n        const result = points2 || [];\n        const len = points.length;\n        let p0;\n        let p1;\n        let p2;\n        let pi;\n\n        // cache values\n        const m0 = m[0];\n\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        let r;\n\n        for (let i = 0; i < len; ++i) {\n\n            // cache values\n            pi = points[i];\n\n            p0 = pi[0];\n            p1 = pi[1];\n            p2 = pi[2];\n\n            r = result[i] || (result[i] = [0, 0, 0]);\n\n            r[0] = (m0 * p0) + (m4 * p1) + (m8 * p2) + m12;\n            r[1] = (m1 * p0) + (m5 * p1) + (m9 * p2) + m13;\n            r[2] = (m2 * p0) + (m6 * p1) + (m10 * p2) + m14;\n            r[3] = (m3 * p0) + (m7 * p1) + (m11 * p2) + m15;\n        }\n\n        result.length = len;\n\n        return result;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions3\n     * @static\n     */\n    transformPositions3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 3) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions4\n     * @static\n     */\n    transformPositions4(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms a three-element vector by a 4x4 matrix.\n     * @method transformVec3\n     * @static\n     */\n    transformVec3(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        dest = dest || this.vec3();\n        dest[0] = (m[0] * v0) + (m[4] * v1) + (m[8] * v2);\n        dest[1] = (m[1] * v0) + (m[5] * v1) + (m[9] * v2);\n        dest[2] = (m[2] * v0) + (m[6] * v1) + (m[10] * v2);\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 matrix.\n     * @method transformVec4\n     * @static\n     */\n    transformVec4(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest = dest || math.vec4();\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the x-axis\n     *\n     * @method rotateVec3X\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3X(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0];\n        r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);\n        r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the y-axis\n     *\n     * @method rotateVec3Y\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Y(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);\n        r[1] = p[1];\n        r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the z-axis\n     *\n     * @method rotateVec3Z\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Z(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);\n        r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);\n        r[2] = p[2];\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 projection matrix.\n     *\n     * @method projectVec4\n     * @param {Number[]} p 3D View-space coordinate\n     * @param {Number[]} q 2D Projected coordinate\n     * @returns {Number[]} 2D Projected coordinate\n     * @static\n     */\n    projectVec4(p, q) {\n        const f = 1.0 / p[3];\n        q = q || math.vec2();\n        q[0] = v[0] * f;\n        q[1] = v[1] * f;\n        return q;\n    },\n\n    /**\n     * Unprojects a three-element vector.\n     *\n     * @method unprojectVec3\n     * @param {Number[]} p 3D Projected coordinate\n     * @param {Number[]} viewMat View matrix\n     * @returns {Number[]} projMat Projection matrix\n     * @static\n     */\n    unprojectVec3: ((() => {\n        const mat = new FloatArrayType(16);\n        const mat2 = new FloatArrayType(16);\n        const mat3 = new FloatArrayType(16);\n        return function (p, viewMat, projMat, q) {\n            return this.transformVec3(this.mulMat4(this.inverseMat4(viewMat, mat), this.inverseMat4(projMat, mat2), mat3), p, q)\n        };\n    }))(),\n\n    /**\n     * Linearly interpolates between two 3D vectors.\n     * @method lerpVec3\n     * @static\n     */\n    lerpVec3(t, t1, t2, p1, p2, dest) {\n        const result = dest || math.vec3();\n        const f = (t - t1) / (t2 - t1);\n        result[0] = p1[0] + (f * (p2[0] - p1[0]));\n        result[1] = p1[1] + (f * (p2[1] - p1[1]));\n        result[2] = p1[2] + (f * (p2[2] - p1[2]));\n        return result;\n    },\n\n\n    /**\n     * Flattens a two-dimensional array into a one-dimensional array.\n     *\n     * @method flatten\n     * @static\n     * @param {Array of Arrays} a A 2D array\n     * @returns Flattened 1D array\n     */\n    flatten(a) {\n\n        const result = [];\n\n        let i;\n        let leni;\n        let j;\n        let lenj;\n        let item;\n\n        for (i = 0, leni = a.length; i < leni; i++) {\n            item = a[i];\n            for (j = 0, lenj = item.length; j < lenj; j++) {\n                result.push(item[j]);\n            }\n        }\n\n        return result;\n    },\n\n\n    identityQuaternion(dest = math.vec4()) {\n        dest[0] = 0.0;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 1.0;\n        return dest;\n    },\n\n    /**\n     * Initializes a quaternion from Euler angles.\n     *\n     * @param {Number[]} euler The Euler angles.\n     * @param {String} order Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination quaternion, created by default.\n     * @returns {Number[]} The quaternion.\n     */\n    eulerToQuaternion(euler, order, dest = math.vec4()) {\n        // http://www.mathworks.com/matlabcentral/fileexchange/\n        // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n        //\tcontent/SpinCalc.m\n\n        const a = (euler[0] * math.DEGTORAD) / 2;\n        const b = (euler[1] * math.DEGTORAD) / 2;\n        const c = (euler[2] * math.DEGTORAD) / 2;\n\n        const c1 = Math.cos(a);\n        const c2 = Math.cos(b);\n        const c3 = Math.cos(c);\n        const s1 = Math.sin(a);\n        const s2 = Math.sin(b);\n        const s3 = Math.sin(c);\n\n        if (order === 'XYZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'ZYX') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'YZX') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'XZY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n        }\n\n        return dest;\n    },\n\n    mat4ToQuaternion(m, dest = math.vec4()) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = m[0];\n        const m12 = m[4];\n        const m13 = m[8];\n        const m21 = m[1];\n        const m22 = m[5];\n        const m23 = m[9];\n        const m31 = m[2];\n        const m32 = m[6];\n        const m33 = m[10];\n        let s;\n\n        const trace = m11 + m22 + m33;\n\n        if (trace > 0) {\n\n            s = 0.5 / Math.sqrt(trace + 1.0);\n\n            dest[3] = 0.25 / s;\n            dest[0] = (m32 - m23) * s;\n            dest[1] = (m13 - m31) * s;\n            dest[2] = (m21 - m12) * s;\n\n        } else if (m11 > m22 && m11 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\n            dest[3] = (m32 - m23) / s;\n            dest[0] = 0.25 * s;\n            dest[1] = (m12 + m21) / s;\n            dest[2] = (m13 + m31) / s;\n\n        } else if (m22 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\n            dest[3] = (m13 - m31) / s;\n            dest[0] = (m12 + m21) / s;\n            dest[1] = 0.25 * s;\n            dest[2] = (m23 + m32) / s;\n\n        } else {\n\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\n            dest[3] = (m21 - m12) / s;\n            dest[0] = (m13 + m31) / s;\n            dest[1] = (m23 + m32) / s;\n            dest[2] = 0.25 * s;\n        }\n\n        return dest;\n    },\n\n    vec3PairToQuaternion(u, v, dest = math.vec4()) {\n        const norm_u_norm_v = Math.sqrt(math.dotVec3(u, u) * math.dotVec3(v, v));\n        let real_part = norm_u_norm_v + math.dotVec3(u, v);\n\n        if (real_part < 0.00000001 * norm_u_norm_v) {\n\n            // If u and v are exactly opposite, rotate 180 degrees\n            // around an arbitrary orthogonal axis. Axis normalisation\n            // can happen later, when we normalise the quaternion.\n\n            real_part = 0.0;\n\n            if (Math.abs(u[0]) > Math.abs(u[2])) {\n\n                dest[0] = -u[1];\n                dest[1] = u[0];\n                dest[2] = 0;\n\n            } else {\n                dest[0] = 0;\n                dest[1] = -u[2];\n                dest[2] = u[1]\n            }\n\n        } else {\n\n            // Otherwise, build quaternion the standard way.\n            math.cross3Vec3(u, v, dest);\n        }\n\n        dest[3] = real_part;\n\n        return math.normalizeQuaternion(dest);\n    },\n\n    angleAxisToQuaternion(angleAxis, dest = math.vec4()) {\n        const halfAngle = angleAxis[3] / 2.0;\n        const fsin = Math.sin(halfAngle);\n        dest[0] = fsin * angleAxis[0];\n        dest[1] = fsin * angleAxis[1];\n        dest[2] = fsin * angleAxis[2];\n        dest[3] = Math.cos(halfAngle);\n        return dest;\n    },\n\n    quaternionToEuler: ((() => {\n        const mat = new FloatArrayType(16);\n        return (q, order, dest) => {\n            dest = dest || math.vec3();\n            math.quaternionToRotationMat4(q, mat);\n            math.mat4ToEuler(mat, order, dest);\n            return dest;\n        };\n    }))(),\n\n    mulQuaternions(p, q, dest = math.vec4()) {\n        const p0 = p[0];\n        const p1 = p[1];\n        const p2 = p[2];\n        const p3 = p[3];\n        const q0 = q[0];\n        const q1 = q[1];\n        const q2 = q[2];\n        const q3 = q[3];\n        dest[0] = p3 * q0 + p0 * q3 + p1 * q2 - p2 * q1;\n        dest[1] = p3 * q1 + p1 * q3 + p2 * q0 - p0 * q2;\n        dest[2] = p3 * q2 + p2 * q3 + p0 * q1 - p1 * q0;\n        dest[3] = p3 * q3 - p0 * q0 - p1 * q1 - p2 * q2;\n        return dest;\n    },\n\n    vec3ApplyQuaternion(q, vec, dest = math.vec3()) {\n        const x = vec[0];\n        const y = vec[1];\n        const z = vec[2];\n\n        const qx = q[0];\n        const qy = q[1];\n        const qz = q[2];\n        const qw = q[3];\n\n        // calculate quat * vector\n\n        const ix = qw * x + qy * z - qz * y;\n        const iy = qw * y + qz * x - qx * z;\n        const iz = qw * z + qx * y - qy * x;\n        const iw = -qx * x - qy * y - qz * z;\n\n        // calculate result * inverse quat\n\n        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n        return dest;\n    },\n\n    quaternionToMat4(q, dest) {\n\n        dest = math.identityMat4(dest);\n\n        const q0 = q[0];  //x\n        const q1 = q[1];  //y\n        const q2 = q[2];  //z\n        const q3 = q[3];  //w\n\n        const tx = 2.0 * q0;\n        const ty = 2.0 * q1;\n        const tz = 2.0 * q2;\n\n        const twx = tx * q3;\n        const twy = ty * q3;\n        const twz = tz * q3;\n\n        const txx = tx * q0;\n        const txy = ty * q0;\n        const txz = tz * q0;\n\n        const tyy = ty * q1;\n        const tyz = tz * q1;\n        const tzz = tz * q2;\n\n        dest[0] = 1.0 - (tyy + tzz);\n        dest[1] = txy + twz;\n        dest[2] = txz - twy;\n\n        dest[4] = txy - twz;\n        dest[5] = 1.0 - (txx + tzz);\n        dest[6] = tyz + twx;\n\n        dest[8] = txz + twy;\n        dest[9] = tyz - twx;\n\n        dest[10] = 1.0 - (txx + tyy);\n\n        return dest;\n    },\n\n    quaternionToRotationMat4(q, m) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        m[0] = 1 - (yy + zz);\n        m[4] = xy - wz;\n        m[8] = xz + wy;\n\n        m[1] = xy + wz;\n        m[5] = 1 - (xx + zz);\n        m[9] = yz - wx;\n\n        m[2] = xz - wy;\n        m[6] = yz + wx;\n        m[10] = 1 - (xx + yy);\n\n        // last column\n        m[3] = 0;\n        m[7] = 0;\n        m[11] = 0;\n\n        // bottom row\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n\n        return m;\n    },\n\n    normalizeQuaternion(q, dest = q) {\n        const len = math.lenVec4([q[0], q[1], q[2], q[3]]);\n        dest[0] = q[0] / len;\n        dest[1] = q[1] / len;\n        dest[2] = q[2] / len;\n        dest[3] = q[3] / len;\n        return dest;\n    },\n\n    conjugateQuaternion(q, dest = q) {\n        dest[0] = -q[0];\n        dest[1] = -q[1];\n        dest[2] = -q[2];\n        dest[3] = q[3];\n        return dest;\n    },\n\n    inverseQuaternion(q, dest) {\n        return math.normalizeQuaternion(math.conjugateQuaternion(q, dest));\n    },\n\n    quaternionToAngleAxis(q, angleAxis = math.vec4()) {\n        q = math.normalizeQuaternion(q, tempVec4);\n        const q3 = q[3];\n        const angle = 2 * Math.acos(q3);\n        const s = Math.sqrt(1 - q3 * q3);\n        if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt\n            angleAxis[0] = q[0];\n            angleAxis[1] = q[1];\n            angleAxis[2] = q[2];\n        } else {\n            angleAxis[0] = q[0] / s;\n            angleAxis[1] = q[1] / s;\n            angleAxis[2] = q[2] / s;\n        }\n        angleAxis[3] = angle; // * 57.295779579;\n        return angleAxis;\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Boundaries\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Returns a new, uninitialized 3D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB3(values) {\n        return new FloatArrayType(values || 6);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB2(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB3(values) {\n        return new FloatArrayType(values || 32);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB2(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /** Returns a new 3D bounding sphere */\n    Sphere3(x, y, z, r) {\n        return new FloatArrayType([x, y, z, r]);\n    },\n\n    /**\n     * Transforms an OBB3 by a 4x4 matrix.\n     *\n     * @private\n     */\n    transformOBB3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /** Returns true if the first AABB contains the second AABB.\n     * @param aabb1\n     * @param aabb2\n     * @returns {boolean}\n     */\n    containsAABB3: function (aabb1, aabb2) {\n        const result = (\n            aabb1[0] <= aabb2[0] && aabb2[3] <= aabb1[3] &&\n            aabb1[1] <= aabb2[1] && aabb2[4] <= aabb1[4] &&\n            aabb1[2] <= aabb2[2] && aabb2[5] <= aabb1[5]);\n        return result;\n    },\n\n    /**\n     * Gets the diagonal size of an AABB3 given as minima and maxima.\n     *\n     * @private\n     */\n    getAABB3Diag: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return aabb => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            math.subVec3(max, min, tempVec3);\n\n            return Math.abs(math.lenVec3(tempVec3));\n        };\n    }))(),\n\n    /**\n     * Get a diagonal boundary size that is symmetrical about the given point.\n     *\n     * @private\n     */\n    getAABB3DiagPoint: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return (aabb, p) => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            const diagVec = math.subVec3(max, min, tempVec3);\n\n            const xneg = p[0] - aabb[0];\n            const xpos = aabb[3] - p[0];\n            const yneg = p[1] - aabb[1];\n            const ypos = aabb[4] - p[1];\n            const zneg = p[2] - aabb[2];\n            const zpos = aabb[5] - p[2];\n\n            diagVec[0] += (xneg > xpos) ? xneg : xpos;\n            diagVec[1] += (yneg > ypos) ? yneg : ypos;\n            diagVec[2] += (zneg > zpos) ? zneg : zpos;\n\n            return Math.abs(math.lenVec3(diagVec));\n        };\n    }))(),\n\n    /**\n     * Gets the center of an AABB.\n     *\n     * @private\n     */\n    getAABB3Center(aabb, dest) {\n        const r = dest || math.vec3();\n\n        r[0] = (aabb[0] + aabb[3]) / 2;\n        r[1] = (aabb[1] + aabb[4]) / 2;\n        r[2] = (aabb[2] + aabb[5]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Gets the center of a 2D AABB.\n     *\n     * @private\n     */\n    getAABB2Center(aabb, dest) {\n        const r = dest || math.vec2();\n\n        r[0] = (aabb[2] + aabb[0]) / 2;\n        r[1] = (aabb[3] + aabb[1]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.\n     * Creates new AABB if none supplied.\n     *\n     * @private\n     */\n    collapseAABB3(aabb = math.AABB3()) {\n        aabb[0] = math.MAX_DOUBLE;\n        aabb[1] = math.MAX_DOUBLE;\n        aabb[2] = math.MAX_DOUBLE;\n        aabb[3] = -math.MAX_DOUBLE;\n        aabb[4] = -math.MAX_DOUBLE;\n        aabb[5] = -math.MAX_DOUBLE;\n\n        return aabb;\n    },\n\n    /**\n     * Converts an axis-aligned 3D boundary into an oriented boundary consisting of\n     * an array of eight 3D positions, one for each corner of the boundary.\n     *\n     * @private\n     */\n    AABB3ToOBB3(aabb, obb = math.OBB3()) {\n        obb[0] = aabb[0];\n        obb[1] = aabb[1];\n        obb[2] = aabb[2];\n        obb[3] = 1;\n\n        obb[4] = aabb[3];\n        obb[5] = aabb[1];\n        obb[6] = aabb[2];\n        obb[7] = 1;\n\n        obb[8] = aabb[3];\n        obb[9] = aabb[4];\n        obb[10] = aabb[2];\n        obb[11] = 1;\n\n        obb[12] = aabb[0];\n        obb[13] = aabb[4];\n        obb[14] = aabb[2];\n        obb[15] = 1;\n\n        obb[16] = aabb[0];\n        obb[17] = aabb[1];\n        obb[18] = aabb[5];\n        obb[19] = 1;\n\n        obb[20] = aabb[3];\n        obb[21] = aabb[1];\n        obb[22] = aabb[5];\n        obb[23] = 1;\n\n        obb[24] = aabb[3];\n        obb[25] = aabb[4];\n        obb[26] = aabb[5];\n        obb[27] = 1;\n\n        obb[28] = aabb[0];\n        obb[29] = aabb[4];\n        obb[30] = aabb[5];\n        obb[31] = 1;\n\n        return obb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    positions3ToAABB3: ((() => {\n\n        const p = new FloatArrayType(3);\n\n        return (positions, aabb, positionsDecodeMatrix) => {\n            aabb = aabb || math.AABB3();\n\n            let xmin = math.MAX_DOUBLE;\n            let ymin = math.MAX_DOUBLE;\n            let zmin = math.MAX_DOUBLE;\n            let xmax = -math.MAX_DOUBLE;\n            let ymax = -math.MAX_DOUBLE;\n            let zmax = -math.MAX_DOUBLE;\n\n            let x;\n            let y;\n            let z;\n\n            for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                if (positionsDecodeMatrix) {\n\n                    p[0] = positions[i + 0];\n                    p[1] = positions[i + 1];\n                    p[2] = positions[i + 2];\n\n                    math.decompressPosition(p, positionsDecodeMatrix, p);\n\n                    x = p[0];\n                    y = p[1];\n                    z = p[2];\n\n                } else {\n                    x = positions[i + 0];\n                    y = positions[i + 1];\n                    z = positions[i + 2];\n                }\n\n                if (x < xmin) {\n                    xmin = x;\n                }\n\n                if (y < ymin) {\n                    ymin = y;\n                }\n\n                if (z < zmin) {\n                    zmin = z;\n                }\n\n                if (x > xmax) {\n                    xmax = x;\n                }\n\n                if (y > ymax) {\n                    ymax = y;\n                }\n\n                if (z > zmax) {\n                    zmax = z;\n                }\n            }\n\n            aabb[0] = xmin;\n            aabb[1] = ymin;\n            aabb[2] = zmin;\n            aabb[3] = xmax;\n            aabb[4] = ymax;\n            aabb[5] = zmax;\n\n            return aabb;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    OBB3ToAABB3(obb, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = -math.MAX_DOUBLE;\n        let ymax = -math.MAX_DOUBLE;\n        let zmax = -math.MAX_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = obb.length; i < len; i += 4) {\n\n            x = obb[i + 0];\n            y = obb[i + 1];\n            z = obb[i + 2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToAABB3(points, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = -math.MAX_DOUBLE;\n        let ymax = -math.MAX_DOUBLE;\n        let zmax = -math.MAX_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = points.length; i < len; i++) {\n\n            x = points[i][0];\n            y = points[i][1];\n            z = points[i][2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToSphere3: ((() => {\n\n        const tempVec3 = new FloatArrayType(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const numPoints = points.length;\n\n            for (i = 0; i < numPoints; i++) {\n                x += points[i][0];\n                y += points[i][1];\n                z += points[i][2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < numPoints; i++) {\n\n                dist = Math.abs(math.lenVec3(math.subVec3(points[i], sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D positions.\n     *\n     * @private\n     */\n    positions3ToSphere3: ((() => {\n\n        const tempVec3a = new FloatArrayType(3);\n        const tempVec3b = new FloatArrayType(3);\n\n        return (positions, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPositions = positions.length;\n            let radius = 0;\n\n            for (i = 0; i < lenPositions; i += 3) {\n                x += positions[i];\n                y += positions[i + 1];\n                z += positions[i + 2];\n            }\n\n            const numPositions = lenPositions / 3;\n\n            sphere[0] = x / numPositions;\n            sphere[1] = y / numPositions;\n            sphere[2] = z / numPositions;\n\n            let dist;\n\n            for (i = 0; i < lenPositions; i += 3) {\n\n                tempVec3a[0] = positions[i];\n                tempVec3a[1] = positions[i + 1];\n                tempVec3a[2] = positions[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(tempVec3a, sphere, tempVec3b)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    OBB3ToSphere3: ((() => {\n\n        const point = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPoints = points.length;\n            const numPoints = lenPoints / 4;\n\n            for (i = 0; i < lenPoints; i += 4) {\n                x += points[i + 0];\n                y += points[i + 1];\n                z += points[i + 2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < lenPoints; i += 4) {\n\n                point[0] = points[i + 0];\n                point[1] = points[i + 1];\n                point[2] = points[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(point, sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Gets the center of a bounding sphere.\n     *\n     * @private\n     */\n    getSphere3Center(sphere, dest = math.vec3()) {\n        dest[0] = sphere[0];\n        dest[1] = sphere[1];\n        dest[2] = sphere[2];\n\n        return dest;\n    },\n\n    /**\n     * Expands the first axis-aligned 3D boundary to enclose the second, if required.\n     *\n     * @private\n     */\n    expandAABB3(aabb1, aabb2) {\n\n        if (aabb1[0] > aabb2[0]) {\n            aabb1[0] = aabb2[0];\n        }\n\n        if (aabb1[1] > aabb2[1]) {\n            aabb1[1] = aabb2[1];\n        }\n\n        if (aabb1[2] > aabb2[2]) {\n            aabb1[2] = aabb2[2];\n        }\n\n        if (aabb1[3] < aabb2[3]) {\n            aabb1[3] = aabb2[3];\n        }\n\n        if (aabb1[4] < aabb2[4]) {\n            aabb1[4] = aabb2[4];\n        }\n\n        if (aabb1[5] < aabb2[5]) {\n            aabb1[5] = aabb2[5];\n        }\n\n        return aabb1;\n    },\n\n    /**\n     * Expands an axis-aligned 3D boundary to enclose the given point, if needed.\n     *\n     * @private\n     */\n    expandAABB3Point3(aabb, p) {\n\n        if (aabb[0] > p[0]) {\n            aabb[0] = p[0];\n        }\n\n        if (aabb[1] > p[1]) {\n            aabb[1] = p[1];\n        }\n\n        if (aabb[2] > p[2]) {\n            aabb[2] = p[2];\n        }\n\n        if (aabb[3] < p[0]) {\n            aabb[3] = p[0];\n        }\n\n        if (aabb[4] < p[1]) {\n            aabb[4] = p[1];\n        }\n\n        if (aabb[5] < p[2]) {\n            aabb[5] = p[2];\n        }\n\n        return aabb;\n    }\n};\n\nexport {math};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-tools/src/XKTModel/lib/math.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 144,
    "kind": "variable",
    "name": "doublePrecision",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~doublePrecision",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 145,
    "kind": "variable",
    "name": "FloatArrayType",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~FloatArrayType",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 146,
    "kind": "variable",
    "name": "tempMat1",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~tempMat1",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 147,
    "kind": "variable",
    "name": "tempMat2",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~tempMat2",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 148,
    "kind": "variable",
    "name": "tempVec4",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~tempVec4",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 149,
    "kind": "variable",
    "name": "math",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~math",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/math.js",
    "importStyle": "{math}",
    "description": "",
    "lineNumber": 13,
    "ignore": true,
    "type": {
      "types": [
        "{\"MAX_DOUBLE\": *, \"MIN_DOUBLE\": *, \"DEGTORAD\": number, \"RADTODEG\": number, \"vec2\": function, \"vec3\": function, \"vec4\": function, \"mat3\": function, \"mat3ToMat4\": function, \"mat4\": function, \"mat4ToMat3\": function, \"createUUID\": *, \"clamp\": function, \"fmod\": function, \"negateVec4\": function, \"addVec4\": function, \"addVec4Scalar\": function, \"addVec3\": function, \"addVec3Scalar\": function, \"subVec4\": function, \"subVec3\": function, \"subVec2\": function, \"subVec4Scalar\": function, \"subScalarVec4\": function, \"mulVec4\": function, \"mulVec4Scalar\": function, \"mulVec3Scalar\": function, \"mulVec2Scalar\": function, \"divVec3\": function, \"divVec4\": function, \"divScalarVec3\": function, \"divVec3Scalar\": function, \"divVec4Scalar\": function, \"divScalarVec4\": function, \"dotVec4\": function, \"cross3Vec4\": function, \"cross3Vec3\": function, \"sqLenVec4\": function, \"lenVec4\": function, \"dotVec3\": function, \"dotVec2\": function, \"sqLenVec3\": function, \"sqLenVec2\": function, \"lenVec3\": function, \"distVec3\": *, \"lenVec2\": function, \"distVec2\": *, \"rcpVec3\": function, \"normalizeVec4\": function, \"normalizeVec3\": function, \"normalizeVec2\": function, \"angleVec3\": function, \"vec3FromMat4Scale\": *, \"vecToArray\": *, \"xyzArrayToObject\": function, \"xyzObjectToArray\": function, \"dupMat4\": function, \"mat4To3\": function, \"m4s\": function, \"setMat4ToZeroes\": function, \"setMat4ToOnes\": function, \"diagonalMat4v\": function, \"diagonalMat4c\": function, \"diagonalMat4s\": function, \"identityMat4\": function, \"identityMat3\": function, \"isIdentityMat4\": function, \"negateMat4\": function, \"addMat4\": function, \"addMat4Scalar\": function, \"addScalarMat4\": function, \"subMat4\": function, \"subMat4Scalar\": function, \"subScalarMat4\": function, \"mulMat4\": function, \"mulMat3\": function, \"mulMat4Scalar\": function, \"mulMat4v4\": function, \"transposeMat4\": function, \"transposeMat3\": function, \"determinantMat4\": function, \"inverseMat4\": function, \"traceMat4\": function, \"translationMat4v\": function, \"translationMat3v\": function, \"translationMat4c\": *, \"translationMat4s\": function, \"translateMat4v\": function, \"OLDtranslateMat4c\": function, \"translateMat4c\": function, \"rotationMat4v\": function, \"rotationMat4c\": function, \"scalingMat4v\": function, \"scalingMat3v\": function, \"scalingMat4c\": *, \"scaleMat4c\": function, \"scaleMat4v\": function, \"scalingMat4s\": function, \"rotationTranslationMat4\": function, \"mat4ToEuler\": function, \"composeMat4\": function, \"decomposeMat4\": *, \"lookAtMat4v\": function, \"lookAtMat4c\": function, \"orthoMat4c\": function, \"frustumMat4v\": function, \"frustumMat4\": function, \"perspectiveMat4\": function, \"transformPoint3\": function, \"transformPoint4\": function, \"transformPoints3\": function, \"transformPositions3\": function, \"transformPositions4\": function, \"transformVec3\": function, \"transformVec4\": function, \"rotateVec3X\": function, \"rotateVec3Y\": function, \"rotateVec3Z\": function, \"projectVec4\": function, \"unprojectVec3\": *, \"lerpVec3\": function, \"flatten\": function, \"identityQuaternion\": function, \"eulerToQuaternion\": function, \"mat4ToQuaternion\": function, \"vec3PairToQuaternion\": function, \"angleAxisToQuaternion\": function, \"quaternionToEuler\": *, \"mulQuaternions\": function, \"vec3ApplyQuaternion\": function, \"quaternionToMat4\": function, \"quaternionToRotationMat4\": function, \"normalizeQuaternion\": function, \"conjugateQuaternion\": function, \"inverseQuaternion\": function, \"quaternionToAngleAxis\": function, \"AABB3\": function, \"AABB2\": function, \"OBB3\": function, \"OBB2\": function, \"Sphere3\": function, \"transformOBB3\": function, \"containsAABB3\": *, \"getAABB3Diag\": *, \"getAABB3DiagPoint\": *, \"getAABB3Center\": function, \"getAABB2Center\": function, \"collapseAABB3\": function, \"AABB3ToOBB3\": function, \"positions3ToAABB3\": *, \"OBB3ToAABB3\": function, \"points3ToAABB3\": function, \"points3ToSphere3\": *, \"positions3ToSphere3\": *, \"OBB3ToSphere3\": *, \"getSphere3Center\": function, \"expandAABB3\": function, \"expandAABB3Point3\": function}"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "file",
    "name": "src/XKTModel/lib/utils.js",
    "content": "function isString(value) {\n    return (typeof value === 'string' || value instanceof String);\n}\n\n/**\n * @private\n */\nconst utils = {\n    isString: isString,\n};\n\nexport {utils};\n",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-tools/src/XKTModel/lib/utils.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 151,
    "kind": "function",
    "name": "isString",
    "memberof": "src/XKTModel/lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/utils.js~isString",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 152,
    "kind": "variable",
    "name": "utils",
    "memberof": "src/XKTModel/lib/utils.js",
    "static": true,
    "longname": "src/XKTModel/lib/utils.js~utils",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/lib/utils.js",
    "importStyle": "{utils}",
    "description": "",
    "lineNumber": 8,
    "ignore": true,
    "type": {
      "types": [
        "{\"isString\": *}"
      ]
    }
  },
  {
    "__docId__": 153,
    "kind": "file",
    "name": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "content": "import {utils} from \"./lib/utils.js\";\nimport {math} from \"./lib/math.js\";\n\n// HACK: Allows node.js to find atob()\nlet atob2;\nif (typeof atob === 'undefined') {\n    const atob = require('atob');\n    atob2 = atob;\n} else {\n    atob2 = atob;\n}\n\nconst WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n};\n\nconst WEBGL_TYPE_SIZES = {\n    'SCALAR': 1,\n    'VEC2': 2,\n    'VEC3': 3,\n    'VEC4': 4,\n    'MAT2': 4,\n    'MAT3': 9,\n    'MAT4': 16\n};\n\n/**\n * Parses glTF JSON into an {@link XKTModel}.\n *\n * Expects the XKTModel to be freshly instantiated, and calls {@link XKTModel#finalize} on the XKTModel before returning.\n *\n * @param {Object} gltf The glTF JSON.\n * @param {XKTModel} model XKTModel to parse into\n * @param {function} getAttachment Callback through which to fetch attachments, if the glTF has them.\n */\nasync function loadGLTFIntoXKTModel(gltf, model, getAttachment) {\n    const parsingCtx = {\n        gltf: gltf,\n        getAttachment: getAttachment || (() => {throw new Error('You must define getAttachment() method to convert glTF with external resources')}),\n        model: model,\n        numPrimitivesCreated: 0,\n        numEntitiesCreated: 0,\n        nodes: [],\n        meshInstanceCounts: {},\n        _meshPrimitiveIds: {}\n    };\n    await parseBuffers(parsingCtx);\n    parseBufferViews(parsingCtx);\n    freeBuffers(parsingCtx);\n    parseMaterials(parsingCtx);\n    parseDefaultScene(parsingCtx);\n}\nasync function parseBuffers(parsingCtx) {  // Parses geometry buffers into temporary  \"_buffer\" Unit8Array properties on the glTF \"buffer\" elements\n    const buffers = parsingCtx.gltf.buffers;\n    if (buffers) {\n        await Promise.all(buffers.map(buffer => parseBuffer(parsingCtx, buffer)));\n    }\n}\n\nasync function parseBuffer(parsingCtx, bufferInfo) {\n    const uri = bufferInfo.uri;\n    if (!uri) {\n        throw new Error('gltf/handleBuffer missing uri in ' + JSON.stringify(bufferInfo));\n    }\n    bufferInfo._buffer = await parseArrayBuffer(parsingCtx, uri);\n}\n\nasync function parseArrayBuffer(parsingCtx, uri) {\n    // Check for data: URI\n    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n    const dataUriRegexResult = uri.match(dataUriRegex);\n    if (dataUriRegexResult) { // Safari can't handle data URIs through XMLHttpRequest\n        const isBase64 = !!dataUriRegexResult[2];\n        let data = dataUriRegexResult[3];\n        data = decodeURIComponent(data);\n        if (isBase64) {\n            data = atob2(data);\n        }\n        const buffer = new ArrayBuffer(data.length);\n        const view = new Uint8Array(buffer);\n        for (let i = 0; i < data.length; i++) {\n            view[i] = data.charCodeAt(i);\n        }\n        return buffer;\n\n    } else {\n        // Uri is a path to a file\n        const contents = await parsingCtx.getAttachment(uri);\n        return toArrayBuffer(contents);\n    }\n}\n\nfunction toArrayBuffer(buf) {\n    var ab = new ArrayBuffer(buf.length);\n    var view = new Uint8Array(ab);\n    for (let i = 0; i < buf.length; ++i) {\n        view[i] = buf[i];\n    }\n    return ab;\n}\n\nfunction parseBufferViews(parsingCtx) { // Parses our temporary \"_buffer\" properties into \"_buffer\" properties on glTF \"bufferView\" elements\n    const bufferViewsInfo = parsingCtx.gltf.bufferViews;\n    if (bufferViewsInfo) {\n        for (var i = 0, len = bufferViewsInfo.length; i < len; i++) {\n            parseBufferView(parsingCtx, bufferViewsInfo[i]);\n        }\n    }\n}\n\nfunction parseBufferView(parsingCtx, bufferViewInfo) {\n    const buffer = parsingCtx.gltf.buffers[bufferViewInfo.buffer];\n    bufferViewInfo._typedArray = null;\n    const byteLength = bufferViewInfo.byteLength || 0;\n    const byteOffset = bufferViewInfo.byteOffset || 0;\n    bufferViewInfo._buffer = buffer._buffer.slice(byteOffset, byteOffset + byteLength);\n}\n\nfunction freeBuffers(parsingCtx) { // Deletes the \"_buffer\" properties from the glTF \"buffer\" elements, to save memory\n    const buffers = parsingCtx.gltf.buffers;\n    if (buffers) {\n        for (var i = 0, len = buffers.length; i < len; i++) {\n            buffers[i]._buffer = null;\n        }\n    }\n}\n\nfunction parseMaterials(parsingCtx) {\n    const materialsInfo = parsingCtx.gltf.materials;\n    if (materialsInfo) {\n        var materialInfo;\n        var material;\n        for (var i = 0, len = materialsInfo.length; i < len; i++) {\n            materialInfo = materialsInfo[i];\n            material = parseMaterialColor(parsingCtx, materialInfo);\n            materialInfo._rgbaColor = material;\n        }\n    }\n}\n\nfunction parseMaterialColor(parsingCtx, materialInfo) { // Attempts to extract an RGBA color for a glTF material\n    const color = new Float32Array([1, 1, 1, 1]);\n    const extensions = materialInfo.extensions;\n    if (extensions) {\n        const specularPBR = extensions[\"KHR_materials_pbrSpecularGlossiness\"];\n        if (specularPBR) {\n            const diffuseFactor = specularPBR.diffuseFactor;\n            if (diffuseFactor !== null && diffuseFactor !== undefined) {\n                color.set(diffuseFactor);\n            }\n        }\n        const common = extensions[\"KHR_materials_common\"];\n        if (common) {\n            const technique = common.technique;\n            const values = common.values || {};\n            const blinn = technique === \"BLINN\";\n            const phong = technique === \"PHONG\";\n            const lambert = technique === \"LAMBERT\";\n            const diffuse = values.diffuse;\n            if (diffuse && (blinn || phong || lambert)) {\n                if (!utils.isString(diffuse)) {\n                    color.set(diffuse);\n                }\n            }\n            const transparency = values.transparency;\n            if (transparency !== null && transparency !== undefined) {\n                color[3] = transparency;\n            }\n            const transparent = values.transparent;\n            if (transparent !== null && transparent !== undefined) {\n                color[3] = transparent;\n            }\n        }\n    }\n    const metallicPBR = materialInfo.pbrMetallicRoughness;\n    if (metallicPBR) {\n        const baseColorFactor = metallicPBR.baseColorFactor;\n        if (baseColorFactor) {\n            color.set(baseColorFactor);\n        }\n    }\n    return color;\n}\n\nfunction parseDefaultScene(parsingCtx) {\n    const scene = parsingCtx.gltf.scene || 0;\n    const defaultSceneInfo = parsingCtx.gltf.scenes[scene];\n    if (!defaultSceneInfo) {\n        throw new Error(\"glTF has no default scene\");\n    }\n    prepareSceneCountMeshes(parsingCtx, defaultSceneInfo);\n    parseScene(parsingCtx, defaultSceneInfo);\n}\n\nfunction prepareSceneCountMeshes(parsingCtx, sceneInfo) {\n    const nodes = sceneInfo.nodes;\n    if (!nodes) {\n        return;\n    }\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        const glTFNode = parsingCtx.gltf.nodes[nodes[i]];\n        if (glTFNode) {\n            prepareNodeCountMeshes(parsingCtx, glTFNode);\n        }\n    }\n}\n\nfunction prepareNodeCountMeshes(parsingCtx, glTFNode) {\n\n    const gltf = parsingCtx.gltf;\n\n    const meshId = glTFNode.mesh;\n\n    if (meshId !== undefined) {\n        if (parsingCtx.meshInstanceCounts[meshId] !== undefined) {\n            parsingCtx.meshInstanceCounts [meshId]++;\n        } else {\n            parsingCtx.meshInstanceCounts [meshId] = 1;\n        }\n    }\n\n    if (glTFNode.children) {\n        const children = glTFNode.children;\n        for (let i = 0, len = children.length; i < len; i++) {\n            const childNodeIdx = children[i];\n            const childGLTFNode = gltf.nodes[childNodeIdx];\n            if (!childGLTFNode) {\n                continue;\n            }\n            prepareNodeCountMeshes(parsingCtx, childGLTFNode);\n        }\n    }\n}\n\nfunction parseScene(parsingCtx, sceneInfo) {\n    const nodes = sceneInfo.nodes;\n    if (!nodes) {\n        return;\n    }\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        const glTFNode = parsingCtx.gltf.nodes[nodes[i]];\n        if (glTFNode) {\n            parseNode(parsingCtx, glTFNode, null);\n        }\n    }\n}\n\nfunction parseNode(parsingCtx, glTFNode, matrix) {\n\n    const gltf = parsingCtx.gltf;\n    const model = parsingCtx.model;\n\n    let localMatrix;\n\n    if (glTFNode.matrix) {\n        localMatrix = glTFNode.matrix;\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, math.mat4());\n        } else {\n            matrix = localMatrix;\n        }\n    }\n\n    if (glTFNode.translation) {\n        localMatrix = math.translationMat4v(glTFNode.translation);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, localMatrix);\n        } else {\n            matrix = localMatrix;\n        }\n    }\n\n    if (glTFNode.rotation) {\n        localMatrix = math.quaternionToMat4(glTFNode.rotation);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, localMatrix);\n        } else {\n            matrix = localMatrix;\n        }\n    }\n\n    if (glTFNode.scale) {\n        localMatrix = math.scalingMat4v(glTFNode.scale);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, localMatrix);\n        } else {\n            matrix = localMatrix;\n        }\n    }\n\n    const meshId = glTFNode.mesh;\n\n    if (meshId !== undefined) {\n\n        const meshInfo = gltf.meshes[meshId];\n\n        if (meshInfo) {\n\n            let primitivesReused = (parsingCtx.meshInstanceCounts [meshId] > 1);\n\n            let primitiveModelingMatrix;\n            let entityModelingMatrix;\n\n            if (primitivesReused) {\n\n                // Primitives in a mesh that is shared are left in Model-space\n                // Entities that instance those primitives will use their matrix to transform the primitives into World-space\n\n                primitiveModelingMatrix = math.identityMat4();\n                entityModelingMatrix = matrix ? matrix.slice() : math.identityMat4();\n\n            } else {\n\n                // glTF meshes do not share primitives - each primitive belongs to one mesh\n                // Primitives in a mesh that's not shared get baked into World-space\n\n                primitiveModelingMatrix = matrix ? matrix.slice() : math.identityMat4();\n                entityModelingMatrix = math.identityMat4();\n            }\n\n            const numPrimitivesInMesh = meshInfo.primitives.length;\n\n            if (numPrimitivesInMesh > 0) {\n\n                let primitiveIds = parsingCtx._meshPrimitiveIds[meshId];\n\n                if (!primitiveIds) {\n\n                    primitiveIds = [];\n\n                    for (let i = 0; i < numPrimitivesInMesh; i++) {\n\n                        const primitiveInfo = meshInfo.primitives[i];\n                        const materialIndex = primitiveInfo.material;\n                        const materialInfo = (materialIndex !== null && materialIndex !== undefined) ? gltf.materials[materialIndex] : null;\n                        const color = materialInfo ? materialInfo._rgbaColor : new Float32Array([1.0, 1.0, 1.0, 1.0]);\n                        const opacity = materialInfo ? materialInfo._rgbaColor[3] : 1.0;\n\n                        const geometryArrays = {};\n\n                        parsePrimitiveGeometry(parsingCtx, primitiveInfo, geometryArrays);\n\n                        const primitiveId = parsingCtx.numPrimitivesCreated;\n\n                        model.createPrimitive({\n                            primitiveId: primitiveId,\n                            primitiveType: \"triangles\",\n                            matrix: primitiveModelingMatrix,\n                            color: color,\n                            opacity: opacity,\n                            positions: new Float64Array(geometryArrays.positions), // Double precision required for baking non-reused primitive positions\n                            normals: geometryArrays.normals,\n                            indices: geometryArrays.indices\n                        });\n\n                        primitiveIds.push(primitiveId);\n\n                        parsingCtx.numPrimitivesCreated++;\n                    }\n\n                    parsingCtx._meshPrimitiveIds [meshId] = primitiveIds;\n                }\n\n                const entityId = glTFNode.name || \"entity\" + parsingCtx.numEntitiesCreated;\n\n                model.createEntity({\n                    entityId: entityId,\n                    matrix: entityModelingMatrix,\n                    primitiveIds: primitiveIds\n                });\n\n                parsingCtx.numEntitiesCreated++;\n            }\n        }\n    }\n\n    if (glTFNode.children) {\n        const children = glTFNode.children;\n        for (let i = 0, len = children.length; i < len; i++) {\n            const childNodeIdx = children[i];\n            const childGLTFNode = gltf.nodes[childNodeIdx];\n            if (!childGLTFNode) {\n                console.warn('Node not found: ' + i);\n                continue;\n            }\n            parseNode(parsingCtx, childGLTFNode, matrix);\n        }\n    }\n}\n\nfunction parsePrimitiveGeometry(parsingCtx, primitiveInfo, geometryArrays) {\n    const attributes = primitiveInfo.attributes;\n    if (!attributes) {\n        return;\n    }\n    geometryArrays.primitive = \"triangles\";\n    const accessors = parsingCtx.gltf.accessors;\n    const indicesIndex = primitiveInfo.indices;\n    if (indicesIndex !== null && indicesIndex !== undefined) {\n        const accessorInfo = accessors[indicesIndex];\n        geometryArrays.indices = parseAccessorTypedArray(parsingCtx, accessorInfo);\n    }\n    const positionsIndex = attributes.POSITION;\n    if (positionsIndex !== null && positionsIndex !== undefined) {\n        const accessorInfo = accessors[positionsIndex];\n        geometryArrays.positions = parseAccessorTypedArray(parsingCtx, accessorInfo);\n    }\n    const normalsIndex = attributes.NORMAL;\n    if (normalsIndex !== null && normalsIndex !== undefined) {\n        const accessorInfo = accessors[normalsIndex];\n        geometryArrays.normals = parseAccessorTypedArray(parsingCtx, accessorInfo);\n    }\n}\n\nfunction parseAccessorTypedArray(parsingCtx, accessorInfo) {\n    const bufferViewInfo = parsingCtx.gltf.bufferViews[accessorInfo.bufferView];\n    const itemSize = WEBGL_TYPE_SIZES[accessorInfo.type];\n    const TypedArray = WEBGL_COMPONENT_TYPES[accessorInfo.componentType];\n    const elementBytes = TypedArray.BYTES_PER_ELEMENT; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n    const itemBytes = elementBytes * itemSize;\n    if (accessorInfo.byteStride && accessorInfo.byteStride !== itemBytes) { // The buffer is not interleaved if the stride is the item size in bytes.\n        throw new Error(\"interleaved buffer!\"); // TODO\n    } else {\n        return new TypedArray(bufferViewInfo._buffer, accessorInfo.byteOffset || 0, accessorInfo.count * itemSize);\n    }\n}\n\n\nexport {loadGLTFIntoXKTModel};\n",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-tools/src/XKTModel/loadGLTFIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 154,
    "kind": "variable",
    "name": "WEBGL_COMPONENT_TYPES",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~WEBGL_COMPONENT_TYPES",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "{\"5120\": *, \"5121\": *, \"5122\": *, \"5123\": *, \"5125\": *, \"5126\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 155,
    "kind": "variable",
    "name": "WEBGL_TYPE_SIZES",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~WEBGL_TYPE_SIZES",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "{\"SCALAR\": number, \"VEC2\": number, \"VEC3\": number, \"VEC4\": number, \"MAT2\": number, \"MAT3\": number, \"MAT4\": number}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 156,
    "kind": "function",
    "name": "parseBuffers",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~parseBuffers",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 157,
    "kind": "function",
    "name": "parseBuffer",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~parseBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "bufferInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 158,
    "kind": "function",
    "name": "parseArrayBuffer",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~parseArrayBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "uri",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 159,
    "kind": "function",
    "name": "toArrayBuffer",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~toArrayBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "params": [
      {
        "name": "buf",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 160,
    "kind": "function",
    "name": "parseBufferViews",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~parseBufferViews",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 107,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 161,
    "kind": "function",
    "name": "parseBufferView",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~parseBufferView",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 116,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "bufferViewInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 162,
    "kind": "function",
    "name": "freeBuffers",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~freeBuffers",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 124,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 163,
    "kind": "function",
    "name": "parseMaterials",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~parseMaterials",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 133,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 164,
    "kind": "function",
    "name": "parseMaterialColor",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~parseMaterialColor",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 146,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "materialInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 165,
    "kind": "function",
    "name": "parseDefaultScene",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~parseDefaultScene",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 190,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 166,
    "kind": "function",
    "name": "prepareSceneCountMeshes",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~prepareSceneCountMeshes",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 200,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "sceneInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 167,
    "kind": "function",
    "name": "prepareNodeCountMeshes",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~prepareNodeCountMeshes",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 213,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "glTFNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 168,
    "kind": "function",
    "name": "parseScene",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~parseScene",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 240,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "sceneInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 169,
    "kind": "function",
    "name": "parseNode",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~parseNode",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 253,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "glTFNode",
        "types": [
          "*"
        ]
      },
      {
        "name": "matrix",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 170,
    "kind": "function",
    "name": "parsePrimitiveGeometry",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~parsePrimitiveGeometry",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 396,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "primitiveInfo",
        "types": [
          "*"
        ]
      },
      {
        "name": "geometryArrays",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 171,
    "kind": "function",
    "name": "parseAccessorTypedArray",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~parseAccessorTypedArray",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 420,
    "undocument": true,
    "params": [
      {
        "name": "parsingCtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "accessorInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 172,
    "kind": "function",
    "name": "loadGLTFIntoXKTModel",
    "memberof": "src/XKTModel/loadGLTFIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/XKTModel/loadGLTFIntoXKTModel.js~loadGLTFIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/loadGLTFIntoXKTModel.js",
    "importStyle": "{loadGLTFIntoXKTModel}",
    "description": "Parses glTF JSON into an {@link XKTModel}.\n\nExpects the XKTModel to be freshly instantiated, and calls {@link XKTModel#finalize} on the XKTModel before returning.",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "gltf",
        "description": "The glTF JSON."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "model",
        "description": "XKTModel to parse into"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "getAttachment",
        "description": "Callback through which to fetch attachments, if the glTF has them."
      }
    ],
    "return": null
  },
  {
    "__docId__": 173,
    "kind": "file",
    "name": "src/XKTModel/validateXKTArrayBuffer.js",
    "content": "/**\n * @desc Validates an {@link ArrayBuffer} against the {@link XKTModel} it was written from.\n *\n * @param {ArrayBuffer} arrayBuffer The {@link ArrayBuffer}.\n * @param {XKTModel} xktModel The {@link XKTModel} that the {@link ArrayBuffer} was written from.\n * @returns {Boolean} True if valid, else false. Logs validity failures to the JS console.\n */\nfunction validateXKTArrayBuffer(arrayBuffer, xktModel) {\n\n    const dataView = new DataView(arrayBuffer);\n    const dataArray = new Uint8Array(arrayBuffer);\n    const xktVersion = dataView.getUint32(0, true);\n    const numElements = dataView.getUint32(4, true);\n\n    const elements = [];\n\n    let byteOffset = (numElements + 2) * 4;\n\n    for (let i = 0; i < numElements; i++) {\n        const elementSize = dataView.getUint32((i + 2) * 4, true);\n        elements.push(dataArray.subarray(byteOffset, byteOffset + elementSize));\n        byteOffset += elementSize;\n    }\n\n    const deflatedData = extract(elements);\n    const inflatedData = inflate(deflatedData);\n\n    return validateData(inflatedData, xktModel);\n}\n\nfunction extract(elements) {\n    return {\n        positions: elements[0],\n        normals: elements[1],\n        indices: elements[2],\n        edgeIndices: elements[3],\n        matrices: elements[4],\n        reusedPrimitivesDecodeMatrix: elements[5],\n        eachPrimitivePositionsAndNormalsPortion: elements[6],\n        eachPrimitiveIndicesPortion: elements[7],\n        eachPrimitiveEdgeIndicesPortion: elements[8],\n        eachPrimitiveColorAndOpacity: elements[9],\n        primitiveInstances: elements[10],\n        eachEntityId: elements[11],\n        eachEntityPrimitiveInstancesPortion: elements[12],\n        eachEntityMatricesPortion: elements[13],\n        eachTileAABB: elements[14],\n        eachTileEntitiesPortion: elements[15]\n    };\n}\n\nfunction inflate(deflatedData) {\n    return {\n        positions: new Uint16Array(pako.inflate(deflatedData.positions).buffer),\n        normals: new Int8Array(pako.inflate(deflatedData.normals).buffer),\n        indices: new Uint32Array(pako.inflate(deflatedData.indices).buffer),\n        edgeIndices: new Uint32Array(pako.inflate(deflatedData.edgeIndices).buffer),\n        matrices: new Float32Array(pako.inflate(deflatedData.matrices).buffer),\n        reusedPrimitivesDecodeMatrix: new Float32Array(pako.inflate(deflatedData.reusedPrimitivesDecodeMatrix).buffer),\n        eachPrimitivePositionsAndNormalsPortion: new Uint32Array(pako.inflate(deflatedData.eachPrimitivePositionsAndNormalsPortion).buffer),\n        eachPrimitiveIndicesPortion: new Uint32Array(pako.inflate(deflatedData.eachPrimitiveIndicesPortion).buffer),\n        eachPrimitiveEdgeIndicesPortion: new Uint32Array(pako.inflate(deflatedData.eachPrimitiveEdgeIndicesPortion).buffer),\n        eachPrimitiveColorAndOpacity: new Uint8Array(pako.inflate(deflatedData.eachPrimitiveColorAndOpacity).buffer),\n        primitiveInstances: new Uint32Array(pako.inflate(deflatedData.primitiveInstances).buffer),\n        eachEntityId: pako.inflate(deflatedData.eachEntityId, {to: 'string'}),\n        eachEntityPrimitiveInstancesPortion: new Uint32Array(pako.inflate(deflatedData.eachEntityPrimitiveInstancesPortion).buffer),\n        eachEntityMatricesPortion: new Uint32Array(pako.inflate(deflatedData.eachEntityMatricesPortion).buffer),\n        eachTileAABB: new Float64Array(pako.inflate(deflatedData.eachTileAABB).buffer),\n        eachTileEntitiesPortion: new Uint32Array(pako.inflate(deflatedData.eachTileEntitiesPortion).buffer),\n    };\n}\n\nconst decompressColor = (function () {\n    const floatColor = new Float32Array(3);\n    return function (intColor) {\n        floatColor[0] = intColor[0] / 255.0;\n        floatColor[1] = intColor[1] / 255.0;\n        floatColor[2] = intColor[2] / 255.0;\n        return floatColor;\n    };\n})();\n\nfunction validateData(inflatedData, xktModel) {\n\n    const positions = inflatedData.positions;\n    const normals = inflatedData.normals;\n    const indices = inflatedData.indices;\n    const edgeIndices = inflatedData.edgeIndices;\n\n    const matrices = inflatedData.matrices;\n\n    const reusedPrimitivesDecodeMatrix = inflatedData.reusedPrimitivesDecodeMatrix;\n\n    const eachPrimitivePositionsAndNormalsPortion = inflatedData.eachPrimitivePositionsAndNormalsPortion;\n    const eachPrimitiveIndicesPortion = inflatedData.eachPrimitiveIndicesPortion;\n    const eachPrimitiveEdgeIndicesPortion = inflatedData.eachPrimitiveEdgeIndicesPortion;\n    const eachPrimitiveColorAndOpacity = inflatedData.eachPrimitiveColorAndOpacity;\n\n    const primitiveInstances = inflatedData.primitiveInstances;\n\n    const eachEntityId = JSON.parse(inflatedData.eachEntityId);\n    const eachEntityPrimitiveInstancesPortion = inflatedData.eachEntityPrimitiveInstancesPortion;\n    const eachEntityMatricesPortion = inflatedData.eachEntityMatricesPortion;\n\n    const eachTileAABB = inflatedData.eachTileAABB;\n    const eachTileDecodeMatrix = inflatedData.eachTileDecodeMatrix;\n    const eachTileEntitiesPortion = inflatedData.eachTileEntitiesPortion;\n\n    const numPrimitives = eachPrimitivePositionsAndNormalsPortion.length;\n    const numPrimitiveInstances = primitiveInstances.length;\n    const numEntities = eachEntityId.length;\n    const numTiles = eachTileEntitiesPortion.length;\n\n    // ASSERTIONS\n\n    if (numTiles !== xktModel.tilesList.length) {\n        console.error(\"Unexpected number of tiles; found \" + numTiles + \", but expected \" + xktModel.tilesList.length);\n        return false;\n    }\n\n    // Count instances of each primitive\n\n    const primitiveReuseCounts = new Uint32Array(numPrimitives);\n\n    for (let primitiveInstanceIndex = 0; primitiveInstanceIndex < numPrimitiveInstances; primitiveInstanceIndex++) {\n        const primitiveIndex = primitiveInstances[primitiveInstanceIndex];\n        if (primitiveReuseCounts[primitiveIndex] !== undefined) {\n            primitiveReuseCounts[primitiveIndex]++;\n        } else {\n            primitiveReuseCounts[primitiveIndex] = 1;\n        }\n    }\n\n    // Iterate over tiles\n\n    for (let tileIndex = 0; tileIndex < numTiles; tileIndex++) {\n\n        const lastTileIndex = (numTiles - 1);\n        const atLastTile = (tileIndex === lastTileIndex);\n\n        const firstTileEntityIndex = eachTileEntitiesPortion [tileIndex];\n        const lastTileEntityIndex = atLastTile ? numEntities : eachTileEntitiesPortion[tileIndex + 1];\n\n        const tileDecodeMatrixIndex = tileIndex * 16;\n        const tileAABBIndex = tileIndex * 6;\n\n        const tileAABB = eachTileAABB.subarray(tileAABBIndex, tileAABBIndex + 6);\n\n        // ASSERTIONS\n\n        const xktTile = xktModel.tilesList[tileIndex];\n\n        if (!xktTile) {\n            console.error(\"xktModel.tilesList[tileIndex] not found\");\n            return false;\n        }\n\n        if (!compareArrays(tileAABB, xktTile.aabb)) {\n            console.error(\"compareArrays(tileAABB, xktTile.aabb) === false\");\n            return false;\n        }\n\n        const numTileEntities = (lastTileEntityIndex - firstTileEntityIndex);\n        if (numTileEntities !== xktTile.entities.length) {\n            console.error(\"Unexpected number of entities in tile\");\n            return false;\n        }\n\n        // Iterate over each tile's entities\n\n        for (let tileEntityIndex = firstTileEntityIndex; tileEntityIndex < lastTileEntityIndex; tileEntityIndex++) {\n\n            const entityId = eachEntityId[tileEntityIndex];\n\n            const entityMatrixIndex = eachEntityMatricesPortion[tileEntityIndex];\n            const entityMatrix = matrices.slice(entityMatrixIndex, entityMatrixIndex + 16);\n\n            const lastTileEntityIndex = (numEntities - 1);\n            const atLastTileEntity = (tileEntityIndex === lastTileEntityIndex);\n            const firstPrimitiveInstanceIndex = eachEntityPrimitiveInstancesPortion [tileEntityIndex];\n            const lastPrimitiveInstanceIndex = atLastTileEntity ? primitiveInstances.length : eachEntityPrimitiveInstancesPortion[tileEntityIndex + 1];\n\n            // ASSERTIONS\n\n            const xktEntity = xktModel.entitiesList[tileEntityIndex];\n\n            if (!xktEntity) {\n                console.error(\"xktModel.entitiesList[tileEntityIndex] not found\");\n                return false;\n            }\n\n            if (entityId !== xktEntity.entityId) {\n                console.error(\"entityId !== xktEntity.entityId\");\n                return false;\n            }\n\n            if (!compareArrays(entityMatrix, xktEntity.matrix)) {\n                console.error(\"compareArrays(entityMatrix, xktEntity.matrix) === false\");\n                return false;\n            }\n\n            // Iterate each entity's primitive instances\n\n            for (let primitiveInstancesIndex = firstPrimitiveInstanceIndex; primitiveInstancesIndex < lastPrimitiveInstanceIndex; primitiveInstancesIndex++) {\n\n                const primitiveIndex = primitiveInstances[primitiveInstancesIndex];\n                const primitiveReuseCount = primitiveReuseCounts[primitiveIndex];\n                const isReusedPrimitive = (primitiveReuseCount > 1);\n\n                const atLastPrimitive = (primitiveIndex === (numPrimitives - 1));\n\n                const primitivePositions = positions.subarray(eachPrimitivePositionsAndNormalsPortion [primitiveIndex], atLastPrimitive ? positions.length : eachPrimitivePositionsAndNormalsPortion [primitiveIndex + 1]);\n                const primitiveNormals = normals.subarray(eachPrimitivePositionsAndNormalsPortion [primitiveIndex], atLastPrimitive ? normals.length : eachPrimitivePositionsAndNormalsPortion [primitiveIndex + 1]);\n                const primitiveIndices = indices.subarray(eachPrimitiveIndicesPortion [primitiveIndex], atLastPrimitive ? indices.length : eachPrimitiveIndicesPortion [primitiveIndex + 1]);\n                const primitiveEdgeIndices = edgeIndices.subarray(eachPrimitiveEdgeIndicesPortion [primitiveIndex], atLastPrimitive ? edgeIndices.length : eachPrimitiveEdgeIndicesPortion [primitiveIndex + 1]);\n\n                const color = decompressColor(eachPrimitiveColorAndOpacity.subarray((primitiveIndex * 4), (primitiveIndex * 4) + 3));\n                const opacity = eachPrimitiveColorAndOpacity[(primitiveIndex * 4) + 3] / 255.0;\n\n                // ASSERTIONS\n\n                const xktPrimitiveInstance = xktModel.primitiveInstancesList[primitiveInstancesIndex];\n                const xktPrimitive = xktModel.primitivesList[primitiveIndex];\n\n                if (!xktPrimitiveInstance) {\n                    console.error(\"xktModel.primitiveInstancesList[primitiveInstancesIndex] not found\");\n                    return false;\n                }\n\n                if (!xktPrimitive) {\n                    console.error(\"xktModel.primitivesList[primitiveIndex] not found\");\n                    return false;\n                }\n\n                if (xktPrimitiveInstance.primitive !== xktPrimitive) {\n                    console.error(\"xktPrimitiveInstance.primitive !== xktPrimitive\");\n                    return false;\n                }\n\n                if (!compareArrays(primitivePositions, xktPrimitive.positions)) {\n                    console.error(\"compareArrays(primitivePositions, xktPrimitive.positions) === false\");\n                    return false;\n                }\n\n                if (!compareArrays(primitiveNormals, xktPrimitive.normalsOctEncoded)) {\n                    console.error(\"compareArrays(primitiveNormals, xktPrimitive.normals) === false\");\n                    return false;\n                }\n\n                if (!compareArrays(primitiveIndices, xktPrimitive.indices)) {\n                    console.error(\"compareArrays(primitiveIndices, xktPrimitive.indices) === false\");\n                    return false;\n                }\n\n                if (!compareArrays(primitiveEdgeIndices, xktPrimitive.edgeIndices)) {\n                    console.error(\"compareArrays(primitiveEdgeIndices, xktPrimitive.edgeIndices) === false\");\n                    return false;\n                }\n\n                if (!compareArrays(color, xktPrimitive.color)) {\n                    console.error(\"compareArrays(color, xktPrimitive.color) === false\");\n                    return false;\n                }\n\n                if (opacity !== xktPrimitive.opacity) {\n                    console.error(\"opacity !== xktPrimitive.opacity\");\n                    return false;\n                }\n\n                if (primitiveReuseCount !== xktPrimitive.numInstances) {\n                    console.error(\"primitiveReuseCount !== xktPrimitive.numInstances\");\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nfunction compareArrays(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0, len = a.length; i < len; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport {validateXKTArrayBuffer};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-tools/src/XKTModel/validateXKTArrayBuffer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 174,
    "kind": "function",
    "name": "extract",
    "memberof": "src/XKTModel/validateXKTArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/validateXKTArrayBuffer.js~extract",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/validateXKTArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "params": [
      {
        "name": "elements",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"positions\": *, \"normals\": *, \"indices\": *, \"edgeIndices\": *, \"matrices\": *, \"reusedPrimitivesDecodeMatrix\": *, \"eachPrimitivePositionsAndNormalsPortion\": *, \"eachPrimitiveIndicesPortion\": *, \"eachPrimitiveEdgeIndicesPortion\": *, \"eachPrimitiveColorAndOpacity\": *, \"primitiveInstances\": *, \"eachEntityId\": *, \"eachEntityPrimitiveInstancesPortion\": *, \"eachEntityMatricesPortion\": *, \"eachTileAABB\": *, \"eachTileEntitiesPortion\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 175,
    "kind": "function",
    "name": "inflate",
    "memberof": "src/XKTModel/validateXKTArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/validateXKTArrayBuffer.js~inflate",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/validateXKTArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "params": [
      {
        "name": "deflatedData",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"positions\": *, \"normals\": *, \"indices\": *, \"edgeIndices\": *, \"matrices\": *, \"reusedPrimitivesDecodeMatrix\": *, \"eachPrimitivePositionsAndNormalsPortion\": *, \"eachPrimitiveIndicesPortion\": *, \"eachPrimitiveEdgeIndicesPortion\": *, \"eachPrimitiveColorAndOpacity\": *, \"primitiveInstances\": *, \"eachEntityId\": *, \"eachEntityPrimitiveInstancesPortion\": *, \"eachEntityMatricesPortion\": *, \"eachTileAABB\": *, \"eachTileEntitiesPortion\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 176,
    "kind": "variable",
    "name": "decompressColor",
    "memberof": "src/XKTModel/validateXKTArrayBuffer.js",
    "static": true,
    "longname": "src/XKTModel/validateXKTArrayBuffer.js~decompressColor",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/validateXKTArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 177,
    "kind": "function",
    "name": "validateData",
    "memberof": "src/XKTModel/validateXKTArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/validateXKTArrayBuffer.js~validateData",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/validateXKTArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "params": [
      {
        "name": "inflatedData",
        "types": [
          "*"
        ]
      },
      {
        "name": "xktModel",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 178,
    "kind": "function",
    "name": "compareArrays",
    "memberof": "src/XKTModel/validateXKTArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/validateXKTArrayBuffer.js~compareArrays",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/validateXKTArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 281,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 179,
    "kind": "function",
    "name": "validateXKTArrayBuffer",
    "memberof": "src/XKTModel/validateXKTArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/validateXKTArrayBuffer.js~validateXKTArrayBuffer",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/validateXKTArrayBuffer.js",
    "importStyle": "{validateXKTArrayBuffer}",
    "description": "Validates an {@link ArrayBuffer} against the {@link XKTModel} it was written from.",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Boolean} True if valid, else false. Logs validity failures to the JS console."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": false,
        "name": "arrayBuffer",
        "description": "The {@link ArrayBuffer}."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "xktModel",
        "description": "The {@link XKTModel} that the {@link ArrayBuffer} was written from."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": "True if valid, else false. Logs validity failures to the JS console."
    }
  },
  {
    "__docId__": 180,
    "kind": "file",
    "name": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "content": "import * as p from \"./lib/pako.es.js\";\n\nlet pako = p;\nif (!pako.inflate) {  // See https://github.com/nodeca/pako/issues/97\n    pako = pako.default;\n}\n\nconst XKT_VERSION = 6; // XKT format version\n\n/**\n * Writes an {@link XKTModel} to an {@link ArrayBuffer}.\n *\n * @param {XKTModel} xktModel The {@link XKTModel}.\n * @returns {ArrayBuffer} The {@link ArrayBuffer}.\n */\nfunction writeXKTModelToArrayBuffer(xktModel) {\n\n    const data = getModelData(xktModel);\n\n    const deflatedData = deflateData(data);\n\n    const arrayBuffer = createArrayBuffer(deflatedData);\n\n    return arrayBuffer;\n}\n\nfunction getModelData(xktModel) {\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Allocate data\n    //------------------------------------------------------------------------------------------------------------------\n\n    const primitivesList = xktModel.primitivesList;\n    const primitiveInstancesList = xktModel.primitiveInstancesList;\n    const entitiesList = xktModel.entitiesList;\n    const tilesList = xktModel.tilesList;\n\n    const numPrimitives = primitivesList.length;\n    const numPrimitiveInstances = primitiveInstancesList.length;\n    const numEntities = entitiesList.length;\n    const numTiles = tilesList.length;\n\n    let lenPositions = 0;\n    let lenNormals = 0;\n    let lenIndices = 0;\n    let lenEdgeIndices = 0;\n    let lenColors = 0;\n    let lenMatrices = 0;\n\n    for (let primitiveIndex = 0; primitiveIndex < numPrimitives; primitiveIndex++) {\n        const primitive = primitivesList [primitiveIndex];\n        lenPositions += primitive.positionsQuantized.length;\n        lenNormals += primitive.normalsOctEncoded.length;\n        lenIndices += primitive.indices.length;\n        lenEdgeIndices += primitive.edgeIndices.length;\n        lenColors += 4;\n    }\n\n    for (let entityIndex = 0; entityIndex < numEntities; entityIndex++) {\n        const entity = entitiesList[entityIndex];\n        if (entity.hasReusedPrimitives) {\n            lenMatrices += 16;\n        }\n    }\n\n    const data = {\n\n        positions: new Uint16Array(lenPositions), // All geometry arrays\n        normals: new Int8Array(lenNormals),\n        indices: new Uint32Array(lenIndices),\n        edgeIndices: new Uint32Array(lenEdgeIndices),\n\n        matrices: new Float32Array(lenMatrices), // Modeling matrices for entities that share primitives. Each entity either shares all it's primitives, or owns all its primitives exclusively. Exclusively-owned primitives are pre-transformed into World-space, and so their entities don't have modeling matrices in this array.\n\n        reusedPrimitivesDecodeMatrix: new Float32Array(xktModel.reusedPrimitivesDecodeMatrix), // A single, global vertex position de-quantization matrix for all reused primitives. Reused primitives are quantized to their collective Local-space AABB, and this matrix is derived from that AABB.\n\n        eachPrimitivePositionsAndNormalsPortion: new Uint32Array(numPrimitives), // For each primitive, an index to its first element in data.positions and data.normals\n        eachPrimitiveIndicesPortion: new Uint32Array(numPrimitives), // For each primitive, an index to its first element in data.indices\n        eachPrimitiveEdgeIndicesPortion: new Uint32Array(numPrimitives), // For each primitive, an index to its first element in data.edgeIndices\n        eachPrimitiveColorAndOpacity: new Uint8Array(lenColors), // For each primitive, an RGBA integer color of format [0..255, 0..255, 0..255, 0..255]\n\n        // Primitive instances are grouped in runs that are shared by the same entities\n\n        primitiveInstances: new Uint32Array(numPrimitiveInstances), // For each primitive instance, an index into the eachPrimitive* arrays\n\n        // Entity elements in the following arrays are grouped in runs that are shared by the same tiles\n\n        eachEntityId: [], // For each entity, an ID string\n        eachEntityPrimitiveInstancesPortion: new Uint32Array(numEntities), // For each entity, the index of the the first element of primitiveInstances used by the entity\n        eachEntityMatricesPortion: new Uint32Array(numEntities), // For each entity that shares primitives, an index to its first element in data.matrices, to indicate the modeling matrix that transforms the shared primitives' Local-space vertex positions. Thios is ignored for entities that don't share primitives, because the vertex positions of non-shared primitives are pre-transformed into World-space.\n\n        eachTileAABB: new Float64Array(numTiles * 6), // For each tile, an axis-aligned bounding box\n        eachTileEntitiesPortion: new Uint32Array(numTiles) // For each tile, the index of the the first element of eachEntityId, eachEntityPrimitiveInstancesPortion and eachEntityMatricesPortion used by the tile\n    };\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Populate the data\n    //------------------------------------------------------------------------------------------------------------------\n\n    let countPositions = 0;\n    let countNormals = 0;\n    let countIndices = 0;\n    let countEdgeIndices = 0;\n    let countColors = 0;\n\n    // Primitives\n\n    for (let primitiveIndex = 0; primitiveIndex < numPrimitives; primitiveIndex++) {\n\n        const primitive = primitivesList [primitiveIndex];\n\n        data.positions.set(primitive.positionsQuantized, countPositions);\n        data.normals.set(primitive.normalsOctEncoded, countNormals);\n        data.indices.set(primitive.indices, countIndices);\n        data.edgeIndices.set(primitive.edgeIndices, countEdgeIndices);\n\n        data.eachPrimitivePositionsAndNormalsPortion [primitiveIndex] = countPositions;\n        data.eachPrimitiveIndicesPortion [primitiveIndex] = countIndices;\n        data.eachPrimitiveEdgeIndicesPortion [primitiveIndex] = countEdgeIndices;\n        data.eachPrimitiveColorAndOpacity[countColors + 0] = Math.floor(primitive.color[0] * 255);\n        data.eachPrimitiveColorAndOpacity[countColors + 1] = Math.floor(primitive.color[1] * 255);\n        data.eachPrimitiveColorAndOpacity[countColors + 2] = Math.floor(primitive.color[2] * 255);\n        data.eachPrimitiveColorAndOpacity[countColors + 3] = Math.floor(primitive.opacity * 255);\n\n        countPositions += primitive.positions.length;\n        countNormals += primitive.normalsOctEncoded.length;\n        countIndices += primitive.indices.length;\n        countEdgeIndices += primitive.edgeIndices.length;\n        countColors += 4;\n    }\n\n    // Entities, primitive instances, and tiles\n\n    let entityIndex = 0;\n    let countEntityPrimitiveInstancesPortion = 0;\n    let matricesIndex = 0;\n\n    for (let tileIndex = 0; tileIndex < numTiles; tileIndex++) {\n\n        const tile = tilesList [tileIndex];\n        const tileEntities = tile.entities;\n        const numTileEntities = tileEntities.length;\n\n        if (numTileEntities === 0) {\n            continue;\n        }\n\n        data.eachTileEntitiesPortion[tileIndex] = entityIndex;\n\n        const tileAABB = tile.aabb;\n\n        for (let j = 0; j < numTileEntities; j++) {\n\n            const entity = tileEntities[j];\n            const entityPrimitiveInstances = entity.primitiveInstances;\n            const numEntityPrimitiveInstances = entityPrimitiveInstances.length;\n\n            if (numEntityPrimitiveInstances === 0) {\n                continue;\n            }\n\n            for (let k = 0; k < numEntityPrimitiveInstances; k++) {\n\n                const primitiveInstance = entityPrimitiveInstances[k];\n                const primitive = primitiveInstance.primitive;\n                const primitiveIndex = primitive.primitiveIndex;\n\n                data.primitiveInstances [countEntityPrimitiveInstancesPortion + k] = primitiveIndex;\n            }\n\n            if (entity.hasReusedPrimitives) {\n\n                data.matrices.set(entity.matrix, matricesIndex);\n                data.eachEntityMatricesPortion [entityIndex] = matricesIndex;\n\n                matricesIndex += 16;\n            }\n\n            data.eachEntityId [entityIndex] = entity.entityId;\n            data.eachEntityPrimitiveInstancesPortion[entityIndex] = countEntityPrimitiveInstancesPortion; // <<<<<<<<<<<<<<<<<<<< Error here? Order/value of countEntityPrimitiveInstancesPortion correct?\n\n            entityIndex++;\n            countEntityPrimitiveInstancesPortion += numEntityPrimitiveInstances;\n        }\n\n        const tileAABBIndex = tileIndex * 6;\n        const tileDecodeMatrixIndex = tileIndex * 16;\n\n        data.eachTileAABB.set(tileAABB, tileAABBIndex);\n    }\n\n    return data;\n}\n\nfunction deflateData(data) {\n\n    return {\n\n        positions: pako.deflate(data.positions.buffer),\n        normals: pako.deflate(data.normals.buffer),\n        indices: pako.deflate(data.indices.buffer),\n        edgeIndices: pako.deflate(data.edgeIndices.buffer),\n\n        matrices: pako.deflate(data.matrices.buffer),\n\n        reusedPrimitivesDecodeMatrix: pako.deflate(data.reusedPrimitivesDecodeMatrix.buffer),\n\n        eachPrimitivePositionsAndNormalsPortion: pako.deflate(data.eachPrimitivePositionsAndNormalsPortion.buffer),\n        eachPrimitiveIndicesPortion: pako.deflate(data.eachPrimitiveIndicesPortion.buffer),\n        eachPrimitiveEdgeIndicesPortion: pako.deflate(data.eachPrimitiveEdgeIndicesPortion.buffer),\n        eachPrimitiveColorAndOpacity: pako.deflate(data.eachPrimitiveColorAndOpacity.buffer),\n\n        primitiveInstances: pako.deflate(data.primitiveInstances.buffer),\n\n        eachEntityId: pako.deflate(JSON.stringify(data.eachEntityId)\n            .replace(/[\\u007F-\\uFFFF]/g, function (chr) { // Produce only ASCII-chars, so that the data can be inflated later\n                return \"\\\\u\" + (\"0000\" + chr.charCodeAt(0).toString(16)).substr(-4)\n            })),\n        eachEntityPrimitiveInstancesPortion: pako.deflate(data.eachEntityPrimitiveInstancesPortion.buffer),\n        eachEntityMatricesPortion: pako.deflate(data.eachEntityMatricesPortion.buffer),\n\n        eachTileAABB: pako.deflate(data.eachTileAABB.buffer),\n        eachTileEntitiesPortion: pako.deflate(data.eachTileEntitiesPortion.buffer)\n    };\n}\n\nfunction createArrayBuffer(deflatedData) {\n\n    return toArrayBuffer([\n\n        deflatedData.positions,\n        deflatedData.normals,\n        deflatedData.indices,\n        deflatedData.edgeIndices,\n\n        deflatedData.matrices,\n\n        deflatedData.reusedPrimitivesDecodeMatrix,\n\n        deflatedData.eachPrimitivePositionsAndNormalsPortion,\n        deflatedData.eachPrimitiveIndicesPortion,\n        deflatedData.eachPrimitiveEdgeIndicesPortion,\n        deflatedData.eachPrimitiveColorAndOpacity,\n\n        deflatedData.primitiveInstances,\n\n        deflatedData.eachEntityId,\n        deflatedData.eachEntityPrimitiveInstancesPortion,\n        deflatedData.eachEntityMatricesPortion,\n\n        deflatedData.eachTileAABB,\n        deflatedData.eachTileEntitiesPortion\n    ]);\n}\n\nfunction toArrayBuffer(elements) {\n    const indexData = new Uint32Array(elements.length + 2);\n    indexData[0] = XKT_VERSION;\n    indexData [1] = elements.length;  // Stored Data 1.1: number of stored elements\n    let dataLen = 0;    // Stored Data 1.2: length of stored elements\n    for (let i = 0, len = elements.length; i < len; i++) {\n        const element = elements[i];\n        const elementsize = element.length;\n        indexData[i + 2] = elementsize;\n        dataLen += elementsize;\n    }\n    const indexBuf = new Uint8Array(indexData.buffer);\n    const dataArray = new Uint8Array(indexBuf.length + dataLen);\n    dataArray.set(indexBuf);\n    var offset = indexBuf.length;\n    for (let i = 0, len = elements.length; i < len; i++) {     // Stored Data 2: the elements themselves\n        const element = elements[i];\n        dataArray.set(element, offset);\n        offset += element.length;\n    }\n    console.log(\"Array buffer size: \" + (dataArray.length / 1024).toFixed(3) + \" kB\");\n    return dataArray.buffer;\n}\n\nexport {writeXKTModelToArrayBuffer};",
    "static": true,
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-tools/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 181,
    "kind": "variable",
    "name": "pako",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~pako",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 182,
    "kind": "variable",
    "name": "XKT_VERSION",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~XKT_VERSION",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 183,
    "kind": "function",
    "name": "getModelData",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~getModelData",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "xktModel",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 184,
    "kind": "function",
    "name": "deflateData",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~deflateData",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 195,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"positions\": *, \"normals\": *, \"indices\": *, \"edgeIndices\": *, \"matrices\": *, \"reusedPrimitivesDecodeMatrix\": *, \"eachPrimitivePositionsAndNormalsPortion\": *, \"eachPrimitiveIndicesPortion\": *, \"eachPrimitiveEdgeIndicesPortion\": *, \"eachPrimitiveColorAndOpacity\": *, \"primitiveInstances\": *, \"eachEntityId\": *, \"eachEntityPrimitiveInstancesPortion\": *, \"eachEntityMatricesPortion\": *, \"eachTileAABB\": *, \"eachTileEntitiesPortion\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 185,
    "kind": "function",
    "name": "createArrayBuffer",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~createArrayBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 227,
    "undocument": true,
    "params": [
      {
        "name": "deflatedData",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 186,
    "kind": "function",
    "name": "toArrayBuffer",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~toArrayBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 256,
    "undocument": true,
    "params": [
      {
        "name": "elements",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 187,
    "kind": "function",
    "name": "writeXKTModelToArrayBuffer",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~writeXKTModelToArrayBuffer",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-xkt-utils/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": "{writeXKTModelToArrayBuffer}",
    "description": "Writes an {@link XKTModel} to an {@link ArrayBuffer}.",
    "lineNumber": 16,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ArrayBuffer} The {@link ArrayBuffer}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "xktModel",
        "description": "The {@link XKTModel}."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayBuffer"
      ],
      "spread": false,
      "description": "The {@link ArrayBuffer}."
    }
  },
  {
    "kind": "index",
    "content": "\n# xeokit-xkt-utils\n\n[![npm version](https://badge.fury.io/js/%40xeokit%2Fxeokit-xkt-utils.svg)](https://badge.fury.io/js/%40xeokit%2Fxeokit-xkt-utils)\n\n**````xeokit-xkt-utils````** is a library of JavaScript tools for creating ````XKT```` model geometry files, which we then can load \ninto [xeokit](http://xeokit.io). Using this library in either browser or node, we can convert glTF into ````XKT````, and can even generate ````XKT```` files programmatically.\n\nThis library is currently used within the [xeokit-gltf-to-xkt](https://github.com/xeokit/xeokit-gltf-to-xkt) tool to convert glTF to ````XKT````.    \n\n![Spatial partitioning](http://xeokit.io/img/BimdataViewerCroppedNarrow.jpg)\n\n## Contents\n- [Links](#links)\n- [Features](#features)\n- [JavaScript API](#javascript-api)\n    + [XKTModel](#xktmodel)\n    + [Building an XKTModel](#building-an-xktmodel)\n    + [Serializing the XKTModel to an ArrayBuffer](#serializing-the-xktmodel-to-an-arraybuffer)\n    + [Validating the ArrayBuffer](#validating-the-arraybuffer)\n    + [Loading the ArrayBuffer into a Viewer](#loading-the-arraybuffer-into-a-viewer)\n    + [Loading glTF into an XKTModel](#loading-gltf-into-an-xktmodel)\n- [Building](#building)\n    \n\n## Links\n\n* [API Documentation](https://xeokit.github.io/xeokit-xkt-utils/docs)\n* [Live Tests](https://xeokit.github.io/xeokit-xkt-utils/examples)\n* [Source Code](https://github.com/xeokit/xeokit-xkt-utils)\n* [npm](https://www.npmjs.com/package/@xeokit/xeokit-xkt-utils)\n\n## Features\n\n* Generate XKT files programmatically.  \n* Convert glTF into XKT files.\n* Full-precision geometry without the cost of storing double-precision values.\n* Geometry compression using instancing, quantization, oct-encoding and gzip.\n* Works in browser and node.   \n\n## JavaScript API\n\n#### XKTModel\n\nAt the center of ````xeokit-xkt-utils```` is the  [**````XKTModel````**](https://xeokit.github.io/xeokit-xkt-utils/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) \nclass, which represents an ````XKT```` model. \n\n````XKTModel```` provides builder methods, with which we can programmatically populate it with 3D objects.  \n\n````xeokit-xkt-utils```` also provides these utility functions for loading, serializing and validating ````XKTModels````:\n\n* [**````loadGLTFIntoXKTModel````**](https://xeokit.github.io/xeokit-xkt-utils/docs/function/index.html#static-function-loadGLTFIntoXKTModel) loads glTF JSON into an ````XKTModel````.\n* [**````writeXKTModelToArrayBuffer````**](https://xeokit.github.io/xeokit-xkt-utils/docs/function/index.html#static-function-writeXKTModelToArrayBuffer) serializes an ````XKTModel```` to an ````ArrayBuffer````.\n* [**````validateXKTArrayBuffer````**](https://xeokit.github.io/xeokit-xkt-utils/docs/function/index.html#static-function-validateXKTArrayBuffer) validates an ````ArrayBuffer```` against the ````XKTModel```` it was serialized from. \n\n#### Building an XKTModel\n\nTo demonstrate the API, let's use [````XKTModel````](https://xeokit.github.io/xeokit-xkt-utils/docs/class/src/XKTModel/XKTModel.js~XKTModel.html)'s builder\n methods to programmatically build a model that resembles the screenshot below. Then we'll serialize the ````XKTModel```` to an \n ````ArrayBuffer````, which we'll finally load that into a xeokit [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html)\n using [````XKTLoaderPlugin````](https://xeokit.github.io/xeokit-sdk/docs/class/src/plugins/XKTLoaderPlugin/XKTLoaderPlugin.js~XKTLoaderPlugin.html). \n\nWe'll code this example to run in the browser, using the ES module in [xeokit-xkt-utils.es.js](./dist/xeokit-xkt-utils.es.js). We could also code it \nto run on node, using the CommonJS module in [xeokit-xkt-utils.cjs.js](./dist/xeokit-xkt-utils.cjs.js). \n\n[![XKTModel Example](http://xeokit.io/img/docs/PerformanceModel/PerformanceModel.png)](https://xeokit.github.io/xeokit-xkt-utils/examples/#XKTModel_generate_instancing)\n \n[[Run this example](https://xeokit.github.io/xeokit-xkt-utils/examples/#XKTModel_generate_instancing)]\n \n\n````javascript\n\nimport {XKTModel, writeXKTModelToArrayBuffer, validateXKTArrayBuffer} from \"./dist/xeokit-xkt-utils.es.js\";\n\n// Or in node:\n// const {XKTModel, loadGLTFIntoXKTModel, writeXKTModelToArrayBuffer} = require(\"./xeokit-xkt-utils.cjs.js\");\n\nconst xktModel = new XKTModel();\n\nxktModel.createPrimitive({\n     primitiveId: \"legPrimitive\",\n     primitiveType: \"triangles\",\n     positions: [\n         1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1,\n         -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1,\n         -1, -1, -1, -1, -1, 1, -1, 1, 1, -1\n     ],\n     normals: [\n         0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,\n         -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0,\n         -1, 0, 0, -1\n     ],\n     indices: [\n         0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19,\n         20, 21, 22, 20, 22, 23\n     ],\n     color: [255, 0, 0],\n     opacity: 255\n });\n\nxktModel.createEntity({\n     entityId: \"leg1\",\n     primitiveIds: [\"legPrimitive\"],\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0]\n });\n\nxktModel.createEntity({\n     entityId: \"leg2\",\n     primitiveIds: [\"legPrimitive\"],\n     position: [4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0]\n });\n\nxktModel.createEntity({\n     entityId: \"leg3\",\n     primitiveIds: [\"legPrimitive\"],\n     position: [4, -6, 4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0]\n });\n\nxktModel.createEntity({\n     entityId: \"leg4\",\n     primitiveIds: [\"legPrimitive\"],\n     position: [-4, -6, 4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0]\n });\n\nxktModel.createEntity({\n     entityId: \"top\",\n     primitiveIds: [\"legPrimitive\"],\n     position: [0, -3, 0],\n     scale: [6, 0.5, 6],\n     rotation: [0, 0, 0]\n });\n````\n\nOnce we've built our [````XKTModel````](https://xeokit.github.io/xeokit-xkt-utils/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) we need to finalize it. Then it's ready to use.\n\n````javascript\nxktModel.finalize();\n````\n\n#### Serializing the XKTModel to an ArrayBuffer\n\nNext, we'll use  [````writeXKTModelToArrayBuffer````](https://xeokit.github.io/xeokit-xkt-utils/docs/function/index.html#static-function-writeXKTModelToArrayBuffer)  to serialize our [````XKTModel````](https://xeokit.github.io/xeokit-xkt-utils/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) to an ````ArrayBuffer````.\n\n````javascript\nconst xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel);\n````\n\n#### Validating the ArrayBuffer\n\nNow we'll use [````validateXKTArrayBuffer````](https://xeokit.github.io/xeokit-xkt-utils/docs/function/index.html#static-function-validateXKTArrayBuffer) to validate \nthe ````ArrayBuffer```` against our [````XKTModel````](https://xeokit.github.io/xeokit-xkt-utils/docs/class/src/XKTModel/XKTModel.js~XKTModel.html). If this function \nfinds any errors, it will log them to the console and return ````false````. Otherwise, it will return ````true```` to indicate that the ````ArrayBuffer```` is correct. \n\n````javascript\nconst xktArrayBufferValid = validateXKTArrayBuffer(xktArrayBuffer, xktModel);\n\nif (!xktArrayBufferValid) {\n    console.error(\"XKT array buffer is invalid!\");\n}\n````\n\n#### Loading the ArrayBuffer into a Viewer\n\nLet's now create a [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html), then load the ````ArrayBuffer```` into it using an [````XKTLoaderPlugin````](https://xeokit.github.io/xeokit-sdk/docs/class/src/plugins/XKTLoaderPlugin/XKTLoaderPlugin.js~XKTLoaderPlugin.html).\n\n````javascript\nconst viewer = new Viewer({\n    canvasId: \"myCanvas\"\n});\n\nconst xktLoader = new XKTLoaderPlugin(viewer);\n\nconst model = xktLoader.load({\n    id: \"myModel\",\n    xkt: xktArrayBuffer\n});\n````\n\nNote that the ````XKTLoaderPlugin```` could also load our ````ArrayBuffer```` from a URL.\n\nFinally, let's fit the whole model in view.\n\n````javascript\nviewer.cameraFlight.flyTo(model);\n````\n\n#### Loading glTF into an XKTModel\n\nLet's use [````loadGLTFIntoXKTModel````](https://xeokit.github.io/xeokit-xkt-utils/docs/function/index.html#static-function-loadGLTFIntoXKTModel) to parse glTF into an [````XKTModel````](https://xeokit.github.io/xeokit-xkt-utils/docs/class/src/XKTModel/XKTModel.js~XKTModel.html). \n\nWe'll also use the classes and functions introduced in the previous examples to serialize the [````XKTModel````](https://xeokit.github.io/xeokit-xkt-utils/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) to an ````ArrayBuffer````, then validate the ````ArrayBuffer```` and load it into a [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html).\n\n````javascript\nconst viewer = new Viewer({\n    canvasId: \"myCanvas\"\n});\n\nconst xktLoader = new XKTLoaderPlugin(viewer);\n\nutils.loadJSON(\"./models/gltf/MAP/MAP.gltf\", (json) => {\n\n        const xktModel = new XKTModel();\n\n        loadGLTFIntoXKTModel(json, xktModel).then(() => {\n      \n            const xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel);\n\n            const xktArrayBufferValid = validateXKTArrayBuffer(xktArrayBuffer, xktModel);\n\n            xktLoader.load({\n                id: \"myModel\",\n                xkt: xktArrayBuffer\n            });\n\n            viewer.cameraFlight.flyTo(viewer.scene);\n        });\n    },\n    (errMsg) => {  });\n````\n\n## Building \n\nBuilding the binaries in [````./dist````](https://xeokit.github.io/xeokit-xkt-utils/dist):\n\n````bash\nnpm update\nnpm run build\n````\n\nThis will build:\n\n* [./dist/xeokit-xkt-utils.cjs.js](./dist/xeokit-xkt-utils.cjs.js) - CommonJS module\n* [./dist/xeokit-xkt-utils.es.js](./dist/xeokit-xkt-utils.es.js) - ES module\n\nBuilding the JavaScript API documentation in [````./docs````](https://xeokit.github.io/xeokit-xkt-utils/docs):\n\n````bash\nnpm run docs\n````\n\nBuilding the live tests in [````./examples````](https://xeokit.github.io/xeokit-xkt-utils/examples):\n\n````bash\ncd examples\nnpm update\nnpm run build\n````\n",
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-tools/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"@xeokit/xeokit-xkt-utils\",\n  \"version\": \"0.0.5\",\n  \"description\": \"JavaScript utilities to create .XKT files\",\n  \"main\": \"index.js\",\n  \"directories\": {},\n  \"scripts\": {\n    \"test\": \"mocha\",\n    \"build\": \" rollup -c\",\n    \"docs\": \"./node_modules/.bin/esdoc\",\n    \"publish\": \"npm publish --access public\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/xeokit/xeokit-xkt-utils.git\"\n  },\n  \"keywords\": [\n    \"xeolabs\",\n    \"xeokit\",\n    \"bim\",\n    \"ifc\",\n    \"webgl\",\n    \"xkt\",\n    \"gltf\"\n  ],\n  \"author\": \"Lindsay Kay\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/xeokit/xeokit-xkt-utils/issues\"\n  },\n  \"homepage\": \"https://github.com/xeokit/xeokit-xkt-utils#readme\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"@rollup/plugin-commonjs\": \"^15.1.0\",\n    \"mocha\": \"^8.1.3\",\n    \"autoprefixer\": \"^9.8.5\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"rollup\": \"^1.32.1\",\n    \"rollup-plugin-minify-es\": \"^1.1.1\",\n    \"rollup-plugin-node-resolve\": \"^5.2.0\"\n  },\n  \"files\": [\n    \"/dist\",\n    \"src\"\n  ]\n}\n",
    "longname": "/home/lindsay/xeolabs/xeokit/xeokit-xkt-tools/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]